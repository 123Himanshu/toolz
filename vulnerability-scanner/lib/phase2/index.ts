/**
 * Phase 2: Centralized Vulnerability Storage, Normalization, Merging & Correlation
 * 
 * Main entry point for Phase 2 functionality
 */

// Types
export * from './types';

// Parsers
export { getParser, parseToolOutput } from './parsers';

// Deduplication
export { DeduplicationEngine, deduplicateVulnerabilities } from './deduplication';
export type { DeduplicationResult, DeduplicationConfig } from './deduplication';

// Risk Scoring
export { RiskScoringEngine, calculateRiskScore } from './risk-scoring';
export type { RiskScoringConfig } from './risk-scoring';

// Correlation
export { CorrelationEngine, correlateFindings } from './correlation';
export type { CorrelationResult } from './correlation';

// Attack Path Generation
export { AttackPathGenerator, generateAttackPaths } from './attack-path';
export type { AttackPathConfig } from './attack-path';

// Storage
export { Phase2Storage, getPhase2Storage } from './storage';

// Threat Intelligence
export { enrichWithThreatIntel, batchEnrichVulnerabilities, calculateThreatAdjustedRisk } from './threat-intel';

// Export Formats
export { exportResults } from './export';
export type { ExportFormat, ExportOptions, ExportData } from './export';

// Remediation Tracking
export { 
  updateRemediationStatus, 
  getRemediationStatus, 
  getRemediationStats,
  generateRemediationPlan 
} from './remediation';
export type { RemediationStatus, RemediationRecord, RemediationPlan } from './remediation';

// Historical Trending
export { recordTrendingData, getTrendingForTarget, getOverallTrending, getRiskTrend } from './trending';
export type { TrendingDataPoint, TrendAnalysis } from './trending';

// ============================================================================
// MAIN PROCESSING PIPELINE
// ============================================================================

import { parseToolOutput } from './parsers';
import { deduplicateVulnerabilities } from './deduplication';
import { calculateRiskScore } from './risk-scoring';
import { correlateFindings } from './correlation';
import { generateAttackPaths } from './attack-path';
import { getPhase2Storage } from './storage';
import { recordTrendingData } from './trending';
import { batchEnrichVulnerabilities } from './threat-intel';
import {
  NormalizedVulnerability,
  DiscoveredHost,
  DiscoveredService,
  ScanSession,
  AttackPath
} from './types';

export interface ProcessingResult {
  // Normalized data
  vulnerabilities: NormalizedVulnerability[];
  hosts: DiscoveredHost[];
  services: DiscoveredService[];
  
  // Deduplication
  deduplication: {
    unique: number;
    duplicates: number;
    mergedCount: number;
  };
  
  // Risk scoring
  riskScore: {
    overall: number;
    label: string;
    bySeverity: Record<string, number>;
  };
  
  // Correlation
  correlation: {
    crossScannerVerified: number;
    cveCorrelations: number;
  };
  
  // Attack paths
  attackPaths: AttackPath[];
  
  // Session
  session: ScanSession;
}

/**
 * Process raw scan results through the Phase 2 pipeline
 */
export async function processScanResults(
  scanId: string,
  target: string,
  rawResults: Record<string, any>,
  tools: string[]
): Promise<ProcessingResult> {
  const storage = getPhase2Storage();
  const startTime = new Date();

  // Step 1: Parse and normalize all tool outputs
  let allVulnerabilities: NormalizedVulnerability[] = [];
  let allHosts: DiscoveredHost[] = [];
  let allServices: DiscoveredService[] = [];

  for (const tool of tools) {
    const rawOutput = rawResults[tool];
    if (!rawOutput) continue;

    // Store raw output
    storage.storeRawOutput(scanId, tool, rawOutput);

    // Parse
    const parsed = parseToolOutput(tool, rawOutput, scanId);
    allVulnerabilities.push(...parsed.vulnerabilities);
    allHosts.push(...parsed.hosts);
    allServices.push(...parsed.services);
  }

  // Step 2: Deduplicate vulnerabilities
  const deduplicationResult = deduplicateVulnerabilities(allVulnerabilities);
  const uniqueVulnerabilities = deduplicationResult.unique;

  // Step 3: Merge hosts and services
  const mergedHosts = mergeHostRecords(allHosts);
  const mergedServices = mergeServiceRecords(allServices);

  // Step 4: Calculate risk scores
  const riskResult = calculateRiskScore(uniqueVulnerabilities, mergedHosts, mergedServices);

  // Update host risk scores
  for (const host of mergedHosts) {
    const hostRisk = riskResult.byHost.get(host.ip);
    if (hostRisk) {
      host.riskScore = hostRisk.overall;
    }
  }

  // Step 5: Correlate findings
  const correlationResult = correlateFindings(uniqueVulnerabilities, mergedHosts, mergedServices);

  // Update vulnerability confidence based on correlation
  for (const vuln of uniqueVulnerabilities) {
    const correlation = correlationResult.correlatedFindings.get(vuln.id);
    if (correlation) {
      vuln.confidence = correlation.correlatedConfidence;
    }
  }

  // Step 6: Generate attack paths
  const attackPaths = generateAttackPaths(uniqueVulnerabilities, mergedHosts, mergedServices);
  for (const path of attackPaths) {
    path.scanId = scanId;
  }

  // Step 7: Create session record
  const session: ScanSession = {
    id: scanId,
    target,
    scanType: 'active',
    tools,
    toolResults: Object.fromEntries(
      tools.map(t => [t, rawResults[t]?.success ? 'success' : 'failed'])
    ),
    startedAt: startTime.toISOString(),
    completedAt: new Date().toISOString(),
    duration: (Date.now() - startTime.getTime()) / 1000,
    hostsDiscovered: mergedHosts.length,
    servicesDiscovered: mergedServices.length,
    vulnerabilitiesFound: uniqueVulnerabilities.length,
    severityBreakdown: riskResult.bySeverity as { critical: number; high: number; medium: number; low: number; info: number },
    totalFindings: allVulnerabilities.length,
    uniqueFindings: uniqueVulnerabilities.length,
    duplicatesRemoved: deduplicationResult.mergedCount,
    overallRiskScore: riskResult.overall.overall
  };

  // Step 8: Enrich with threat intelligence (async, non-blocking)
  batchEnrichVulnerabilities(uniqueVulnerabilities).catch(err => {
    console.error('Threat intel enrichment failed:', err);
  });

  // Step 9: Store everything
  storage.storeVulnerabilities(uniqueVulnerabilities);
  storage.storeHosts(mergedHosts);
  storage.storeServices(mergedServices);
  storage.storeSession(session);
  storage.storeAttackPaths(attackPaths);

  // Step 10: Record trending data
  recordTrendingData(session);

  return {
    vulnerabilities: uniqueVulnerabilities,
    hosts: mergedHosts,
    services: mergedServices,
    deduplication: {
      unique: uniqueVulnerabilities.length,
      duplicates: deduplicationResult.duplicates.length,
      mergedCount: deduplicationResult.mergedCount
    },
    riskScore: {
      overall: riskResult.overall.overall,
      label: riskResult.overall.label,
      bySeverity: riskResult.bySeverity
    },
    correlation: {
      crossScannerVerified: correlationResult.stats.crossScannerVerified,
      cveCorrelations: correlationResult.stats.cveCorrelations
    },
    attackPaths,
    session
  };
}

/**
 * Merge host records from multiple scanners
 */
function mergeHostRecords(hosts: DiscoveredHost[]): DiscoveredHost[] {
  const hostMap = new Map<string, DiscoveredHost>();

  for (const host of hosts) {
    const existing = hostMap.get(host.ip);
    
    if (existing) {
      // Merge
      existing.hostname = host.hostname || existing.hostname;
      existing.lastSeen = host.lastSeen;
      existing.discoveredBy = [...new Set([...existing.discoveredBy, ...host.discoveredBy])];
      existing.openPorts = [...new Set([...existing.openPorts, ...host.openPorts])];
      existing.services = [...new Set([...existing.services, ...host.services])];
      existing.vulnerabilityCount.critical += host.vulnerabilityCount.critical;
      existing.vulnerabilityCount.high += host.vulnerabilityCount.high;
      existing.vulnerabilityCount.medium += host.vulnerabilityCount.medium;
      existing.vulnerabilityCount.low += host.vulnerabilityCount.low;
      existing.vulnerabilityCount.info += host.vulnerabilityCount.info;
    } else {
      hostMap.set(host.ip, { ...host });
    }
  }

  return Array.from(hostMap.values());
}

/**
 * Merge service records from multiple scanners
 */
function mergeServiceRecords(services: DiscoveredService[]): DiscoveredService[] {
  const serviceMap = new Map<string, DiscoveredService>();

  for (const service of services) {
    const key = `${service.host}:${service.port}`;
    const existing = serviceMap.get(key);
    
    if (existing) {
      // Merge
      existing.version = service.version || existing.version;
      existing.product = service.product || existing.product;
      existing.lastSeen = service.lastSeen;
      existing.discoveredBy = [...new Set([...existing.discoveredBy, ...service.discoveredBy])];
      existing.vulnerabilityCount += service.vulnerabilityCount;
    } else {
      serviceMap.set(key, { ...service });
    }
  }

  return Array.from(serviceMap.values());
}

/**
 * Get summary for a scan
 */
export function getScanSummary(scanId: string): {
  session: ScanSession | undefined;
  vulnerabilities: NormalizedVulnerability[];
  hosts: DiscoveredHost[];
  services: DiscoveredService[];
  attackPaths: AttackPath[];
  statistics: {
    totalVulnerabilities: number;
    totalHosts: number;
    totalServices: number;
    totalSessions: number;
    severityBreakdown: Record<string, number>;
    scannerBreakdown: Record<string, number>;
  };
} {
  const storage = getPhase2Storage();
  
  return {
    session: storage.getSession(scanId),
    vulnerabilities: storage.getVulnerabilitiesByScan(scanId),
    hosts: storage.getAllHosts().filter(h => 
      storage.getVulnerabilitiesByScan(scanId).some(v => v.host === h.ip)
    ),
    services: storage.getAllServices(),
    attackPaths: storage.getAttackPathsByScan(scanId),
    statistics: storage.getStatistics()
  };
}

/**
 * Query vulnerabilities across all scans
 */
export function queryVulnerabilities(query: import('./types').VulnerabilityQuery) {
  const storage = getPhase2Storage();
  return storage.queryVulnerabilities(query);
}

/**
 * Get all hosts inventory
 */
export function getHostsInventory() {
  const storage = getPhase2Storage();
  return storage.getAllHosts();
}

/**
 * Get all services inventory
 */
export function getServicesInventory() {
  const storage = getPhase2Storage();
  return storage.getAllServices();
}

/**
 * Get overall statistics
 */
export function getOverallStatistics() {
  const storage = getPhase2Storage();
  return storage.getStatistics();
}
