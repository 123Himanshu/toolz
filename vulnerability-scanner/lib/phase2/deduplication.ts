/**
 * Deduplication Engine
 * Detects and merges duplicate findings across scanners
 */

import { NormalizedVulnerability, Severity } from './types';

export interface DeduplicationResult {
  unique: NormalizedVulnerability[];
  duplicates: NormalizedVulnerability[];
  mergedCount: number;
  stats: {
    totalInput: number;
    uniqueOutput: number;
    duplicatesFound: number;
    mergesByScanner: Record<string, number>;
  };
}

export interface DeduplicationConfig {
  // Matching thresholds
  severityTolerance: number;      // Max severity score difference (default: 2)
  titleSimilarityThreshold: number; // 0-1 similarity threshold (default: 0.8)
  
  // Matching rules
  requireSameHost: boolean;       // Must match on host (default: true)
  requireSamePort: boolean;       // Must match on port (default: false)
  requireSameCVE: boolean;        // Must match on CVE if present (default: true)
  
  // Merge behavior
  keepHighestSeverity: boolean;   // Keep highest severity when merging (default: true)
  mergeEvidence: boolean;         // Combine evidence from all sources (default: true)
}

const DEFAULT_CONFIG: DeduplicationConfig = {
  severityTolerance: 2,
  titleSimilarityThreshold: 0.8,
  requireSameHost: true,
  requireSamePort: false,
  requireSameCVE: true,
  keepHighestSeverity: true,
  mergeEvidence: true
};

export class DeduplicationEngine {
  private config: DeduplicationConfig;

  constructor(config: Partial<DeduplicationConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Deduplicate vulnerabilities
   */
  deduplicate(vulnerabilities: NormalizedVulnerability[]): DeduplicationResult {
    const unique: NormalizedVulnerability[] = [];
    const duplicates: NormalizedVulnerability[] = [];
    const mergesByScanner: Record<string, number> = {};

    // Group by fingerprint first (exact matches)
    const fingerprintGroups = this.groupByFingerprint(vulnerabilities);

    // Process each group
    for (const group of fingerprintGroups.values()) {
      if (group.length === 1) {
        unique.push(group[0]);
      } else {
        // Merge duplicates
        const merged = this.mergeGroup(group);
        unique.push(merged);
        
        // Track duplicates
        for (let i = 1; i < group.length; i++) {
          const dup = { ...group[i], duplicateOf: merged.id };
          duplicates.push(dup);
          mergesByScanner[group[i].scanner] = (mergesByScanner[group[i].scanner] || 0) + 1;
        }
      }
    }

    // Second pass: fuzzy matching for similar vulnerabilities
    const fuzzyResult = this.fuzzyDeduplicate(unique);

    return {
      unique: fuzzyResult.unique,
      duplicates: [...duplicates, ...fuzzyResult.duplicates],
      mergedCount: duplicates.length + fuzzyResult.duplicates.length,
      stats: {
        totalInput: vulnerabilities.length,
        uniqueOutput: fuzzyResult.unique.length,
        duplicatesFound: duplicates.length + fuzzyResult.duplicates.length,
        mergesByScanner
      }
    };
  }

  /**
   * Group vulnerabilities by fingerprint
   */
  private groupByFingerprint(vulns: NormalizedVulnerability[]): Map<string, NormalizedVulnerability[]> {
    const groups = new Map<string, NormalizedVulnerability[]>();

    for (const vuln of vulns) {
      const key = vuln.fingerprint;
      if (!groups.has(key)) {
        groups.set(key, []);
      }
      groups.get(key)!.push(vuln);
    }

    return groups;
  }

  /**
   * Merge a group of duplicate vulnerabilities
   */
  private mergeGroup(group: NormalizedVulnerability[]): NormalizedVulnerability {
    // Sort by severity (highest first) and confidence
    const sorted = [...group].sort((a, b) => {
      if (b.severity.score !== a.severity.score) {
        return b.severity.score - a.severity.score;
      }
      return b.confidence - a.confidence;
    });

    const primary = sorted[0];
    const merged: NormalizedVulnerability = { ...primary };

    // Merge data from all sources
    const allScanners = new Set(group.map(v => v.scanner));
    const allCVEs = new Set(group.flatMap(v => v.cve || []));
    const allCWEs = new Set(group.flatMap(v => v.cwe || []));
    const allRefs = new Set(group.flatMap(v => v.references || []));

    // Update merged vulnerability
    merged.duplicateCount = group.length;
    merged.cve = [...allCVEs];
    merged.cwe = [...allCWEs];
    merged.references = [...allRefs];

    // Merge evidence if configured
    if (this.config.mergeEvidence) {
      const evidenceParts = group
        .filter(v => v.evidence)
        .map(v => `[${v.scanner}] ${v.evidence}`);
      if (evidenceParts.length > 0) {
        merged.evidence = evidenceParts.join('\n\n');
      }
    }

    // Keep highest severity if configured
    if (this.config.keepHighestSeverity) {
      const maxSeverity = Math.max(...group.map(v => v.severity.score));
      if (maxSeverity > merged.severity.score) {
        merged.severity = this.scoreToSeverity(maxSeverity);
      }
    }

    // Boost confidence for multi-scanner confirmation
    if (allScanners.size > 1) {
      merged.confidence = Math.min(100, merged.confidence + (allScanners.size - 1) * 10);
    }

    // Add note about sources
    const scannerList = [...allScanners].join(', ');
    merged.description = `${merged.description}\n\n[Confirmed by ${allScanners.size} scanner(s): ${scannerList}]`;

    return merged;
  }

  /**
   * Fuzzy deduplication for similar but not identical findings
   */
  private fuzzyDeduplicate(vulns: NormalizedVulnerability[]): {
    unique: NormalizedVulnerability[];
    duplicates: NormalizedVulnerability[];
  } {
    const unique: NormalizedVulnerability[] = [];
    const duplicates: NormalizedVulnerability[] = [];
    const processed = new Set<string>();

    for (const vuln of vulns) {
      if (processed.has(vuln.id)) continue;

      // Find similar vulnerabilities
      const similar = vulns.filter(v => 
        !processed.has(v.id) && 
        v.id !== vuln.id && 
        this.isSimilar(vuln, v)
      );

      if (similar.length === 0) {
        unique.push(vuln);
        processed.add(vuln.id);
      } else {
        // Merge similar findings
        const group = [vuln, ...similar];
        const merged = this.mergeGroup(group);
        unique.push(merged);

        for (const v of group) {
          processed.add(v.id);
          if (v.id !== merged.id) {
            duplicates.push({ ...v, duplicateOf: merged.id });
          }
        }
      }
    }

    return { unique, duplicates };
  }

  /**
   * Check if two vulnerabilities are similar
   */
  private isSimilar(a: NormalizedVulnerability, b: NormalizedVulnerability): boolean {
    // Must match on host if required
    if (this.config.requireSameHost && a.host !== b.host) {
      return false;
    }

    // Must match on port if required
    if (this.config.requireSamePort && a.port !== b.port) {
      return false;
    }

    // Check CVE match
    if (this.config.requireSameCVE) {
      const aCVEs = new Set(a.cve || []);
      const bCVEs = new Set(b.cve || []);
      
      if (aCVEs.size > 0 && bCVEs.size > 0) {
        const intersection = [...aCVEs].filter(cve => bCVEs.has(cve));
        if (intersection.length > 0) {
          return true; // Same CVE = definitely similar
        }
      }
    }

    // Check severity tolerance
    const severityDiff = Math.abs(a.severity.score - b.severity.score);
    if (severityDiff > this.config.severityTolerance) {
      return false;
    }

    // Check title similarity
    const titleSimilarity = this.calculateSimilarity(a.title, b.title);
    if (titleSimilarity >= this.config.titleSimilarityThreshold) {
      return true;
    }

    // Check scanner ID match (same template/plugin)
    if (a.scannerId && b.scannerId && a.scannerId === b.scannerId) {
      return true;
    }

    return false;
  }

  /**
   * Calculate string similarity (Jaccard index on words)
   */
  private calculateSimilarity(a: string, b: string): number {
    const wordsA = new Set(a.toLowerCase().split(/\s+/).filter(w => w.length > 2));
    const wordsB = new Set(b.toLowerCase().split(/\s+/).filter(w => w.length > 2));

    if (wordsA.size === 0 || wordsB.size === 0) return 0;

    const intersection = [...wordsA].filter(w => wordsB.has(w)).length;
    const union = new Set([...wordsA, ...wordsB]).size;

    return intersection / union;
  }

  /**
   * Convert score to severity object
   */
  private scoreToSeverity(score: number): Severity {
    let label: Severity['label'];
    
    if (score >= 9.0) label = 'critical';
    else if (score >= 7.0) label = 'high';
    else if (score >= 4.0) label = 'medium';
    else if (score >= 0.1) label = 'low';
    else label = 'info';

    return { score, label };
  }
}

/**
 * Quick deduplication function
 */
export function deduplicateVulnerabilities(
  vulnerabilities: NormalizedVulnerability[],
  config?: Partial<DeduplicationConfig>
): DeduplicationResult {
  const engine = new DeduplicationEngine(config);
  return engine.deduplicate(vulnerabilities);
}
