/**
 * Risk Scoring Engine
 * Calculate composite risk scores for vulnerabilities, hosts, and overall scan
 */

import { 
  NormalizedVulnerability, 
  DiscoveredHost, 
  DiscoveredService,
  RiskScore, 
  RiskFactors 
} from './types';

export interface RiskScoringConfig {
  // Weight factors (must sum to 1.0)
  weights: {
    cvss: number;           // Base CVSS weight (default: 0.4)
    exposure: number;       // Exposure weight (default: 0.25)
    exploitability: number; // Exploit availability weight (default: 0.2)
    reachability: number;   // Lateral movement weight (default: 0.15)
  };
  
  // Exposure scoring
  internetExposedPorts: number[];  // Ports considered internet-exposed
  criticalServices: string[];       // Services considered critical
  
  // Asset criticality (can be customized per host)
  defaultAssetCriticality: number;  // Default criticality (0-10)
}

const DEFAULT_CONFIG: RiskScoringConfig = {
  weights: {
    cvss: 0.4,
    exposure: 0.25,
    exploitability: 0.2,
    reachability: 0.15
  },
  internetExposedPorts: [21, 22, 23, 25, 80, 443, 445, 3389, 8080, 8443],
  criticalServices: ['ssh', 'rdp', 'smb', 'database', 'mysql', 'postgresql', 'mongodb', 'redis'],
  defaultAssetCriticality: 5
};

export class RiskScoringEngine {
  private config: RiskScoringConfig;
  private knownExploits: Set<string>; // CVEs with known exploits

  constructor(config: Partial<RiskScoringConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.knownExploits = new Set([
      // Common exploited CVEs (sample - would be loaded from threat intel)
      'CVE-2021-44228', // Log4Shell
      'CVE-2021-26855', // ProxyLogon
      'CVE-2021-34527', // PrintNightmare
      'CVE-2020-1472',  // Zerologon
      'CVE-2019-19781', // Citrix ADC
      'CVE-2019-11510', // Pulse Secure
      'CVE-2018-13379', // FortiGate
      'CVE-2017-0144',  // EternalBlue
      'CVE-2014-0160',  // Heartbleed
    ]);
  }

  /**
   * Calculate risk score for a single vulnerability
   */
  scoreVulnerability(
    vuln: NormalizedVulnerability,
    host?: DiscoveredHost,
    services?: DiscoveredService[]
  ): RiskScore {
    const factors = this.calculateFactors(vuln, host, services);
    const overall = this.calculateOverallScore(factors);
    
    return {
      overall,
      factors,
      label: this.scoreToLabel(overall),
      trend: 'stable' // Would be calculated from historical data
    };
  }

  /**
   * Calculate risk score for a host
   */
  scoreHost(
    host: DiscoveredHost,
    vulnerabilities: NormalizedVulnerability[],
    services: DiscoveredService[]
  ): RiskScore {
    // Get vulnerabilities for this host
    const hostVulns = vulnerabilities.filter(v => v.host === host.ip || v.host === host.hostname);
    
    if (hostVulns.length === 0) {
      return {
        overall: 0,
        factors: {
          cvssScore: 0,
          exposureScore: this.calculateExposureScore(host, services),
          reachabilityScore: 0,
          exploitabilityScore: 0,
          assetCriticality: this.config.defaultAssetCriticality
        },
        label: 'low',
        trend: 'stable'
      };
    }

    // Calculate aggregate scores
    const vulnScores = hostVulns.map(v => this.scoreVulnerability(v, host, services));
    
    // Use maximum CVSS and exploitability, average for others
    const maxCvss = Math.max(...vulnScores.map(s => s.factors.cvssScore));
    const maxExploitability = Math.max(...vulnScores.map(s => s.factors.exploitabilityScore));
    const avgExposure = vulnScores.reduce((sum, s) => sum + s.factors.exposureScore, 0) / vulnScores.length;
    const avgReachability = vulnScores.reduce((sum, s) => sum + s.factors.reachabilityScore, 0) / vulnScores.length;

    const factors: RiskFactors = {
      cvssScore: maxCvss,
      exposureScore: avgExposure,
      reachabilityScore: avgReachability,
      exploitabilityScore: maxExploitability,
      assetCriticality: this.config.defaultAssetCriticality
    };

    // Apply vulnerability count multiplier
    const vulnCountMultiplier = Math.min(1.5, 1 + (hostVulns.length - 1) * 0.05);
    const overall = Math.min(100, this.calculateOverallScore(factors) * vulnCountMultiplier);

    return {
      overall,
      factors,
      label: this.scoreToLabel(overall),
      trend: 'stable'
    };
  }

  /**
   * Calculate overall scan risk score
   */
  scoreScan(
    vulnerabilities: NormalizedVulnerability[],
    hosts: DiscoveredHost[],
    services: DiscoveredService[]
  ): {
    overall: RiskScore;
    byHost: Map<string, RiskScore>;
    bySeverity: Record<string, number>;
    topRisks: NormalizedVulnerability[];
  } {
    // Score each host
    const byHost = new Map<string, RiskScore>();
    for (const host of hosts) {
      const hostServices = services.filter(s => s.host === host.ip);
      byHost.set(host.ip, this.scoreHost(host, vulnerabilities, hostServices));
    }

    // Calculate severity breakdown
    const bySeverity: Record<string, number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };
    for (const vuln of vulnerabilities) {
      bySeverity[vuln.severity.label]++;
    }

    // Get top risks (highest scoring vulnerabilities)
    const scoredVulns = vulnerabilities.map(v => ({
      vuln: v,
      score: this.scoreVulnerability(v).overall
    }));
    scoredVulns.sort((a, b) => b.score - a.score);
    const topRisks = scoredVulns.slice(0, 10).map(sv => sv.vuln);

    // Calculate overall score
    const hostScores = Array.from(byHost.values());
    const maxHostScore = hostScores.length > 0 
      ? Math.max(...hostScores.map(s => s.overall))
      : 0;
    
    // Weight by severity counts
    const severityWeight = 
      (bySeverity.critical * 10 + bySeverity.high * 7 + bySeverity.medium * 4 + bySeverity.low * 1) /
      Math.max(1, vulnerabilities.length);

    const overallScore = Math.min(100, (maxHostScore * 0.6) + (severityWeight * 4));

    return {
      overall: {
        overall: overallScore,
        factors: {
          cvssScore: Math.max(...vulnerabilities.map(v => v.severity.score), 0),
          exposureScore: hostScores.reduce((sum, s) => sum + s.factors.exposureScore, 0) / Math.max(1, hostScores.length),
          reachabilityScore: hostScores.reduce((sum, s) => sum + s.factors.reachabilityScore, 0) / Math.max(1, hostScores.length),
          exploitabilityScore: Math.max(...hostScores.map(s => s.factors.exploitabilityScore), 0),
          assetCriticality: this.config.defaultAssetCriticality
        },
        label: this.scoreToLabel(overallScore),
        trend: 'stable'
      },
      byHost,
      bySeverity,
      topRisks
    };
  }

  /**
   * Calculate risk factors for a vulnerability
   */
  private calculateFactors(
    vuln: NormalizedVulnerability,
    host?: DiscoveredHost,
    services?: DiscoveredService[]
  ): RiskFactors {
    return {
      cvssScore: vuln.severity.score,
      exposureScore: this.calculateExposureScore(host, services, vuln.port),
      reachabilityScore: this.calculateReachabilityScore(vuln, host),
      exploitabilityScore: this.calculateExploitabilityScore(vuln),
      assetCriticality: this.config.defaultAssetCriticality
    };
  }

  /**
   * Calculate exposure score (0-10)
   */
  private calculateExposureScore(
    host?: DiscoveredHost,
    services?: DiscoveredService[],
    port?: number
  ): number {
    let score = 5; // Base score

    if (!host) return score;

    // Check for internet-exposed ports
    const exposedPorts = host.openPorts.filter(p => 
      this.config.internetExposedPorts.includes(p)
    );
    score += exposedPorts.length * 0.5;

    // Check for critical services
    if (services) {
      const criticalServices = services.filter(s =>
        this.config.criticalServices.some(cs => 
          s.service.toLowerCase().includes(cs)
        )
      );
      score += criticalServices.length * 0.5;
    }

    // Specific port exposure
    if (port && this.config.internetExposedPorts.includes(port)) {
      score += 1;
    }

    return Math.min(10, score);
  }

  /**
   * Calculate reachability score (0-10)
   */
  private calculateReachabilityScore(
    vuln: NormalizedVulnerability,
    host?: DiscoveredHost
  ): number {
    let score = 3; // Base score

    // Network services increase reachability
    if (vuln.scannerCategory === 'network') {
      score += 2;
    }

    // Web services are highly reachable
    if (vuln.scannerCategory === 'web') {
      score += 3;
    }

    // Common ports increase reachability
    if (vuln.port) {
      const commonPorts = [80, 443, 22, 21, 25, 3389];
      if (commonPorts.includes(vuln.port)) {
        score += 1;
      }
    }

    // Multiple open ports increase lateral movement potential
    if (host && host.openPorts.length > 5) {
      score += 1;
    }

    return Math.min(10, score);
  }

  /**
   * Calculate exploitability score (0-10)
   */
  private calculateExploitabilityScore(vuln: NormalizedVulnerability): number {
    let score = 3; // Base score

    // Check for known exploits
    if (vuln.cve) {
      for (const cve of vuln.cve) {
        if (this.knownExploits.has(cve)) {
          score += 4;
          break;
        }
      }
    }

    // High severity usually means easier exploitation
    if (vuln.severity.score >= 9) {
      score += 2;
    } else if (vuln.severity.score >= 7) {
      score += 1;
    }

    // Evidence of exploitation increases score
    if (vuln.evidence) {
      score += 1;
    }

    // High confidence findings are more likely exploitable
    if (vuln.confidence >= 90) {
      score += 1;
    }

    return Math.min(10, score);
  }

  /**
   * Calculate overall score from factors (0-100)
   */
  private calculateOverallScore(factors: RiskFactors): number {
    const { weights } = this.config;
    
    // Normalize CVSS to 0-100 scale
    const normalizedCvss = factors.cvssScore * 10;
    const normalizedExposure = factors.exposureScore * 10;
    const normalizedReachability = factors.reachabilityScore * 10;
    const normalizedExploitability = factors.exploitabilityScore * 10;

    const score = 
      (normalizedCvss * weights.cvss) +
      (normalizedExposure * weights.exposure) +
      (normalizedReachability * weights.reachability) +
      (normalizedExploitability * weights.exploitability);

    // Apply asset criticality modifier
    const criticalityModifier = factors.assetCriticality / 10;
    const finalScore = score * (0.5 + criticalityModifier * 0.5);

    return Math.round(Math.min(100, Math.max(0, finalScore)));
  }

  /**
   * Convert score to label
   */
  private scoreToLabel(score: number): RiskScore['label'] {
    if (score >= 80) return 'critical';
    if (score >= 60) return 'high';
    if (score >= 40) return 'medium';
    return 'low';
  }

  /**
   * Add known exploit CVE
   */
  addKnownExploit(cve: string): void {
    this.knownExploits.add(cve.toUpperCase());
  }

  /**
   * Load known exploits from threat intel
   */
  loadKnownExploits(cves: string[]): void {
    for (const cve of cves) {
      this.knownExploits.add(cve.toUpperCase());
    }
  }
}

/**
 * Quick risk scoring function
 */
export function calculateRiskScore(
  vulnerabilities: NormalizedVulnerability[],
  hosts: DiscoveredHost[] = [],
  services: DiscoveredService[] = []
): ReturnType<RiskScoringEngine['scoreScan']> {
  const engine = new RiskScoringEngine();
  return engine.scoreScan(vulnerabilities, hosts, services);
}
