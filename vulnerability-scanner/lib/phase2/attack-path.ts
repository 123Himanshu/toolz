/**
 * Attack Path Generator
 * Generate potential attack paths from vulnerability data
 */

import {
  NormalizedVulnerability,
  DiscoveredHost,
  DiscoveredService,
  AttackPath,
  AttackPathNode,
  AttackPathEdge
} from './types';

export interface AttackPathConfig {
  maxPathLength: number;          // Maximum nodes in a path
  minExploitProbability: number;  // Minimum probability to include (0-1)
  includeInfoFindings: boolean;   // Include info-level findings
}

const DEFAULT_CONFIG: AttackPathConfig = {
  maxPathLength: 10,
  minExploitProbability: 0.1,
  includeInfoFindings: false
};

export class AttackPathGenerator {
  private config: AttackPathConfig;

  constructor(config: Partial<AttackPathConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Generate attack paths from scan data
   */
  generatePaths(
    vulnerabilities: NormalizedVulnerability[],
    hosts: DiscoveredHost[],
    services: DiscoveredService[]
  ): AttackPath[] {
    const paths: AttackPath[] = [];

    // Filter vulnerabilities
    const vulns = this.config.includeInfoFindings
      ? vulnerabilities
      : vulnerabilities.filter(v => v.severity.label !== 'info');

    if (vulns.length === 0) return paths;

    // Build graph
    const { nodes, edges } = this.buildGraph(vulns, hosts, services);

    // Find entry points (internet-facing services)
    const entryPoints = this.findEntryPoints(nodes, services);

    // Find targets (high-value assets)
    const targets = this.findTargets(nodes, hosts);

    // Generate paths from entry points to targets
    for (const entry of entryPoints) {
      for (const target of targets) {
        const path = this.findPath(entry, target, nodes, edges);
        if (path) {
          paths.push(path);
        }
      }
    }

    // Generate vulnerability chain paths
    const chainPaths = this.generateChainPaths(vulns, nodes, edges);
    paths.push(...chainPaths);

    // Sort by risk
    paths.sort((a, b) => b.overallRisk - a.overallRisk);

    return paths.slice(0, 10); // Return top 10 paths
  }

  /**
   * Build attack graph from vulnerabilities
   */
  private buildGraph(
    vulns: NormalizedVulnerability[],
    hosts: DiscoveredHost[],
    services: DiscoveredService[]
  ): { nodes: AttackPathNode[]; edges: AttackPathEdge[] } {
    const nodes: AttackPathNode[] = [];
    const edges: AttackPathEdge[] = [];
    const nodeMap = new Map<string, AttackPathNode>();

    // Create host nodes
    for (const host of hosts) {
      const node: AttackPathNode = {
        id: `host:${host.ip}`,
        type: 'host',
        label: host.hostname || host.ip,
        data: { ip: host.ip, hostname: host.hostname, ports: host.openPorts },
        riskScore: host.riskScore
      };
      nodes.push(node);
      nodeMap.set(node.id, node);
    }

    // Create service nodes
    for (const service of services) {
      const node: AttackPathNode = {
        id: `service:${service.host}:${service.port}`,
        type: 'service',
        label: `${service.service}:${service.port}`,
        data: { host: service.host, port: service.port, service: service.service },
        riskScore: service.riskScore
      };
      nodes.push(node);
      nodeMap.set(node.id, node);

      // Edge from host to service
      edges.push({
        id: `${node.id}-to-host`,
        source: `host:${service.host}`,
        target: node.id,
        type: 'leads_to',
        label: 'exposes',
        probability: 1.0
      });
    }

    // Create vulnerability nodes
    for (const vuln of vulns) {
      const node: AttackPathNode = {
        id: `vuln:${vuln.id}`,
        type: 'vulnerability',
        label: vuln.title.substring(0, 50),
        data: {
          title: vuln.title,
          severity: vuln.severity,
          cve: vuln.cve,
          host: vuln.host,
          port: vuln.port
        },
        riskScore: vuln.severity.score * 10
      };
      nodes.push(node);
      nodeMap.set(node.id, node);

      // Edge from service to vulnerability
      if (vuln.port) {
        const serviceId = `service:${vuln.host}:${vuln.port}`;
        if (nodeMap.has(serviceId)) {
          edges.push({
            id: `${serviceId}-to-${node.id}`,
            source: serviceId,
            target: node.id,
            type: 'exploits',
            label: 'vulnerable to',
            probability: this.calculateExploitProbability(vuln)
          });
        }
      }

      // Edge from host to vulnerability (if no service)
      const hostId = `host:${vuln.host}`;
      if (nodeMap.has(hostId) && !vuln.port) {
        edges.push({
          id: `${hostId}-to-${node.id}`,
          source: hostId,
          target: node.id,
          type: 'exploits',
          label: 'vulnerable to',
          probability: this.calculateExploitProbability(vuln)
        });
      }
    }

    // Create edges between related vulnerabilities
    this.createVulnerabilityChainEdges(vulns, nodes, edges, nodeMap);

    return { nodes, edges };
  }

  /**
   * Create edges for vulnerability chains
   */
  private createVulnerabilityChainEdges(
    vulns: NormalizedVulnerability[],
    nodes: AttackPathNode[],
    edges: AttackPathEdge[],
    nodeMap: Map<string, AttackPathNode>
  ): void {
    // Group vulnerabilities by host
    const hostVulns = new Map<string, NormalizedVulnerability[]>();
    for (const vuln of vulns) {
      if (!hostVulns.has(vuln.host)) {
        hostVulns.set(vuln.host, []);
      }
      hostVulns.get(vuln.host)!.push(vuln);
    }

    // Create chains within each host
    for (const [host, hvulns] of hostVulns) {
      // Sort by severity (lower to higher - attack progression)
      const sorted = [...hvulns].sort((a, b) => a.severity.score - b.severity.score);

      for (let i = 0; i < sorted.length - 1; i++) {
        const current = sorted[i];
        const next = sorted[i + 1];

        // Create edge if they could be chained
        if (this.canChain(current, next)) {
          edges.push({
            id: `chain:${current.id}-${next.id}`,
            source: `vuln:${current.id}`,
            target: `vuln:${next.id}`,
            type: 'enables',
            label: 'enables',
            probability: 0.5
          });
        }
      }
    }

    // Create lateral movement edges between hosts
    const hosts = [...hostVulns.keys()];
    for (let i = 0; i < hosts.length; i++) {
      for (let j = i + 1; j < hosts.length; j++) {
        const host1Vulns = hostVulns.get(hosts[i])!;
        const host2Vulns = hostVulns.get(hosts[j])!;

        // Check for lateral movement potential
        const lateralVuln1 = host1Vulns.find(v => this.isLateralMovementVuln(v));
        const lateralVuln2 = host2Vulns.find(v => this.isLateralMovementVuln(v));

        if (lateralVuln1 && lateralVuln2) {
          edges.push({
            id: `lateral:${hosts[i]}-${hosts[j]}`,
            source: `host:${hosts[i]}`,
            target: `host:${hosts[j]}`,
            type: 'leads_to',
            label: 'lateral movement',
            probability: 0.3
          });
        }
      }
    }
  }

  /**
   * Find entry points (internet-facing services)
   */
  private findEntryPoints(
    nodes: AttackPathNode[],
    services: DiscoveredService[]
  ): string[] {
    const entryPoints: string[] = [];
    const internetPorts = [21, 22, 23, 25, 80, 443, 445, 3389, 8080, 8443];

    for (const node of nodes) {
      if (node.type === 'service') {
        const port = node.data.port;
        if (internetPorts.includes(port)) {
          entryPoints.push(node.id);
        }
      }
    }

    // If no specific entry points, use all services
    if (entryPoints.length === 0) {
      entryPoints.push(...nodes.filter(n => n.type === 'service').map(n => n.id));
    }

    return entryPoints;
  }

  /**
   * Find targets (high-value assets)
   */
  private findTargets(
    nodes: AttackPathNode[],
    hosts: DiscoveredHost[]
  ): string[] {
    const targets: string[] = [];

    // High-risk hosts are targets
    for (const node of nodes) {
      if (node.type === 'host' && node.riskScore >= 50) {
        targets.push(node.id);
      }
    }

    // Critical vulnerabilities are targets
    for (const node of nodes) {
      if (node.type === 'vulnerability' && node.riskScore >= 90) {
        targets.push(node.id);
      }
    }

    // If no specific targets, use all hosts
    if (targets.length === 0) {
      targets.push(...nodes.filter(n => n.type === 'host').map(n => n.id));
    }

    return targets;
  }

  /**
   * Find path between two nodes using BFS
   */
  private findPath(
    startId: string,
    endId: string,
    nodes: AttackPathNode[],
    edges: AttackPathEdge[]
  ): AttackPath | null {
    const nodeMap = new Map(nodes.map(n => [n.id, n]));
    const adjacency = new Map<string, AttackPathEdge[]>();

    // Build adjacency list
    for (const edge of edges) {
      if (!adjacency.has(edge.source)) {
        adjacency.set(edge.source, []);
      }
      adjacency.get(edge.source)!.push(edge);
    }

    // BFS
    const queue: { nodeId: string; path: string[]; edges: AttackPathEdge[] }[] = [
      { nodeId: startId, path: [startId], edges: [] }
    ];
    const visited = new Set<string>();

    while (queue.length > 0) {
      const { nodeId, path, edges: pathEdges } = queue.shift()!;

      if (nodeId === endId) {
        // Found path
        return this.createAttackPath(path, pathEdges, nodeMap);
      }

      if (visited.has(nodeId)) continue;
      visited.add(nodeId);

      if (path.length >= this.config.maxPathLength) continue;

      const neighbors = adjacency.get(nodeId) || [];
      for (const edge of neighbors) {
        if (!visited.has(edge.target) && edge.probability >= this.config.minExploitProbability) {
          queue.push({
            nodeId: edge.target,
            path: [...path, edge.target],
            edges: [...pathEdges, edge]
          });
        }
      }
    }

    return null;
  }

  /**
   * Generate vulnerability chain paths
   */
  private generateChainPaths(
    vulns: NormalizedVulnerability[],
    nodes: AttackPathNode[],
    edges: AttackPathEdge[]
  ): AttackPath[] {
    const paths: AttackPath[] = [];
    const nodeMap = new Map(nodes.map(n => [n.id, n]));

    // Group by host
    const hostVulns = new Map<string, NormalizedVulnerability[]>();
    for (const vuln of vulns) {
      if (!hostVulns.has(vuln.host)) {
        hostVulns.set(vuln.host, []);
      }
      hostVulns.get(vuln.host)!.push(vuln);
    }

    // Generate chain for each host with multiple vulns
    for (const [host, hvulns] of hostVulns) {
      if (hvulns.length < 2) continue;

      // Sort by severity
      const sorted = [...hvulns].sort((a, b) => a.severity.score - b.severity.score);
      
      const pathNodes = sorted.map(v => `vuln:${v.id}`);
      const pathEdges: AttackPathEdge[] = [];

      for (let i = 0; i < sorted.length - 1; i++) {
        pathEdges.push({
          id: `chain-edge-${i}`,
          source: `vuln:${sorted[i].id}`,
          target: `vuln:${sorted[i + 1].id}`,
          type: 'enables',
          label: 'escalates to',
          probability: 0.6
        });
      }

      const path = this.createAttackPath(pathNodes, pathEdges, nodeMap);
      path.name = `Vulnerability Chain on ${host}`;
      path.description = `Chain of ${sorted.length} vulnerabilities that could be exploited in sequence`;
      paths.push(path);
    }

    return paths;
  }

  /**
   * Create AttackPath object from path data
   */
  private createAttackPath(
    pathNodeIds: string[],
    pathEdges: AttackPathEdge[],
    nodeMap: Map<string, AttackPathNode>
  ): AttackPath {
    const pathNodes = pathNodeIds
      .map(id => nodeMap.get(id))
      .filter((n): n is AttackPathNode => n !== undefined);

    // Calculate risk
    const maxRisk = Math.max(...pathNodes.map(n => n.riskScore), 0);
    const avgProbability = pathEdges.length > 0
      ? pathEdges.reduce((sum, e) => sum + e.probability, 0) / pathEdges.length
      : 0;

    return {
      id: `path-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      scanId: '',
      name: `Attack Path (${pathNodes.length} steps)`,
      description: this.generatePathDescription(pathNodes),
      nodes: pathNodes,
      edges: pathEdges,
      entryPoints: pathNodeIds.slice(0, 1),
      targets: pathNodeIds.slice(-1),
      criticalPath: pathNodeIds,
      overallRisk: maxRisk * avgProbability,
      exploitability: avgProbability * 10,
      impact: maxRisk,
      mitigations: this.generateMitigations(pathNodes),
      prioritizedFixes: this.generatePrioritizedFixes(pathNodes)
    };
  }

  /**
   * Generate path description
   */
  private generatePathDescription(nodes: AttackPathNode[]): string {
    const steps = nodes.map((n, i) => `${i + 1}. ${n.label}`);
    return `Attack path with ${nodes.length} steps:\n${steps.join('\n')}`;
  }

  /**
   * Generate mitigations for path
   */
  private generateMitigations(nodes: AttackPathNode[]): string[] {
    const mitigations: string[] = [];

    for (const node of nodes) {
      if (node.type === 'vulnerability') {
        const severity = node.data.severity?.label || 'unknown';
        mitigations.push(`Patch ${node.label} (${severity} severity)`);
      } else if (node.type === 'service') {
        mitigations.push(`Restrict access to ${node.label}`);
      }
    }

    return [...new Set(mitigations)];
  }

  /**
   * Generate prioritized fixes
   */
  private generatePrioritizedFixes(nodes: AttackPathNode[]): string[] {
    const vulnNodes = nodes
      .filter(n => n.type === 'vulnerability')
      .sort((a, b) => b.riskScore - a.riskScore);

    return vulnNodes.slice(0, 5).map(n => `Fix: ${n.label}`);
  }

  /**
   * Calculate exploit probability
   */
  private calculateExploitProbability(vuln: NormalizedVulnerability): number {
    let prob = 0.3; // Base probability

    // Higher severity = higher probability
    prob += vuln.severity.score / 20;

    // Known CVE increases probability
    if (vuln.cve && vuln.cve.length > 0) {
      prob += 0.2;
    }

    // High confidence increases probability
    if (vuln.confidence >= 90) {
      prob += 0.1;
    }

    return Math.min(1.0, prob);
  }

  /**
   * Check if vulnerabilities can be chained
   */
  private canChain(v1: NormalizedVulnerability, v2: NormalizedVulnerability): boolean {
    // Same host
    if (v1.host !== v2.host) return false;

    // Lower severity leads to higher
    if (v1.severity.score >= v2.severity.score) return false;

    // Same service/port
    if (v1.port && v2.port && v1.port === v2.port) return true;

    // Different vulnerability types can chain
    if (v1.scannerCategory !== v2.scannerCategory) return true;

    return false;
  }

  /**
   * Check if vulnerability enables lateral movement
   */
  private isLateralMovementVuln(vuln: NormalizedVulnerability): boolean {
    const lateralKeywords = ['smb', 'rdp', 'ssh', 'wmi', 'psexec', 'lateral', 'remote'];
    const title = vuln.title.toLowerCase();
    const desc = vuln.description.toLowerCase();

    return lateralKeywords.some(kw => title.includes(kw) || desc.includes(kw));
  }
}

/**
 * Quick attack path generation
 */
export function generateAttackPaths(
  vulnerabilities: NormalizedVulnerability[],
  hosts: DiscoveredHost[] = [],
  services: DiscoveredService[] = []
): AttackPath[] {
  const generator = new AttackPathGenerator();
  return generator.generatePaths(vulnerabilities, hosts, services);
}
