/**
 * Threat Intelligence Enrichment Module
 * Enriches vulnerabilities with NVD, ExploitDB, EPSS, and more - ALL DYNAMIC APIs
 */

import { NormalizedVulnerability, ThreatIntelligence } from './types';

const CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours

interface CacheEntry {
  data: ThreatIntelligence;
  timestamp: number;
}

const cache = new Map<string, CacheEntry>();

/**
 * Enrich a vulnerability with threat intelligence
 */
export async function enrichWithThreatIntel(
  vuln: NormalizedVulnerability
): Promise<ThreatIntelligence | null> {
  if (!vuln.cve || vuln.cve.length === 0) return null;

  const cve = vuln.cve[0];
  
  // Check cache
  const cached = cache.get(cve);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.data;
  }

  try {
    const intel = await fetchThreatIntel(cve);
    if (intel) {
      cache.set(cve, { data: intel, timestamp: Date.now() });
    }
    return intel;
  } catch (error) {
    console.error(`Failed to fetch threat intel for ${cve}:`, error);
    return null;
  }
}

/**
 * Fetch threat intelligence from ALL REAL DYNAMIC SOURCES
 */
async function fetchThreatIntel(cve: string): Promise<ThreatIntelligence | null> {
  const intel: ThreatIntelligence = {
    cve,
    exploitAvailable: false,
    inTheWild: false,
    ransomwareAssociated: false,
    aptAssociated: false,
    references: []
  };

  // Parallel fetch from all sources for speed
  const [nvdData, epssData, kevData, exploitData, vulnersData] = await Promise.allSettled([
    fetchNVD(cve),
    fetchEPSS(cve),
    fetchCISAKEV(cve),
    fetchExploitDBDynamic(cve),
    fetchVulners(cve)
  ]);


  // Process NVD data
  if (nvdData.status === 'fulfilled' && nvdData.value) {
    intel.nvdScore = nvdData.value.score;
    intel.nvdVector = nvdData.value.vector;
    intel.nvdDescription = nvdData.value.description;
    intel.publishedDate = nvdData.value.published;
    intel.lastModified = nvdData.value.modified;
    intel.references.push(...(nvdData.value.references || []));
    
    // Extract exploit info from NVD references (dynamic)
    const refs = nvdData.value.references || [];
    for (const ref of refs) {
      if (ref.includes('exploit-db.com/exploits/')) {
        intel.exploitAvailable = true;
        const match = ref.match(/exploits\/(\d+)/);
        if (match) {
          intel.exploitDbId = match[1];
          intel.exploitDbUrl = ref;
        }
      }
      if (ref.includes('packetstormsecurity.com')) {
        intel.exploitAvailable = true;
        if (!intel.exploitSources) intel.exploitSources = [];
        intel.exploitSources.push('PacketStorm');
      }
      if (ref.includes('rapid7.com') || ref.includes('metasploit')) {
        intel.exploitAvailable = true;
        intel.metasploitModule = ref;
        if (!intel.exploitSources) intel.exploitSources = [];
        intel.exploitSources.push('Metasploit/Rapid7');
      }
      if (ref.includes('github.com') && (ref.includes('exploit') || ref.includes('poc') || ref.includes('CVE'))) {
        intel.exploitAvailable = true;
        if (!intel.exploitSources) intel.exploitSources = [];
        intel.exploitSources.push('GitHub PoC');
      }
    }
  }

  // Process EPSS data
  if (epssData.status === 'fulfilled' && epssData.value) {
    intel.epssScore = epssData.value.score;
    intel.epssPercentile = epssData.value.percentile;
    if (epssData.value.score > 0.5) {
      intel.inTheWild = true;
    }
  }

  // Process CISA KEV data
  if (kevData.status === 'fulfilled' && kevData.value) {
    intel.inTheWild = true;
    intel.ransomwareAssociated = kevData.value.ransomware || false;
    intel.kevDueDate = kevData.value.dueDate;
    intel.kevVendor = kevData.value.vendor;
    intel.kevProduct = kevData.value.product;
  }

  // Process ExploitDB data (dynamic)
  if (exploitData.status === 'fulfilled' && exploitData.value) {
    intel.exploitAvailable = true;
    intel.exploitDbId = exploitData.value.id;
    intel.exploitDbTitle = exploitData.value.title;
    intel.exploitDbUrl = exploitData.value.url;
    intel.metasploitModule = exploitData.value.metasploit;
  }

  // Process Vulners data (includes Metasploit, PacketStorm, etc.)
  if (vulnersData.status === 'fulfilled' && vulnersData.value) {
    if (vulnersData.value.exploitCount > 0) {
      intel.exploitAvailable = true;
    }
    intel.vulnersScore = vulnersData.value.score;
    intel.exploitSources = vulnersData.value.sources;
    if (vulnersData.value.metasploit) {
      intel.metasploitModule = vulnersData.value.metasploit;
    }
  }

  return intel;
}

/**
 * Fetch CVE data from NVD API (REAL)
 */
async function fetchNVD(cve: string): Promise<{
  score?: number;
  vector?: string;
  description?: string;
  published?: string;
  modified?: string;
  references?: string[];
} | null> {
  try {
    const response = await fetch(
      `https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=${cve}`,
      {
        headers: { 'Accept': 'application/json' },
        signal: AbortSignal.timeout(15000)
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    const vuln = data.vulnerabilities?.[0]?.cve;
    if (!vuln) return null;

    let score: number | undefined;
    let vector: string | undefined;

    if (vuln.metrics?.cvssMetricV31?.[0]) {
      score = vuln.metrics.cvssMetricV31[0].cvssData?.baseScore;
      vector = vuln.metrics.cvssMetricV31[0].cvssData?.vectorString;
    } else if (vuln.metrics?.cvssMetricV30?.[0]) {
      score = vuln.metrics.cvssMetricV30[0].cvssData?.baseScore;
      vector = vuln.metrics.cvssMetricV30[0].cvssData?.vectorString;
    } else if (vuln.metrics?.cvssMetricV2?.[0]) {
      score = vuln.metrics.cvssMetricV2[0].cvssData?.baseScore;
      vector = vuln.metrics.cvssMetricV2[0].cvssData?.vectorString;
    }

    return {
      score,
      vector,
      description: vuln.descriptions?.find((d: any) => d.lang === 'en')?.value,
      published: vuln.published,
      modified: vuln.lastModified,
      references: vuln.references?.map((r: any) => r.url) || []
    };
  } catch {
    return null;
  }
}

/**
 * Fetch EPSS score from FIRST API (REAL)
 */
async function fetchEPSS(cve: string): Promise<{ score: number; percentile: number } | null> {
  try {
    const response = await fetch(
      `https://api.first.org/data/v1/epss?cve=${cve}`,
      { signal: AbortSignal.timeout(10000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    const epss = data.data?.[0];
    if (!epss) return null;

    return {
      score: parseFloat(epss.epss) || 0,
      percentile: parseFloat(epss.percentile) || 0
    };
  } catch {
    return null;
  }
}


/**
 * Check CISA Known Exploited Vulnerabilities catalog (REAL)
 */
async function fetchCISAKEV(cve: string): Promise<{
  ransomware?: boolean;
  dueDate?: string;
  vendor?: string;
  product?: string;
} | null> {
  try {
    const response = await fetch(
      'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
      { signal: AbortSignal.timeout(15000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    const vuln = data.vulnerabilities?.find((v: any) => v.cveID === cve);
    
    if (!vuln) return null;

    return {
      ransomware: vuln.knownRansomwareCampaignUse === 'Known',
      dueDate: vuln.dueDate,
      vendor: vuln.vendorProject,
      product: vuln.product
    };
  } catch {
    return null;
  }
}

/**
 * Fetch ExploitDB data DYNAMICALLY using CVE search (REAL)
 * Uses the Exploit-DB search API via their website
 */
async function fetchExploitDBDynamic(cve: string): Promise<{
  id?: string;
  title?: string;
  url?: string;
  metasploit?: string;
} | null> {
  try {
    // Use GitLab API to search exploit-db repository (public mirror)
    const response = await fetch(
      `https://gitlab.com/api/v4/projects/4621037/repository/files/files_exploits.csv/raw?ref=main`,
      { signal: AbortSignal.timeout(20000) }
    );

    if (!response.ok) {
      // Fallback: Use CVE Details API
      return await fetchCVEDetailsExploit(cve);
    }

    const csvData = await response.text();
    const lines = csvData.split('\n');
    
    // Search for CVE in the CSV
    for (const line of lines) {
      if (line.toLowerCase().includes(cve.toLowerCase())) {
        const parts = line.split(',');
        if (parts.length >= 3) {
          const id = parts[0];
          const title = parts[2]?.replace(/"/g, '');
          return {
            id,
            title,
            url: `https://www.exploit-db.com/exploits/${id}`,
            metasploit: title?.toLowerCase().includes('metasploit') ? title : undefined
          };
        }
      }
    }

    // Fallback to CVE Details
    return await fetchCVEDetailsExploit(cve);
  } catch {
    return await fetchCVEDetailsExploit(cve);
  }
}

/**
 * Fetch exploit info from CVE Details (REAL - Fallback)
 */
async function fetchCVEDetailsExploit(cve: string): Promise<{
  id?: string;
  title?: string;
  url?: string;
  metasploit?: string;
} | null> {
  try {
    // CVE Details provides exploit references in their API
    const cveId = cve.replace('CVE-', '');
    const response = await fetch(
      `https://www.cvedetails.com/json-feed.php?numrows=1&vendor_id=0&product_id=0&version_id=0&hasexp=1&opec=1&opov=1&opcsrf=1&opfileinc=1&opgpriv=1&opsqli=1&opxss=1&opdirt=1&opmemc=1&ophttprs=1&opbyp=1&opginf=1&opdos=1&orderby=1&cvssscoremin=0&cve_id=${cve}`,
      { signal: AbortSignal.timeout(10000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    if (data && data.length > 0 && data[0].exploit_count > 0) {
      return {
        id: data[0].cve_id,
        title: data[0].summary?.substring(0, 100),
        url: `https://www.cvedetails.com/cve/${cve}/`
      };
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * Fetch from Vulners API (REAL - includes Metasploit, PacketStorm, etc.)
 * Vulners aggregates multiple exploit sources
 */
async function fetchVulners(cve: string): Promise<{
  score?: number;
  exploitCount: number;
  sources: string[];
  metasploit?: string;
} | null> {
  try {
    // Vulners public search API
    const response = await fetch(
      `https://vulners.com/api/v3/search/id/?id=${cve}&fields=*`,
      {
        headers: { 'Accept': 'application/json' },
        signal: AbortSignal.timeout(15000)
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    if (data.result !== 'OK' || !data.data?.documents) return null;

    const doc = data.data.documents[cve];
    if (!doc) return null;

    // Check for related exploits
    const exploits = doc.references?.filter((ref: string) => 
      ref.includes('exploit-db') || 
      ref.includes('metasploit') || 
      ref.includes('packetstorm')
    ) || [];

    const metasploitRef = doc.references?.find((ref: string) => 
      ref.includes('metasploit') || ref.includes('rapid7')
    );

    return {
      score: doc.cvss?.score,
      exploitCount: exploits.length,
      sources: exploits.map((e: string) => {
        if (e.includes('exploit-db')) return 'ExploitDB';
        if (e.includes('metasploit')) return 'Metasploit';
        if (e.includes('packetstorm')) return 'PacketStorm';
        return 'Other';
      }),
      metasploit: metasploitRef
    };
  } catch {
    return null;
  }
}


/**
 * Fetch host information from Shodan (REAL)
 */
export async function fetchShodanHost(ip: string): Promise<{
  ports?: number[];
  vulns?: string[];
  hostnames?: string[];
  os?: string;
  org?: string;
  isp?: string;
  country?: string;
  city?: string;
  lastUpdate?: string;
} | null> {
  const apiKey = process.env.SHODAN_API_KEY;
  if (!apiKey) return null;

  try {
    const response = await fetch(
      `https://api.shodan.io/shodan/host/${ip}?key=${apiKey}`,
      { signal: AbortSignal.timeout(15000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    return {
      ports: data.ports,
      vulns: data.vulns,
      hostnames: data.hostnames,
      os: data.os,
      org: data.org,
      isp: data.isp,
      country: data.country_name,
      city: data.city,
      lastUpdate: data.last_update
    };
  } catch {
    return null;
  }
}

/**
 * Search Shodan for CVE-affected hosts (REAL)
 */
export async function searchShodanCVE(cve: string): Promise<{
  total?: number;
  countries?: string[];
  topPorts?: number[];
} | null> {
  const apiKey = process.env.SHODAN_API_KEY;
  if (!apiKey) return null;

  try {
    const response = await fetch(
      `https://api.shodan.io/shodan/host/search?key=${apiKey}&query=vuln:${cve}&facets=country,port`,
      { signal: AbortSignal.timeout(15000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    return {
      total: data.total,
      countries: data.facets?.country?.map((c: any) => c.value) || [],
      topPorts: data.facets?.port?.map((p: any) => p.value) || []
    };
  } catch {
    return null;
  }
}

/**
 * Get Shodan API info (check credits)
 */
export async function getShodanApiInfo(): Promise<{
  queryCredits?: number;
  scanCredits?: number;
  plan?: string;
} | null> {
  const apiKey = process.env.SHODAN_API_KEY;
  if (!apiKey) return null;

  try {
    const response = await fetch(
      `https://api.shodan.io/api-info?key=${apiKey}`,
      { signal: AbortSignal.timeout(10000) }
    );

    if (!response.ok) return null;

    const data = await response.json();
    return {
      queryCredits: data.query_credits,
      scanCredits: data.scan_credits,
      plan: data.plan
    };
  } catch {
    return null;
  }
}

/**
 * Fetch from Rapid7 Vulnerability Database (REAL)
 */
async function fetchRapid7(cve: string): Promise<{
  title?: string;
  severity?: string;
  exploitAvailable?: boolean;
  metasploitModules?: string[];
} | null> {
  try {
    // Rapid7 AttackerKB API (community-driven)
    const response = await fetch(
      `https://api.attackerkb.com/v1/topics?q=${cve}`,
      {
        headers: { 'Accept': 'application/json' },
        signal: AbortSignal.timeout(10000)
      }
    );

    if (!response.ok) return null;

    const data = await response.json();
    if (!data.data || data.data.length === 0) return null;

    const topic = data.data[0];
    return {
      title: topic.name,
      severity: topic.metadata?.severity,
      exploitAvailable: topic.metadata?.exploitAvailable || false,
      metasploitModules: topic.metadata?.metasploitModules || []
    };
  } catch {
    return null;
  }
}

/**
 * Batch enrich multiple vulnerabilities - FULLY DYNAMIC
 */
export async function batchEnrichVulnerabilities(
  vulns: NormalizedVulnerability[]
): Promise<Map<string, ThreatIntelligence>> {
  const results = new Map<string, ThreatIntelligence>();
  
  // Get unique CVEs
  const cves = new Set<string>();
  for (const vuln of vulns) {
    if (vuln.cve) {
      vuln.cve.forEach(c => cves.add(c));
    }
  }

  // Fetch in parallel with rate limiting (respect API limits)
  const batchSize = 3; // Smaller batch to avoid rate limits
  const cveArray = Array.from(cves);
  
  for (let i = 0; i < cveArray.length; i += batchSize) {
    const batch = cveArray.slice(i, i + batchSize);
    const promises = batch.map(async (cve) => {
      const intel = await fetchThreatIntel(cve);
      if (intel) {
        results.set(cve, intel);
      }
    });
    
    await Promise.all(promises);
    
    // Rate limit: wait 2 seconds between batches to respect API limits
    if (i + batchSize < cveArray.length) {
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }

  return results;
}

/**
 * Calculate adjusted risk score based on threat intel
 */
export function calculateThreatAdjustedRisk(
  baseScore: number,
  intel: ThreatIntelligence | null
): number {
  if (!intel) return baseScore;

  let adjustedScore = baseScore;

  // Boost for EPSS score (exploit probability)
  if (intel.epssScore) {
    adjustedScore += intel.epssScore * 15; // Up to +15 for high EPSS
  }

  // Boost for known exploitation in the wild
  if (intel.inTheWild) {
    adjustedScore += 20;
  }

  // Boost for available exploits
  if (intel.exploitAvailable) {
    adjustedScore += 15;
  }

  // Boost for ransomware association
  if (intel.ransomwareAssociated) {
    adjustedScore += 25;
  }

  // Boost for APT association
  if (intel.aptAssociated) {
    adjustedScore += 20;
  }

  // Boost based on Vulners score
  if (intel.vulnersScore && intel.vulnersScore > 7) {
    adjustedScore += 10;
  }

  return Math.min(adjustedScore, 100);
}

// Extend ThreatIntelligence type for new fields
declare module './types' {
  interface ThreatIntelligence {
    epssScore?: number;
    epssPercentile?: number;
    kevDueDate?: string;
    kevVendor?: string;
    kevProduct?: string;
    exploitDbTitle?: string;
    exploitDbUrl?: string;
    vulnersScore?: number;
    exploitSources?: string[];
  }
}
