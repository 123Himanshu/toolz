/**
 * Phase 2 Storage Layer
 * Persistent storage for normalized vulnerabilities, hosts, and services
 */

import fs from 'fs';
import path from 'path';
import {
  NormalizedVulnerability,
  DiscoveredHost,
  DiscoveredService,
  ScanSession,
  AttackPath,
  VulnerabilityQuery,
  QueryResult
} from './types';

const STORAGE_DIR = path.join(process.cwd(), '.scan-data', 'phase2');

// Ensure storage directories exist
const ensureDir = (dir: string) => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
};

ensureDir(STORAGE_DIR);
ensureDir(path.join(STORAGE_DIR, 'vulnerabilities'));
ensureDir(path.join(STORAGE_DIR, 'hosts'));
ensureDir(path.join(STORAGE_DIR, 'services'));
ensureDir(path.join(STORAGE_DIR, 'sessions'));
ensureDir(path.join(STORAGE_DIR, 'attack-paths'));
ensureDir(path.join(STORAGE_DIR, 'raw'));

/**
 * Phase 2 Storage Manager
 */
export class Phase2Storage {
  private vulnerabilities: Map<string, NormalizedVulnerability>;
  private hosts: Map<string, DiscoveredHost>;
  private services: Map<string, DiscoveredService>;
  private sessions: Map<string, ScanSession>;
  private attackPaths: Map<string, AttackPath>;

  constructor() {
    this.vulnerabilities = new Map();
    this.hosts = new Map();
    this.services = new Map();
    this.sessions = new Map();
    this.attackPaths = new Map();
    this.loadAll();
  }

  // ============================================================================
  // VULNERABILITY OPERATIONS
  // ============================================================================

  /**
   * Store normalized vulnerability
   */
  storeVulnerability(vuln: NormalizedVulnerability): void {
    this.vulnerabilities.set(vuln.id, vuln);
    this.saveVulnerabilities();
  }

  /**
   * Store multiple vulnerabilities
   */
  storeVulnerabilities(vulns: NormalizedVulnerability[]): void {
    for (const vuln of vulns) {
      this.vulnerabilities.set(vuln.id, vuln);
    }
    this.saveVulnerabilities();
  }

  /**
   * Get vulnerability by ID
   */
  getVulnerability(id: string): NormalizedVulnerability | undefined {
    return this.vulnerabilities.get(id);
  }

  /**
   * Query vulnerabilities with filters
   */
  queryVulnerabilities(query: VulnerabilityQuery): QueryResult<NormalizedVulnerability> {
    let results = Array.from(this.vulnerabilities.values());

    // Apply filters
    if (query.scanId) {
      results = results.filter(v => v.scanId === query.scanId);
    }

    if (query.scanner) {
      const scanners = Array.isArray(query.scanner) ? query.scanner : [query.scanner];
      results = results.filter(v => scanners.includes(v.scanner));
    }

    if (query.host) {
      results = results.filter(v => v.host === query.host || v.host.includes(query.host!));
    }

    if (query.port) {
      results = results.filter(v => v.port === query.port);
    }

    if (query.severity) {
      const severities = Array.isArray(query.severity) ? query.severity : [query.severity];
      results = results.filter(v => severities.includes(v.severity.label));
    }

    if (query.cve) {
      results = results.filter(v => v.cve?.includes(query.cve!));
    }

    if (query.search) {
      const searchLower = query.search.toLowerCase();
      results = results.filter(v =>
        v.title.toLowerCase().includes(searchLower) ||
        v.description.toLowerCase().includes(searchLower) ||
        v.cve?.some(c => c.toLowerCase().includes(searchLower))
      );
    }

    if (query.uniqueOnly) {
      results = results.filter(v => !v.duplicateOf);
    }

    if (!query.includeFalsePositives) {
      results = results.filter(v => !v.falsePositive);
    }

    // Sort
    const sortBy = query.sortBy || 'severity';
    const sortOrder = query.sortOrder || 'desc';
    
    results.sort((a, b) => {
      let comparison = 0;
      switch (sortBy) {
        case 'severity':
          comparison = a.severity.score - b.severity.score;
          break;
        case 'host':
          comparison = a.host.localeCompare(b.host);
          break;
        case 'scanner':
          comparison = a.scanner.localeCompare(b.scanner);
          break;
        case 'discoveredAt':
          comparison = new Date(a.discoveredAt).getTime() - new Date(b.discoveredAt).getTime();
          break;
      }
      return sortOrder === 'desc' ? -comparison : comparison;
    });

    // Paginate
    const page = query.page || 1;
    const limit = query.limit || 50;
    const start = (page - 1) * limit;
    const paginatedResults = results.slice(start, start + limit);

    return {
      data: paginatedResults,
      total: results.length,
      page,
      limit,
      hasMore: start + limit < results.length
    };
  }

  /**
   * Get vulnerabilities by scan ID
   */
  getVulnerabilitiesByScan(scanId: string): NormalizedVulnerability[] {
    return Array.from(this.vulnerabilities.values())
      .filter(v => v.scanId === scanId);
  }

  /**
   * Get vulnerabilities by host
   */
  getVulnerabilitiesByHost(host: string): NormalizedVulnerability[] {
    return Array.from(this.vulnerabilities.values())
      .filter(v => v.host === host);
  }

  /**
   * Get severity breakdown
   */
  getSeverityBreakdown(scanId?: string): Record<string, number> {
    let vulns = Array.from(this.vulnerabilities.values());
    
    if (scanId) {
      vulns = vulns.filter(v => v.scanId === scanId);
    }

    const breakdown: Record<string, number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };

    for (const vuln of vulns) {
      breakdown[vuln.severity.label]++;
    }

    return breakdown;
  }

  // ============================================================================
  // HOST OPERATIONS
  // ============================================================================

  /**
   * Store discovered host
   */
  storeHost(host: DiscoveredHost): void {
    const existing = this.hosts.get(host.ip);
    
    if (existing) {
      // Merge with existing
      host = this.mergeHosts(existing, host);
    }
    
    this.hosts.set(host.ip, host);
    this.saveHosts();
  }

  /**
   * Store multiple hosts
   */
  storeHosts(hosts: DiscoveredHost[]): void {
    for (const host of hosts) {
      this.storeHost(host);
    }
  }

  /**
   * Get host by IP
   */
  getHost(ip: string): DiscoveredHost | undefined {
    return this.hosts.get(ip);
  }

  /**
   * Get all hosts
   */
  getAllHosts(): DiscoveredHost[] {
    return Array.from(this.hosts.values());
  }

  /**
   * Merge two host records
   */
  private mergeHosts(existing: DiscoveredHost, newHost: DiscoveredHost): DiscoveredHost {
    return {
      ...existing,
      hostname: newHost.hostname || existing.hostname,
      lastSeen: newHost.lastSeen,
      discoveredBy: [...new Set([...existing.discoveredBy, ...newHost.discoveredBy])],
      openPorts: [...new Set([...existing.openPorts, ...newHost.openPorts])],
      services: [...new Set([...existing.services, ...newHost.services])],
      vulnerabilityCount: {
        critical: existing.vulnerabilityCount.critical + newHost.vulnerabilityCount.critical,
        high: existing.vulnerabilityCount.high + newHost.vulnerabilityCount.high,
        medium: existing.vulnerabilityCount.medium + newHost.vulnerabilityCount.medium,
        low: existing.vulnerabilityCount.low + newHost.vulnerabilityCount.low,
        info: existing.vulnerabilityCount.info + newHost.vulnerabilityCount.info
      },
      riskScore: Math.max(existing.riskScore, newHost.riskScore)
    };
  }

  // ============================================================================
  // SERVICE OPERATIONS
  // ============================================================================

  /**
   * Store discovered service
   */
  storeService(service: DiscoveredService): void {
    const key = `${service.host}:${service.port}`;
    const existing = this.services.get(key);
    
    if (existing) {
      service = this.mergeServices(existing, service);
    }
    
    this.services.set(key, service);
    this.saveServices();
  }

  /**
   * Store multiple services
   */
  storeServices(services: DiscoveredService[]): void {
    for (const service of services) {
      this.storeService(service);
    }
  }

  /**
   * Get service by host and port
   */
  getService(host: string, port: number): DiscoveredService | undefined {
    return this.services.get(`${host}:${port}`);
  }

  /**
   * Get services by host
   */
  getServicesByHost(host: string): DiscoveredService[] {
    return Array.from(this.services.values())
      .filter(s => s.host === host);
  }

  /**
   * Get all services
   */
  getAllServices(): DiscoveredService[] {
    return Array.from(this.services.values());
  }

  /**
   * Merge two service records
   */
  private mergeServices(existing: DiscoveredService, newService: DiscoveredService): DiscoveredService {
    return {
      ...existing,
      version: newService.version || existing.version,
      product: newService.product || existing.product,
      lastSeen: newService.lastSeen,
      discoveredBy: [...new Set([...existing.discoveredBy, ...newService.discoveredBy])],
      vulnerabilityCount: existing.vulnerabilityCount + newService.vulnerabilityCount,
      riskScore: Math.max(existing.riskScore, newService.riskScore)
    };
  }

  // ============================================================================
  // SESSION OPERATIONS
  // ============================================================================

  /**
   * Store scan session
   */
  storeSession(session: ScanSession): void {
    this.sessions.set(session.id, session);
    this.saveSessions();
  }

  /**
   * Get session by ID
   */
  getSession(id: string): ScanSession | undefined {
    return this.sessions.get(id);
  }

  /**
   * Get all sessions
   */
  getAllSessions(): ScanSession[] {
    return Array.from(this.sessions.values());
  }

  // ============================================================================
  // ATTACK PATH OPERATIONS
  // ============================================================================

  /**
   * Store attack path
   */
  storeAttackPath(path: AttackPath): void {
    this.attackPaths.set(path.id, path);
    this.saveAttackPaths();
  }

  /**
   * Store multiple attack paths
   */
  storeAttackPaths(paths: AttackPath[]): void {
    for (const path of paths) {
      this.attackPaths.set(path.id, path);
    }
    this.saveAttackPaths();
  }

  /**
   * Get attack paths by scan ID
   */
  getAttackPathsByScan(scanId: string): AttackPath[] {
    return Array.from(this.attackPaths.values())
      .filter(p => p.scanId === scanId);
  }

  /**
   * Get all attack paths
   */
  getAllAttackPaths(): AttackPath[] {
    return Array.from(this.attackPaths.values());
  }

  // ============================================================================
  // RAW DATA OPERATIONS
  // ============================================================================

  /**
   * Store raw scanner output
   */
  storeRawOutput(scanId: string, tool: string, output: any): void {
    const filePath = path.join(STORAGE_DIR, 'raw', `${scanId}_${tool}.json`);
    fs.writeFileSync(filePath, JSON.stringify(output, null, 2));
  }

  /**
   * Get raw scanner output
   */
  getRawOutput(scanId: string, tool: string): any | null {
    const filePath = path.join(STORAGE_DIR, 'raw', `${scanId}_${tool}.json`);
    if (fs.existsSync(filePath)) {
      return JSON.parse(fs.readFileSync(filePath, 'utf-8'));
    }
    return null;
  }

  // ============================================================================
  // STATISTICS
  // ============================================================================

  /**
   * Get overall statistics
   */
  getStatistics(): {
    totalVulnerabilities: number;
    totalHosts: number;
    totalServices: number;
    totalSessions: number;
    severityBreakdown: Record<string, number>;
    scannerBreakdown: Record<string, number>;
  } {
    const vulns = Array.from(this.vulnerabilities.values());
    
    const severityBreakdown: Record<string, number> = {
      critical: 0, high: 0, medium: 0, low: 0, info: 0
    };
    const scannerBreakdown: Record<string, number> = {};

    for (const vuln of vulns) {
      severityBreakdown[vuln.severity.label]++;
      scannerBreakdown[vuln.scanner] = (scannerBreakdown[vuln.scanner] || 0) + 1;
    }

    return {
      totalVulnerabilities: vulns.length,
      totalHosts: this.hosts.size,
      totalServices: this.services.size,
      totalSessions: this.sessions.size,
      severityBreakdown,
      scannerBreakdown
    };
  }

  // ============================================================================
  // PERSISTENCE
  // ============================================================================

  private loadAll(): void {
    this.loadVulnerabilities();
    this.loadHosts();
    this.loadServices();
    this.loadSessions();
    this.loadAttackPaths();
  }

  private loadVulnerabilities(): void {
    const filePath = path.join(STORAGE_DIR, 'vulnerabilities', 'all.json');
    if (fs.existsSync(filePath)) {
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        this.vulnerabilities = new Map(data.map((v: NormalizedVulnerability) => [v.id, v]));
      } catch (e) {
        console.error('Error loading vulnerabilities:', e);
      }
    }
  }

  private saveVulnerabilities(): void {
    const filePath = path.join(STORAGE_DIR, 'vulnerabilities', 'all.json');
    fs.writeFileSync(filePath, JSON.stringify(Array.from(this.vulnerabilities.values()), null, 2));
  }

  private loadHosts(): void {
    const filePath = path.join(STORAGE_DIR, 'hosts', 'all.json');
    if (fs.existsSync(filePath)) {
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        this.hosts = new Map(data.map((h: DiscoveredHost) => [h.ip, h]));
      } catch (e) {
        console.error('Error loading hosts:', e);
      }
    }
  }

  private saveHosts(): void {
    const filePath = path.join(STORAGE_DIR, 'hosts', 'all.json');
    fs.writeFileSync(filePath, JSON.stringify(Array.from(this.hosts.values()), null, 2));
  }

  private loadServices(): void {
    const filePath = path.join(STORAGE_DIR, 'services', 'all.json');
    if (fs.existsSync(filePath)) {
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        this.services = new Map(data.map((s: DiscoveredService) => [`${s.host}:${s.port}`, s]));
      } catch (e) {
        console.error('Error loading services:', e);
      }
    }
  }

  private saveServices(): void {
    const filePath = path.join(STORAGE_DIR, 'services', 'all.json');
    fs.writeFileSync(filePath, JSON.stringify(Array.from(this.services.values()), null, 2));
  }

  private loadSessions(): void {
    const filePath = path.join(STORAGE_DIR, 'sessions', 'all.json');
    if (fs.existsSync(filePath)) {
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        this.sessions = new Map(data.map((s: ScanSession) => [s.id, s]));
      } catch (e) {
        console.error('Error loading sessions:', e);
      }
    }
  }

  private saveSessions(): void {
    const filePath = path.join(STORAGE_DIR, 'sessions', 'all.json');
    fs.writeFileSync(filePath, JSON.stringify(Array.from(this.sessions.values()), null, 2));
  }

  private loadAttackPaths(): void {
    const filePath = path.join(STORAGE_DIR, 'attack-paths', 'all.json');
    if (fs.existsSync(filePath)) {
      try {
        const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
        this.attackPaths = new Map(data.map((p: AttackPath) => [p.id, p]));
      } catch (e) {
        console.error('Error loading attack paths:', e);
      }
    }
  }

  private saveAttackPaths(): void {
    const filePath = path.join(STORAGE_DIR, 'attack-paths', 'all.json');
    fs.writeFileSync(filePath, JSON.stringify(Array.from(this.attackPaths.values()), null, 2));
  }

  /**
   * Clear all data
   */
  clearAll(): void {
    this.vulnerabilities.clear();
    this.hosts.clear();
    this.services.clear();
    this.sessions.clear();
    this.attackPaths.clear();
    
    this.saveVulnerabilities();
    this.saveHosts();
    this.saveServices();
    this.saveSessions();
    this.saveAttackPaths();
  }
}

// Singleton instance
let storage: Phase2Storage | null = null;

export function getPhase2Storage(): Phase2Storage {
  if (!storage) {
    storage = new Phase2Storage();
  }
  return storage;
}
