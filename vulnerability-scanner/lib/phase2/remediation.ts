/**
 * Remediation Tracking Module
 * Track vulnerability remediation status and generate fix recommendations
 */

import { NormalizedVulnerability } from './types';
import { getPhase2Storage } from './storage';

export type RemediationStatus = 'open' | 'in_progress' | 'fixed' | 'accepted' | 'false_positive';

export interface RemediationRecord {
  vulnerabilityId: string;
  status: RemediationStatus;
  assignee?: string;
  notes?: string;
  fixedAt?: string;
  fixedBy?: string;
  verifiedAt?: string;
  verifiedBy?: string;
  acceptedReason?: string;
  createdAt: string;
  updatedAt: string;
}

export interface RemediationStats {
  total: number;
  open: number;
  inProgress: number;
  fixed: number;
  accepted: number;
  falsePositive: number;
  meanTimeToRemediate?: number; // in days
}

// In-memory storage for remediation records
const remediationRecords = new Map<string, RemediationRecord>();

/**
 * Update remediation status for a vulnerability
 */
export function updateRemediationStatus(
  vulnerabilityId: string,
  status: RemediationStatus,
  options?: {
    assignee?: string;
    notes?: string;
    fixedBy?: string;
    acceptedReason?: string;
  }
): RemediationRecord {
  const existing = remediationRecords.get(vulnerabilityId);
  const now = new Date().toISOString();

  const record: RemediationRecord = {
    vulnerabilityId,
    status,
    assignee: options?.assignee || existing?.assignee,
    notes: options?.notes || existing?.notes,
    createdAt: existing?.createdAt || now,
    updatedAt: now
  };


  if (status === 'fixed') {
    record.fixedAt = now;
    record.fixedBy = options?.fixedBy;
  }

  if (status === 'accepted') {
    record.acceptedReason = options?.acceptedReason;
  }

  remediationRecords.set(vulnerabilityId, record);
  return record;
}

/**
 * Get remediation status for a vulnerability
 */
export function getRemediationStatus(vulnerabilityId: string): RemediationRecord | null {
  return remediationRecords.get(vulnerabilityId) || null;
}

/**
 * Get remediation statistics
 */
export function getRemediationStats(): RemediationStats {
  const records = Array.from(remediationRecords.values());
  
  const stats: RemediationStats = {
    total: records.length,
    open: records.filter(r => r.status === 'open').length,
    inProgress: records.filter(r => r.status === 'in_progress').length,
    fixed: records.filter(r => r.status === 'fixed').length,
    accepted: records.filter(r => r.status === 'accepted').length,
    falsePositive: records.filter(r => r.status === 'false_positive').length
  };

  // Calculate mean time to remediate
  const fixedRecords = records.filter(r => r.status === 'fixed' && r.fixedAt);
  if (fixedRecords.length > 0) {
    const totalDays = fixedRecords.reduce((sum, r) => {
      const created = new Date(r.createdAt).getTime();
      const fixed = new Date(r.fixedAt!).getTime();
      return sum + (fixed - created) / (1000 * 60 * 60 * 24);
    }, 0);
    stats.meanTimeToRemediate = totalDays / fixedRecords.length;
  }

  return stats;
}

/**
 * Generate prioritized remediation plan
 */
export function generateRemediationPlan(
  vulnerabilities: NormalizedVulnerability[]
): RemediationPlan {
  // Sort by severity and exploitability
  const sorted = [...vulnerabilities].sort((a, b) => {
    // Critical first
    const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
    const aSev = severityOrder[a.severity.label] ?? 5;
    const bSev = severityOrder[b.severity.label] ?? 5;
    if (aSev !== bSev) return aSev - bSev;
    
    // Then by score
    return b.severity.score - a.severity.score;
  });

  // Group by remediation type
  const groups = groupByRemediation(sorted);

  return {
    generatedAt: new Date().toISOString(),
    totalVulnerabilities: vulnerabilities.length,
    prioritizedActions: generatePrioritizedActions(sorted),
    groupedByRemediation: groups,
    estimatedEffort: estimateEffort(sorted),
    quickWins: findQuickWins(sorted)
  };
}


export interface RemediationPlan {
  generatedAt: string;
  totalVulnerabilities: number;
  prioritizedActions: PrioritizedAction[];
  groupedByRemediation: RemediationGroup[];
  estimatedEffort: EffortEstimate;
  quickWins: NormalizedVulnerability[];
}

export interface PrioritizedAction {
  priority: number;
  vulnerability: NormalizedVulnerability;
  action: string;
  impact: string;
  effort: 'low' | 'medium' | 'high';
}

export interface RemediationGroup {
  type: string;
  count: number;
  vulnerabilities: NormalizedVulnerability[];
  commonRemediation: string;
}

export interface EffortEstimate {
  totalHours: number;
  byCategory: Record<string, number>;
  bySeverity: Record<string, number>;
}

function generatePrioritizedActions(vulns: NormalizedVulnerability[]): PrioritizedAction[] {
  return vulns.slice(0, 20).map((v, i) => ({
    priority: i + 1,
    vulnerability: v,
    action: v.remediation || getDefaultRemediation(v),
    impact: getImpactDescription(v),
    effort: estimateVulnEffort(v)
  }));
}

function getDefaultRemediation(v: NormalizedVulnerability): string {
  const title = v.title.toLowerCase();
  
  if (title.includes('sql injection')) return 'Use parameterized queries';
  if (title.includes('xss')) return 'Implement output encoding and CSP';
  if (title.includes('outdated') || title.includes('version')) return 'Update to latest version';
  if (title.includes('ssl') || title.includes('tls')) return 'Update SSL/TLS configuration';
  if (title.includes('header')) return 'Configure security headers';
  if (title.includes('exposed')) return 'Restrict access with firewall rules';
  
  return 'Review and remediate based on security best practices';
}

function getImpactDescription(v: NormalizedVulnerability): string {
  switch (v.severity.label) {
    case 'critical': return 'Eliminates critical risk of system compromise';
    case 'high': return 'Significantly reduces attack surface';
    case 'medium': return 'Improves security posture';
    case 'low': return 'Minor security improvement';
    default: return 'Informational improvement';
  }
}

function estimateVulnEffort(v: NormalizedVulnerability): 'low' | 'medium' | 'high' {
  const title = v.title.toLowerCase();
  
  // Quick fixes
  if (title.includes('header') || title.includes('cookie') || title.includes('configuration')) {
    return 'low';
  }
  
  // Code changes required
  if (title.includes('injection') || title.includes('xss') || title.includes('authentication')) {
    return 'high';
  }
  
  return 'medium';
}

function groupByRemediation(vulns: NormalizedVulnerability[]): RemediationGroup[] {
  const groups = new Map<string, NormalizedVulnerability[]>();
  
  for (const v of vulns) {
    const type = categorizeRemediation(v);
    if (!groups.has(type)) groups.set(type, []);
    groups.get(type)!.push(v);
  }

  return Array.from(groups.entries()).map(([type, vulns]) => ({
    type,
    count: vulns.length,
    vulnerabilities: vulns,
    commonRemediation: getCommonRemediation(type)
  }));
}

function categorizeRemediation(v: NormalizedVulnerability): string {
  const title = v.title.toLowerCase();
  
  if (title.includes('update') || title.includes('outdated') || title.includes('version')) return 'Software Updates';
  if (title.includes('configuration') || title.includes('header') || title.includes('ssl')) return 'Configuration Changes';
  if (title.includes('injection') || title.includes('xss')) return 'Code Fixes';
  if (title.includes('exposed') || title.includes('open port')) return 'Network Hardening';
  if (title.includes('authentication') || title.includes('credential')) return 'Access Control';
  
  return 'Other';
}

function getCommonRemediation(type: string): string {
  const remediations: Record<string, string> = {
    'Software Updates': 'Update affected software to the latest stable versions',
    'Configuration Changes': 'Review and harden configuration settings',
    'Code Fixes': 'Implement secure coding practices and input validation',
    'Network Hardening': 'Apply firewall rules and network segmentation',
    'Access Control': 'Implement strong authentication and authorization'
  };
  return remediations[type] || 'Review and address based on security best practices';
}

function estimateEffort(vulns: NormalizedVulnerability[]): EffortEstimate {
  const effortHours: Record<string, number> = { low: 1, medium: 4, high: 16 };
  const byCategory: Record<string, number> = {};
  const bySeverity: Record<string, number> = {};
  let totalHours = 0;

  for (const v of vulns) {
    const effort = estimateVulnEffort(v);
    const hours = effortHours[effort];
    totalHours += hours;

    const category = categorizeRemediation(v);
    byCategory[category] = (byCategory[category] || 0) + hours;
    bySeverity[v.severity.label] = (bySeverity[v.severity.label] || 0) + hours;
  }

  return { totalHours, byCategory, bySeverity };
}

function findQuickWins(vulns: NormalizedVulnerability[]): NormalizedVulnerability[] {
  return vulns.filter(v => {
    const effort = estimateVulnEffort(v);
    return effort === 'low' && (v.severity.label === 'critical' || v.severity.label === 'high');
  }).slice(0, 10);
}
