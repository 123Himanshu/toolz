/**
 * AI-Powered Vulnerability Analysis
 * Uses AI models when CVE/threat intel data is not available
 * Provides intelligent analysis for unknown vulnerabilities
 */

import { NormalizedVulnerability, ThreatIntelligence } from './types';

interface AIAnalysisResult {
  riskAssessment: {
    score: number;
    label: 'critical' | 'high' | 'medium' | 'low' | 'info';
    confidence: number;
  };
  exploitability: {
    score: number;
    factors: string[];
  };
  impact: {
    confidentiality: 'high' | 'medium' | 'low' | 'none';
    integrity: 'high' | 'medium' | 'low' | 'none';
    availability: 'high' | 'medium' | 'low' | 'none';
  };
  attackVector: string;
  recommendations: string[];
  relatedCVEs: string[];
  mitreTechniques: string[];
}

/**
 * Analyze vulnerability using AI when no CVE data is available
 */
export async function analyzeWithAI(
  vuln: NormalizedVulnerability
): Promise<AIAnalysisResult | null> {
  try {
    const { getAICompletion } = await import('@/lib/multi-ai-provider');

    const systemPrompt = `You are a cybersecurity expert analyzing vulnerabilities. 
Analyze the given vulnerability and provide a structured assessment.
Return ONLY valid JSON with no markdown formatting.`;

    const userPrompt = `Analyze this vulnerability:
Title: ${vuln.title}
Description: ${vuln.description}
Service: ${vuln.service || 'unknown'}
Port: ${vuln.port || 'unknown'}
Scanner: ${vuln.scanner}
Evidence: ${vuln.evidence || 'none'}

Provide analysis in this exact JSON format:
{
  "riskAssessment": {
    "score": <0-100>,
    "label": "<critical|high|medium|low|info>",
    "confidence": <0-100>
  },
  "exploitability": {
    "score": <0-10>,
    "factors": ["<factor1>", "<factor2>"]
  },
  "impact": {
    "confidentiality": "<high|medium|low|none>",
    "integrity": "<high|medium|low|none>",
    "availability": "<high|medium|low|none>"
  },
  "attackVector": "<network|adjacent|local|physical>",
  "recommendations": ["<rec1>", "<rec2>"],
  "relatedCVEs": ["<CVE-XXXX-XXXXX>"],
  "mitreTechniques": ["<T1XXX>"]
}`;

    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.3,
      maxTokens: 1000,
    });

    // Parse JSON from response
    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    return JSON.parse(jsonMatch[0]) as AIAnalysisResult;
  } catch (error) {
    console.error('AI analysis failed:', error);
    return null;
  }
}

/**
 * Generate threat intel using AI when APIs fail
 */
export async function generateAIThreatIntel(
  vuln: NormalizedVulnerability
): Promise<Partial<ThreatIntelligence> | null> {
  try {
    const { getAICompletion } = await import('@/lib/multi-ai-provider');

    const systemPrompt = `You are a threat intelligence analyst. Based on the vulnerability details, 
estimate threat intelligence metrics. Be conservative in your estimates.
Return ONLY valid JSON.`;

    const userPrompt = `Estimate threat intelligence for:
Title: ${vuln.title}
Description: ${vuln.description}
CVE: ${vuln.cve?.join(', ') || 'unknown'}
Service: ${vuln.service || 'unknown'}
Severity: ${vuln.severity.label} (${vuln.severity.score})

Provide estimates in JSON:
{
  "exploitAvailable": <true|false>,
  "exploitProbability": <0-1>,
  "inTheWild": <true|false>,
  "ransomwareRisk": <true|false>,
  "aptRisk": <true|false>,
  "estimatedCVSS": <0-10>,
  "attackComplexity": "<low|high>",
  "privilegesRequired": "<none|low|high>",
  "userInteraction": "<none|required>",
  "reasoning": "<brief explanation>"
}`;

    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.2,
      maxTokens: 500,
    });

    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    const aiIntel = JSON.parse(jsonMatch[0]);

    return {
      exploitAvailable: aiIntel.exploitAvailable,
      inTheWild: aiIntel.inTheWild,
      ransomwareAssociated: aiIntel.ransomwareRisk,
      aptAssociated: aiIntel.aptRisk,
      nvdScore: aiIntel.estimatedCVSS,
      nvdDescription: aiIntel.reasoning,
    };
  } catch (error) {
    console.error('AI threat intel generation failed:', error);
    return null;
  }
}

/**
 * Predict attack paths using AI
 */
export async function predictAttackPaths(
  vulns: NormalizedVulnerability[]
): Promise<{
  paths: Array<{
    name: string;
    steps: string[];
    risk: number;
    likelihood: number;
  }>;
  recommendations: string[];
} | null> {
  if (vulns.length === 0) return null;

  try {
    const { getAICompletion } = await import('@/lib/multi-ai-provider');

    const vulnSummary = vulns.slice(0, 10).map(v => ({
      title: v.title,
      host: v.host,
      port: v.port,
      severity: v.severity.label,
      service: v.service,
    }));

    const systemPrompt = `You are a penetration testing expert. Analyze vulnerabilities and predict realistic attack paths.
Return ONLY valid JSON.`;

    const userPrompt = `Given these vulnerabilities:
${JSON.stringify(vulnSummary, null, 2)}

Predict attack paths in JSON:
{
  "paths": [
    {
      "name": "<path name>",
      "steps": ["<step1>", "<step2>", "<step3>"],
      "risk": <0-100>,
      "likelihood": <0-100>
    }
  ],
  "recommendations": ["<rec1>", "<rec2>"]
}`;

    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.4,
      maxTokens: 1500,
    });

    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    return JSON.parse(jsonMatch[0]);
  } catch (error) {
    console.error('AI attack path prediction failed:', error);
    return null;
  }
}

/**
 * Generate remediation plan using AI
 */
export async function generateRemediationPlan(
  vulns: NormalizedVulnerability[]
): Promise<{
  prioritizedActions: Array<{
    priority: number;
    action: string;
    affectedVulns: string[];
    effort: 'low' | 'medium' | 'high';
    impact: 'low' | 'medium' | 'high';
  }>;
  quickWins: string[];
  longTermFixes: string[];
} | null> {
  if (vulns.length === 0) return null;

  try {
    const { getAICompletion } = await import('@/lib/multi-ai-provider');

    const vulnSummary = vulns.slice(0, 15).map(v => ({
      id: v.id,
      title: v.title,
      severity: v.severity.label,
      service: v.service,
      host: v.host,
    }));

    const systemPrompt = `You are a security remediation expert. Create a prioritized remediation plan.
Return ONLY valid JSON.`;

    const userPrompt = `Create remediation plan for:
${JSON.stringify(vulnSummary, null, 2)}

Return JSON:
{
  "prioritizedActions": [
    {
      "priority": <1-N>,
      "action": "<specific action>",
      "affectedVulns": ["<vuln_id>"],
      "effort": "<low|medium|high>",
      "impact": "<low|medium|high>"
    }
  ],
  "quickWins": ["<quick fix 1>", "<quick fix 2>"],
  "longTermFixes": ["<long term fix 1>"]
}`;

    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.3,
      maxTokens: 1500,
    });

    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    return JSON.parse(jsonMatch[0]);
  } catch (error) {
    console.error('AI remediation plan failed:', error);
    return null;
  }
}

/**
 * Classify unknown vulnerability using AI
 */
export async function classifyUnknownVuln(
  vuln: NormalizedVulnerability
): Promise<{
  category: string;
  subcategory: string;
  cweId: string;
  owaspCategory: string;
  confidence: number;
} | null> {
  try {
    const { getAICompletion } = await import('@/lib/multi-ai-provider');

    const systemPrompt = `You are a vulnerability classification expert. Classify the vulnerability.
Return ONLY valid JSON.`;

    const userPrompt = `Classify this vulnerability:
Title: ${vuln.title}
Description: ${vuln.description}
Service: ${vuln.service || 'unknown'}
Evidence: ${vuln.evidence || 'none'}

Return JSON:
{
  "category": "<injection|auth|xss|config|crypto|etc>",
  "subcategory": "<specific type>",
  "cweId": "<CWE-XXX>",
  "owaspCategory": "<A01-A10>",
  "confidence": <0-100>
}`;

    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.2,
      maxTokens: 300,
    });

    const jsonMatch = response.content.match(/\{[\s\S]*\}/);
    if (!jsonMatch) return null;

    return JSON.parse(jsonMatch[0]);
  } catch (error) {
    console.error('AI classification failed:', error);
    return null;
  }
}

/**
 * Enrich vulnerability with AI when traditional sources fail
 */
export async function enrichWithAIFallback(
  vuln: NormalizedVulnerability,
  existingIntel: ThreatIntelligence | null
): Promise<NormalizedVulnerability> {
  // If we already have good intel, skip AI
  if (existingIntel?.nvdScore && existingIntel.nvdDescription) {
    return vuln;
  }

  // Use AI for analysis
  const [aiAnalysis, aiIntel, classification] = await Promise.all([
    analyzeWithAI(vuln),
    generateAIThreatIntel(vuln),
    classifyUnknownVuln(vuln),
  ]);

  const enriched = { ...vuln };

  // Apply AI analysis
  if (aiAnalysis) {
    enriched.confidence = aiAnalysis.riskAssessment.confidence;
    if (!enriched.remediation && aiAnalysis.recommendations.length > 0) {
      enriched.remediation = aiAnalysis.recommendations.join('; ');
    }
    // Add MITRE techniques if found
    if (aiAnalysis.mitreTechniques.length > 0) {
      (enriched as any).aiMitreTechniques = aiAnalysis.mitreTechniques;
    }
    // Add related CVEs for research
    if (aiAnalysis.relatedCVEs.length > 0) {
      (enriched as any).aiRelatedCVEs = aiAnalysis.relatedCVEs;
    }
  }

  // Apply classification
  if (classification) {
    if (!enriched.cwe || enriched.cwe.length === 0) {
      enriched.cwe = [classification.cweId];
    }
    (enriched as any).aiCategory = classification.category;
    (enriched as any).aiOwaspCategory = classification.owaspCategory;
  }

  // Mark as AI-enriched
  (enriched as any).aiEnriched = true;
  (enriched as any).aiEnrichedAt = new Date().toISOString();

  return enriched;
}
