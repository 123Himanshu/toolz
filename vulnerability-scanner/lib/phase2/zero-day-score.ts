/**
 * Zero-Day Exposure Score (ZDES) Calculator
 * Scores assets based on zero-day exposure risk factors
 */

import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from './types';

export interface ZeroDayIndicator {
  type: 'exposure' | 'anomaly' | 'eol' | 'config';
  description: string;
  severity: 'critical' | 'high' | 'medium' | 'low';
  confidence: number;
  details?: Record<string, any>;
}

export interface ZDESResult {
  score: number;              // 0-100
  label: 'critical' | 'high' | 'medium' | 'low';
  indicators: ZeroDayIndicator[];
  breakdown: {
    unknownServices: number;
    eolSoftware: number;
    unknownVersions: number;
    weakConfigs: number;
    abnormalPorts: number;
    patchStatus: number;
    externalExposure: number;
  };
}

// End-of-Life Software Database
const EOL_SOFTWARE: Record<string, Date> = {
  'windows 7': new Date('2020-01-14'),
  'windows server 2008': new Date('2020-01-14'),
  'windows server 2012': new Date('2023-10-10'),
  'ubuntu 16.04': new Date('2021-04-30'),
  'ubuntu 18.04': new Date('2023-05-31'),
  'centos 6': new Date('2020-11-30'),
  'centos 7': new Date('2024-06-30'),
  'centos 8': new Date('2021-12-31'),
  'debian 9': new Date('2022-06-30'),
  'php 5': new Date('2019-01-01'),
  'php 7.0': new Date('2019-01-10'),
  'php 7.1': new Date('2019-12-01'),
  'php 7.2': new Date('2020-11-30'),
  'python 2': new Date('2020-01-01'),
  'python 3.5': new Date('2020-09-13'),
  'python 3.6': new Date('2021-12-23'),
  'node 10': new Date('2021-04-30'),
  'node 12': new Date('2022-04-30'),
  'node 14': new Date('2023-04-30'),
  'apache 2.2': new Date('2017-07-11'),
  'nginx 1.14': new Date('2020-04-21'),
  'mysql 5.5': new Date('2018-12-03'),
  'mysql 5.6': new Date('2021-02-05'),
  'postgresql 9': new Date('2021-11-11'),
  'postgresql 10': new Date('2022-11-10'),
  'openssh 6': new Date('2020-01-01'),
  'openssh 7.0': new Date('2020-01-01'),
};

// Standard port mappings
const STANDARD_PORTS: Record<string, number[]> = {
  'http': [80, 8080, 8000, 8888],
  'https': [443, 8443],
  'ssh': [22],
  'ftp': [21],
  'smtp': [25, 587, 465],
  'mysql': [3306],
  'postgresql': [5432],
  'mongodb': [27017],
  'redis': [6379],
  'rdp': [3389],
  'smb': [445, 139],
  'dns': [53],
  'telnet': [23],
};

// Weak configuration keywords
const WEAK_CONFIG_KEYWORDS = [
  'default', 'misconfiguration', 'weak', 'insecure',
  'anonymous', 'unauthenticated', 'exposed', 'open',
  'no authentication', 'no password', 'blank password'
];

/**
 * Calculate Zero-Day Exposure Score for an asset
 */
export function calculateZDES(
  host: DiscoveredHost,
  vulnerabilities: NormalizedVulnerability[],
  services: DiscoveredService[]
): ZDESResult {
  const indicators: ZeroDayIndicator[] = [];
  const breakdown = {
    unknownServices: 0,
    eolSoftware: 0,
    unknownVersions: 0,
    weakConfigs: 0,
    abnormalPorts: 0,
    patchStatus: 0,
    externalExposure: 0,
  };

  // Filter vulns for this host
  const hostVulns = vulnerabilities.filter(v => v.host === host.ip || v.host === host.hostname);
  const hostServices = services.filter(s => s.host === host.ip);

  // Factor 1: Unknown/unclassified services (0-20 points)
  const unknownResult = scoreUnknownServices(hostVulns, hostServices);
  breakdown.unknownServices = unknownResult.score;
  indicators.push(...unknownResult.indicators);

  // Factor 2: EOL software (0-25 points)
  const eolResult = scoreEOLSoftware(host, hostServices);
  breakdown.eolSoftware = eolResult.score;
  indicators.push(...eolResult.indicators);

  // Factor 3: Unknown version fingerprints (0-15 points)
  const versionResult = scoreUnknownVersions(hostServices);
  breakdown.unknownVersions = versionResult.score;
  indicators.push(...versionResult.indicators);

  // Factor 4: Weak configurations (0-10 points)
  const configResult = scoreWeakConfigs(hostVulns);
  breakdown.weakConfigs = configResult.score;
  indicators.push(...configResult.indicators);

  // Factor 5: Abnormal port-service mapping (0-10 points)
  const portResult = scoreAbnormalPorts(hostServices);
  breakdown.abnormalPorts = portResult.score;
  indicators.push(...portResult.indicators);

  // Factor 6: Lack of patches (0-10 points)
  const patchResult = scorePatchStatus(hostVulns);
  breakdown.patchStatus = patchResult.score;
  indicators.push(...patchResult.indicators);

  // Factor 7: External exposure (0-10 points)
  const exposureResult = scoreExternalExposure(host, hostVulns, hostServices);
  breakdown.externalExposure = exposureResult.score;
  indicators.push(...exposureResult.indicators);

  // Calculate total score
  const totalScore = Math.min(100,
    breakdown.unknownServices +
    breakdown.eolSoftware +
    breakdown.unknownVersions +
    breakdown.weakConfigs +
    breakdown.abnormalPorts +
    breakdown.patchStatus +
    breakdown.externalExposure
  );

  // Determine label
  let label: ZDESResult['label'];
  if (totalScore >= 75) label = 'critical';
  else if (totalScore >= 50) label = 'high';
  else if (totalScore >= 25) label = 'medium';
  else label = 'low';

  return {
    score: totalScore,
    label,
    indicators,
    breakdown
  };
}

function scoreUnknownServices(
  vulns: NormalizedVulnerability[],
  services: DiscoveredService[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let unknownCount = 0;

  for (const service of services) {
    if (!service.service || service.service === 'unknown' || service.service === 'tcpwrapped') {
      unknownCount++;
      indicators.push({
        type: 'exposure',
        description: `Unknown service on port ${service.port}`,
        severity: 'medium',
        confidence: 0.6,
        details: { port: service.port }
      });
    }
  }

  const ratio = services.length > 0 ? unknownCount / services.length : 0;
  return { score: Math.round(ratio * 20), indicators };
}

function scoreEOLSoftware(
  host: DiscoveredHost,
  services: DiscoveredService[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let score = 0;
  const now = new Date();

  // Check OS
  if (host.os) {
    const osLower = host.os.toLowerCase();
    for (const [software, eolDate] of Object.entries(EOL_SOFTWARE)) {
      if (osLower.includes(software) && now > eolDate) {
        score += 15;
        indicators.push({
          type: 'eol',
          description: `End-of-Life operating system: ${host.os}`,
          severity: 'high',
          confidence: 0.9,
          details: { eolDate: eolDate.toISOString() }
        });
        break;
      }
    }
  }

  // Check service versions
  for (const service of services) {
    if (service.version) {
      const versionLower = `${service.service} ${service.version}`.toLowerCase();
      for (const [software, eolDate] of Object.entries(EOL_SOFTWARE)) {
        if (versionLower.includes(software) && now > eolDate) {
          score += 5;
          indicators.push({
            type: 'eol',
            description: `EOL software: ${service.service} ${service.version}`,
            severity: 'medium',
            confidence: 0.8,
            details: { eolDate: eolDate.toISOString() }
          });
          break;
        }
      }
    }
  }

  return { score: Math.min(25, score), indicators };
}

function scoreUnknownVersions(
  services: DiscoveredService[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let unknownCount = 0;

  for (const service of services) {
    if (service.service && service.service !== 'unknown') {
      if (!service.version) {
        unknownCount++;
        indicators.push({
          type: 'exposure',
          description: `Unknown version for ${service.service} on port ${service.port}`,
          severity: 'low',
          confidence: 0.5,
          details: { service: service.service, port: service.port }
        });
      }
    }
  }

  const ratio = services.length > 0 ? unknownCount / services.length : 0;
  return { score: Math.round(ratio * 15), indicators };
}

function scoreWeakConfigs(
  vulns: NormalizedVulnerability[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let score = 0;

  for (const vuln of vulns) {
    const text = `${vuln.title} ${vuln.description}`.toLowerCase();
    for (const keyword of WEAK_CONFIG_KEYWORDS) {
      if (text.includes(keyword)) {
        score += 2;
        indicators.push({
          type: 'config',
          description: `Weak configuration: ${vuln.title}`,
          severity: 'medium',
          confidence: 0.7,
          details: { keyword }
        });
        break;
      }
    }
  }

  return { score: Math.min(10, score), indicators };
}

function scoreAbnormalPorts(
  services: DiscoveredService[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let score = 0;

  for (const service of services) {
    if (service.service && service.port) {
      const expectedPorts = STANDARD_PORTS[service.service.toLowerCase()];
      if (expectedPorts && !expectedPorts.includes(service.port)) {
        score += 2;
        indicators.push({
          type: 'anomaly',
          description: `${service.service} on non-standard port ${service.port}`,
          severity: 'low',
          confidence: 0.6,
          details: { service: service.service, port: service.port, expectedPorts }
        });
      }
    }
  }

  return { score: Math.min(10, score), indicators };
}

function scorePatchStatus(
  vulns: NormalizedVulnerability[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let unpatchedCount = 0;

  for (const vuln of vulns) {
    if (vuln.cve && vuln.cve.length > 0 && vuln.severity.score >= 7.0) {
      unpatchedCount++;
      indicators.push({
        type: 'exposure',
        description: `Unpatched high-severity CVE: ${vuln.cve.join(', ')}`,
        severity: 'high',
        confidence: 0.8,
        details: { cve: vuln.cve, cvss: vuln.severity.score }
      });
    }
  }

  const ratio = vulns.length > 0 ? unpatchedCount / vulns.length : 0;
  return { score: Math.round(ratio * 10), indicators };
}

function scoreExternalExposure(
  host: DiscoveredHost,
  vulns: NormalizedVulnerability[],
  services: DiscoveredService[]
): { score: number; indicators: ZeroDayIndicator[] } {
  const indicators: ZeroDayIndicator[] = [];
  let score = 0;

  // Check for internet-facing services
  const internetPorts = [21, 22, 23, 25, 80, 443, 3389, 8080, 8443];
  const exposedServices = services.filter(s => internetPorts.includes(s.port));

  if (exposedServices.length > 0) {
    score += 5;

    // Additional points for vulnerable exposed services
    for (const vuln of vulns) {
      if (vuln.severity.score >= 7.0 && vuln.port && internetPorts.includes(vuln.port)) {
        score += 1;
        indicators.push({
          type: 'exposure',
          description: `Externally exposed vulnerable service: ${vuln.service || 'unknown'} on port ${vuln.port}`,
          severity: 'high',
          confidence: 0.9,
          details: { port: vuln.port, cvss: vuln.severity.score }
        });
      }
    }
  }

  return { score: Math.min(10, score), indicators };
}

/**
 * Calculate ZDES for all hosts
 */
export function calculateAllZDES(
  hosts: DiscoveredHost[],
  vulnerabilities: NormalizedVulnerability[],
  services: DiscoveredService[]
): Map<string, ZDESResult> {
  const results = new Map<string, ZDESResult>();

  for (const host of hosts) {
    const result = calculateZDES(host, vulnerabilities, services);
    results.set(host.ip, result);
  }

  return results;
}
