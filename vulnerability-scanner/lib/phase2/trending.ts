/**
 * Historical Trending Module
 * Track vulnerability counts and risk scores over time
 */

import { ScanSession } from './types';
import fs from 'fs';
import path from 'path';

const TRENDING_FILE = path.join(process.cwd(), '.scan-data', 'phase2', 'trending.json');

export interface TrendingDataPoint {
  timestamp: string;
  scanId: string;
  target: string;
  vulnerabilities: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  riskScore: number;
  hostsDiscovered: number;
  servicesDiscovered: number;
}

export interface TrendingData {
  dataPoints: TrendingDataPoint[];
  lastUpdated: string;
}

/**
 * Record a scan session for trending
 */
export function recordTrendingData(session: ScanSession): void {
  const data = loadTrendingData();
  
  const dataPoint: TrendingDataPoint = {
    timestamp: session.completedAt || new Date().toISOString(),
    scanId: session.id,
    target: session.target,
    vulnerabilities: {
      total: session.vulnerabilitiesFound,
      ...session.severityBreakdown
    },
    riskScore: session.overallRiskScore,
    hostsDiscovered: session.hostsDiscovered,
    servicesDiscovered: session.servicesDiscovered
  };

  data.dataPoints.push(dataPoint);
  data.lastUpdated = new Date().toISOString();

  // Keep last 1000 data points
  if (data.dataPoints.length > 1000) {
    data.dataPoints = data.dataPoints.slice(-1000);
  }

  saveTrendingData(data);
}


/**
 * Get trending data for a specific target
 */
export function getTrendingForTarget(target: string, days: number = 30): TrendingDataPoint[] {
  const data = loadTrendingData();
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - days);

  return data.dataPoints.filter(dp => 
    dp.target === target && new Date(dp.timestamp) >= cutoff
  );
}

/**
 * Get overall trending data
 */
export function getOverallTrending(days: number = 30): TrendAnalysis {
  const data = loadTrendingData();
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - days);

  const recentData = data.dataPoints.filter(dp => new Date(dp.timestamp) >= cutoff);

  if (recentData.length < 2) {
    return {
      trend: 'stable',
      changePercent: 0,
      dataPoints: recentData,
      summary: 'Insufficient data for trend analysis'
    };
  }

  // Calculate trend
  const firstHalf = recentData.slice(0, Math.floor(recentData.length / 2));
  const secondHalf = recentData.slice(Math.floor(recentData.length / 2));

  const avgFirst = average(firstHalf.map(d => d.vulnerabilities.total));
  const avgSecond = average(secondHalf.map(d => d.vulnerabilities.total));

  const changePercent = avgFirst > 0 ? ((avgSecond - avgFirst) / avgFirst) * 100 : 0;

  let trend: 'increasing' | 'decreasing' | 'stable';
  if (changePercent > 10) trend = 'increasing';
  else if (changePercent < -10) trend = 'decreasing';
  else trend = 'stable';

  return {
    trend,
    changePercent: Math.round(changePercent * 10) / 10,
    dataPoints: recentData,
    summary: generateTrendSummary(trend, changePercent, recentData)
  };
}

export interface TrendAnalysis {
  trend: 'increasing' | 'decreasing' | 'stable';
  changePercent: number;
  dataPoints: TrendingDataPoint[];
  summary: string;
}

function average(nums: number[]): number {
  if (nums.length === 0) return 0;
  return nums.reduce((a, b) => a + b, 0) / nums.length;
}

function generateTrendSummary(
  trend: string,
  changePercent: number,
  data: TrendingDataPoint[]
): string {
  const totalScans = data.length;
  const avgVulns = Math.round(average(data.map(d => d.vulnerabilities.total)));
  const avgRisk = Math.round(average(data.map(d => d.riskScore)));

  if (trend === 'increasing') {
    return `Vulnerability count increased by ${Math.abs(changePercent)}% over ${totalScans} scans. Average: ${avgVulns} vulnerabilities, risk score: ${avgRisk}`;
  } else if (trend === 'decreasing') {
    return `Vulnerability count decreased by ${Math.abs(changePercent)}% over ${totalScans} scans. Average: ${avgVulns} vulnerabilities, risk score: ${avgRisk}`;
  }
  return `Vulnerability count stable over ${totalScans} scans. Average: ${avgVulns} vulnerabilities, risk score: ${avgRisk}`;
}

/**
 * Get risk score trend
 */
export function getRiskTrend(target?: string, days: number = 30): {
  current: number;
  previous: number;
  change: number;
  trend: 'up' | 'down' | 'stable';
} {
  const data = loadTrendingData();
  const cutoff = new Date();
  cutoff.setDate(cutoff.getDate() - days);

  let recentData = data.dataPoints.filter(dp => new Date(dp.timestamp) >= cutoff);
  if (target) {
    recentData = recentData.filter(dp => dp.target === target);
  }

  if (recentData.length < 2) {
    return { current: 0, previous: 0, change: 0, trend: 'stable' };
  }

  const current = recentData[recentData.length - 1].riskScore;
  const previous = recentData[0].riskScore;
  const change = current - previous;

  return {
    current,
    previous,
    change,
    trend: change > 5 ? 'up' : change < -5 ? 'down' : 'stable'
  };
}

function loadTrendingData(): TrendingData {
  try {
    if (fs.existsSync(TRENDING_FILE)) {
      return JSON.parse(fs.readFileSync(TRENDING_FILE, 'utf-8'));
    }
  } catch (e) {
    console.error('Error loading trending data:', e);
  }
  return { dataPoints: [], lastUpdated: new Date().toISOString() };
}

function saveTrendingData(data: TrendingData): void {
  try {
    const dir = path.dirname(TRENDING_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(TRENDING_FILE, JSON.stringify(data, null, 2));
  } catch (e) {
    console.error('Error saving trending data:', e);
  }
}
