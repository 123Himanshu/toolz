/**
 * Phase 2 Database Storage Layer
 * Integrates PostgreSQL, MongoDB, Redis, and Elasticsearch
 */

import { query, queryOne, transaction } from '../db/postgres';
import { 
  storeRawOutput, 
  getRawOutput, 
  logScanEvent, 
  storeToolOutput,
  storeAttackGraph,
  storeZeroDayIndicator 
} from '../db/mongodb';
import { cacheSet, cacheGet, cacheDelete } from '../db/redis';
import { 
  indexDocument, 
  bulkIndex, 
  searchVulnerabilities,
  INDICES 
} from '../db/elasticsearch';
import {
  NormalizedVulnerability,
  DiscoveredHost,
  DiscoveredService,
  ScanSession,
  AttackPath,
  VulnerabilityQuery,
  QueryResult
} from './types';
import crypto from 'crypto';

// ============================================================================
// VULNERABILITY OPERATIONS
// ============================================================================

export async function storeVulnerability(vuln: NormalizedVulnerability): Promise<void> {
  // Store in PostgreSQL
  await query(`
    INSERT INTO vulnerabilities (
      id, scan_id, asset_id, canonical_id, scanner, scanner_category, scanner_id,
      host, port, protocol, service, url, title, description,
      severity_score, severity_label, cve, cwe, evidence, request, response,
      matched_at, remediation, references, confidence, verified, false_positive,
      fingerprint, duplicate_of, duplicate_count, discovered_at, updated_at
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14,
      $15, $16, $17, $18, $19, $20, $21, $22, $23, $24, $25, $26, $27,
      $28, $29, $30, $31, $32
    )
    ON CONFLICT (id) DO UPDATE SET
      severity_score = EXCLUDED.severity_score,
      severity_label = EXCLUDED.severity_label,
      confidence = EXCLUDED.confidence,
      duplicate_count = EXCLUDED.duplicate_count,
      updated_at = CURRENT_TIMESTAMP
  `, [
    vuln.id, vuln.scanId, null, null, vuln.scanner, vuln.scannerCategory, vuln.scannerId,
    vuln.host, vuln.port, vuln.protocol, vuln.service, vuln.url, vuln.title, vuln.description,
    vuln.severity.score, vuln.severity.label, vuln.cve, vuln.cwe, vuln.evidence, vuln.request, vuln.response,
    vuln.matchedAt, vuln.remediation, vuln.references, vuln.confidence, vuln.verified, vuln.falsePositive,
    vuln.fingerprint, vuln.duplicateOf, vuln.duplicateCount, vuln.discoveredAt, vuln.updatedAt
  ]);

  // Index in Elasticsearch
  try {
    await indexDocument(INDICES.VULNERABILITIES, vuln.id, {
      ...vuln,
      severityScore: vuln.severity.score,
      severityLabel: vuln.severity.label,
    });
  } catch (error) {
    console.warn('Elasticsearch indexing failed:', error);
  }

  // Cache in Redis (short TTL for recent vulns)
  await cacheSet(`vuln:${vuln.id}`, vuln, 3600);
}

export async function storeVulnerabilities(vulns: NormalizedVulnerability[]): Promise<void> {
  if (vulns.length === 0) return;

  // Batch insert to PostgreSQL
  for (const vuln of vulns) {
    await storeVulnerability(vuln);
  }

  // Bulk index to Elasticsearch
  try {
    await bulkIndex(
      INDICES.VULNERABILITIES,
      vulns.map(v => ({
        id: v.id,
        doc: {
          ...v,
          severityScore: v.severity.score,
          severityLabel: v.severity.label,
        }
      }))
    );
  } catch (error) {
    console.warn('Elasticsearch bulk indexing failed:', error);
  }
}

export async function getVulnerability(id: string): Promise<NormalizedVulnerability | null> {
  // Check Redis cache first
  const cached = await cacheGet<NormalizedVulnerability>(`vuln:${id}`);
  if (cached) return cached;

  // Query PostgreSQL
  const row = await queryOne<any>(`
    SELECT * FROM vulnerabilities WHERE id = $1
  `, [id]);

  if (!row) return null;

  const vuln = rowToVulnerability(row);
  
  // Cache for future requests
  await cacheSet(`vuln:${id}`, vuln, 3600);
  
  return vuln;
}

export async function queryVulnerabilitiesDB(q: VulnerabilityQuery): Promise<QueryResult<NormalizedVulnerability>> {
  // Try Elasticsearch first for full-text search
  if (q.search) {
    try {
      const esResult = await searchVulnerabilities({
        query: q.search,
        scanId: q.scanId,
        host: q.host,
        severity: q.severity as string | string[],
        scanner: q.scanner as string | string[],
        cve: q.cve,
        page: q.page,
        limit: q.limit,
      });

      return {
        data: esResult.hits as NormalizedVulnerability[],
        total: esResult.total,
        page: q.page || 1,
        limit: q.limit || 50,
        hasMore: (q.page || 1) * (q.limit || 50) < esResult.total,
      };
    } catch (error) {
      console.warn('Elasticsearch search failed, falling back to PostgreSQL:', error);
    }
  }

  // PostgreSQL query
  let sql = 'SELECT * FROM vulnerabilities WHERE 1=1';
  const params: any[] = [];
  let paramIndex = 1;

  if (q.scanId) {
    sql += ` AND scan_id = $${paramIndex++}`;
    params.push(q.scanId);
  }

  if (q.scanner) {
    const scanners = Array.isArray(q.scanner) ? q.scanner : [q.scanner];
    sql += ` AND scanner = ANY($${paramIndex++})`;
    params.push(scanners);
  }

  if (q.host) {
    sql += ` AND host ILIKE $${paramIndex++}`;
    params.push(`%${q.host}%`);
  }

  if (q.port) {
    sql += ` AND port = $${paramIndex++}`;
    params.push(q.port);
  }

  if (q.severity) {
    const severities = Array.isArray(q.severity) ? q.severity : [q.severity];
    sql += ` AND severity_label = ANY($${paramIndex++})`;
    params.push(severities);
  }

  if (q.cve) {
    sql += ` AND $${paramIndex++} = ANY(cve)`;
    params.push(q.cve);
  }

  if (q.uniqueOnly) {
    sql += ' AND duplicate_of IS NULL';
  }

  if (!q.includeFalsePositives) {
    sql += ' AND false_positive = false';
  }

  // Count total
  const countResult = await queryOne<{ count: string }>(
    sql.replace('SELECT *', 'SELECT COUNT(*) as count'),
    params
  );
  const total = parseInt(countResult?.count || '0', 10);

  // Add sorting
  const sortBy = q.sortBy || 'severity';
  const sortOrder = q.sortOrder || 'desc';
  const sortColumn = {
    severity: 'severity_score',
    host: 'host',
    scanner: 'scanner',
    discoveredAt: 'discovered_at',
  }[sortBy] || 'severity_score';
  
  sql += ` ORDER BY ${sortColumn} ${sortOrder.toUpperCase()}`;

  // Add pagination
  const page = q.page || 1;
  const limit = q.limit || 50;
  sql += ` LIMIT $${paramIndex++} OFFSET $${paramIndex++}`;
  params.push(limit, (page - 1) * limit);

  const rows = await query<any>(sql, params);
  const data = rows.map(rowToVulnerability);

  return {
    data,
    total,
    page,
    limit,
    hasMore: page * limit < total,
  };
}

// ============================================================================
// HOST OPERATIONS
// ============================================================================

export async function storeHost(host: DiscoveredHost): Promise<void> {
  await query(`
    INSERT INTO assets (
      id, ip_address, hostname, mac_address, os, os_version,
      network_segment, is_external, first_seen, last_seen,
      risk_score, zdes_score, tags, metadata
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
    )
    ON CONFLICT (ip_address) DO UPDATE SET
      hostname = COALESCE(EXCLUDED.hostname, assets.hostname),
      last_seen = EXCLUDED.last_seen,
      risk_score = GREATEST(assets.risk_score, EXCLUDED.risk_score),
      zdes_score = GREATEST(assets.zdes_score, EXCLUDED.zdes_score)
  `, [
    host.id, host.ip, host.hostname, host.mac, host.os, host.osVersion,
    null, host.state === 'up', host.firstSeen, host.lastSeen,
    host.riskScore, 0, host.tags, JSON.stringify({ vulnerabilityCount: host.vulnerabilityCount })
  ]);

  // Index in Elasticsearch
  try {
    await indexDocument(INDICES.ASSETS, host.id, host);
  } catch (error) {
    console.warn('Elasticsearch host indexing failed:', error);
  }
}

export async function storeHosts(hosts: DiscoveredHost[]): Promise<void> {
  for (const host of hosts) {
    await storeHost(host);
  }
}

export async function getHost(ip: string): Promise<DiscoveredHost | null> {
  const row = await queryOne<any>(`
    SELECT * FROM assets WHERE ip_address = $1
  `, [ip]);

  if (!row) return null;
  return rowToHost(row);
}

export async function getAllHosts(): Promise<DiscoveredHost[]> {
  const rows = await query<any>('SELECT * FROM assets ORDER BY risk_score DESC');
  return rows.map(rowToHost);
}

// ============================================================================
// SERVICE OPERATIONS
// ============================================================================

export async function storeService(service: DiscoveredService): Promise<void> {
  // Get asset ID
  const asset = await queryOne<{ id: string }>(
    'SELECT id FROM assets WHERE ip_address = $1',
    [service.host]
  );

  await query(`
    INSERT INTO services (
      id, asset_id, port, protocol, service_name, service_version,
      product, banner, state, first_seen, last_seen, risk_score
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
    )
    ON CONFLICT (asset_id, port, protocol) DO UPDATE SET
      service_version = COALESCE(EXCLUDED.service_version, services.service_version),
      product = COALESCE(EXCLUDED.product, services.product),
      last_seen = EXCLUDED.last_seen,
      risk_score = GREATEST(services.risk_score, EXCLUDED.risk_score)
  `, [
    service.id, asset?.id, service.port, service.protocol, service.service,
    service.version, service.product, service.banner, service.state,
    service.firstSeen, service.lastSeen, service.riskScore
  ]);
}

export async function storeServices(services: DiscoveredService[]): Promise<void> {
  for (const service of services) {
    await storeService(service);
  }
}

export async function getAllServices(): Promise<DiscoveredService[]> {
  const rows = await query<any>(`
    SELECT s.*, a.ip_address as host 
    FROM services s 
    LEFT JOIN assets a ON s.asset_id = a.id
    ORDER BY s.risk_score DESC
  `);
  return rows.map(rowToService);
}

// ============================================================================
// SCAN SESSION OPERATIONS
// ============================================================================

export async function storeScanSession(session: ScanSession): Promise<void> {
  await query(`
    INSERT INTO scans (
      id, user_id, target, scan_type, status, tools,
      started_at, completed_at, duration_seconds, raw_output_ref
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
    )
    ON CONFLICT (id) DO UPDATE SET
      status = EXCLUDED.status,
      completed_at = EXCLUDED.completed_at,
      duration_seconds = EXCLUDED.duration_seconds
  `, [
    session.id, null, session.target, session.scanType, 'completed',
    session.tools, session.startedAt, session.completedAt, session.duration, null
  ]);

  // Log to MongoDB
  await logScanEvent({
    scanId: session.id,
    level: 'info',
    message: 'Scan session stored',
    metadata: {
      target: session.target,
      tools: session.tools,
      vulnerabilitiesFound: session.vulnerabilitiesFound,
    }
  });
}

export async function getScanSession(id: string): Promise<ScanSession | null> {
  const row = await queryOne<any>(`
    SELECT * FROM scans WHERE id = $1
  `, [id]);

  if (!row) return null;
  return rowToSession(row);
}

// ============================================================================
// RAW OUTPUT OPERATIONS (MongoDB)
// ============================================================================

export async function storeRawScanOutput(
  scanId: string,
  tool: string,
  target: string,
  output: any
): Promise<string> {
  const checksum = crypto.createHash('sha256').update(JSON.stringify(output)).digest('hex');
  
  return storeRawOutput({
    scanId,
    tool,
    target,
    output,
    outputType: 'json',
    size: JSON.stringify(output).length,
    checksum,
  });
}

export async function getRawScanOutput(scanId: string, tool: string): Promise<any> {
  const raw = await getRawOutput(scanId, tool);
  return raw?.output || null;
}

// ============================================================================
// ATTACK PATH OPERATIONS
// ============================================================================

export async function storeAttackPathDB(path: AttackPath): Promise<void> {
  await query(`
    INSERT INTO attack_paths (
      id, scan_id, name, description, entry_point, target, path_type,
      nodes, edges, critical_path, overall_risk, exploitability, impact,
      mitigations, prioritized_fixes
    ) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
    )
  `, [
    path.id, path.scanId, path.name, path.description, path.entryPoints[0],
    path.targets[0], 'chained', JSON.stringify(path.nodes), JSON.stringify(path.edges),
    path.criticalPath, path.overallRisk, path.exploitability, path.impact,
    path.mitigations, path.prioritizedFixes
  ]);

  // Store graph in MongoDB for complex queries
  await storeAttackGraph({
    scanId: path.scanId,
    nodes: path.nodes,
    edges: path.edges,
    metadata: {
      nodeCount: path.nodes.length,
      edgeCount: path.edges.length,
      entryPoints: path.entryPoints,
      criticalAssets: path.targets,
    }
  });
}

export async function getAttackPathsByScan(scanId: string): Promise<AttackPath[]> {
  const rows = await query<any>(`
    SELECT * FROM attack_paths WHERE scan_id = $1 ORDER BY overall_risk DESC
  `, [scanId]);

  return rows.map(row => ({
    id: row.id,
    scanId: row.scan_id,
    name: row.name,
    description: row.description,
    nodes: row.nodes,
    edges: row.edges,
    entryPoints: [row.entry_point],
    targets: [row.target],
    criticalPath: row.critical_path,
    overallRisk: parseFloat(row.overall_risk),
    exploitability: parseFloat(row.exploitability),
    impact: parseFloat(row.impact),
    mitigations: row.mitigations,
    prioritizedFixes: row.prioritized_fixes,
  }));
}

// ============================================================================
// STATISTICS
// ============================================================================

export async function getStatistics(): Promise<{
  totalVulnerabilities: number;
  totalHosts: number;
  totalServices: number;
  totalSessions: number;
  severityBreakdown: Record<string, number>;
  scannerBreakdown: Record<string, number>;
}> {
  const [vulnCount, hostCount, serviceCount, sessionCount] = await Promise.all([
    queryOne<{ count: string }>('SELECT COUNT(*) as count FROM vulnerabilities'),
    queryOne<{ count: string }>('SELECT COUNT(*) as count FROM assets'),
    queryOne<{ count: string }>('SELECT COUNT(*) as count FROM services'),
    queryOne<{ count: string }>('SELECT COUNT(*) as count FROM scans'),
  ]);

  const severityRows = await query<{ severity_label: string; count: string }>(`
    SELECT severity_label, COUNT(*) as count 
    FROM vulnerabilities 
    GROUP BY severity_label
  `);

  const scannerRows = await query<{ scanner: string; count: string }>(`
    SELECT scanner, COUNT(*) as count 
    FROM vulnerabilities 
    GROUP BY scanner
  `);

  const severityBreakdown: Record<string, number> = {
    critical: 0, high: 0, medium: 0, low: 0, info: 0
  };
  for (const row of severityRows) {
    severityBreakdown[row.severity_label] = parseInt(row.count, 10);
  }

  const scannerBreakdown: Record<string, number> = {};
  for (const row of scannerRows) {
    scannerBreakdown[row.scanner] = parseInt(row.count, 10);
  }

  return {
    totalVulnerabilities: parseInt(vulnCount?.count || '0', 10),
    totalHosts: parseInt(hostCount?.count || '0', 10),
    totalServices: parseInt(serviceCount?.count || '0', 10),
    totalSessions: parseInt(sessionCount?.count || '0', 10),
    severityBreakdown,
    scannerBreakdown,
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function rowToVulnerability(row: any): NormalizedVulnerability {
  return {
    id: row.id,
    scanId: row.scan_id,
    scanner: row.scanner,
    scannerCategory: row.scanner_category,
    scannerId: row.scanner_id,
    host: row.host,
    port: row.port,
    protocol: row.protocol,
    service: row.service,
    url: row.url,
    title: row.title,
    description: row.description,
    severity: {
      score: parseFloat(row.severity_score),
      label: row.severity_label,
    },
    cve: row.cve,
    cwe: row.cwe,
    evidence: row.evidence,
    request: row.request,
    response: row.response,
    matchedAt: row.matched_at,
    remediation: row.remediation,
    references: row.references,
    confidence: row.confidence,
    verified: row.verified,
    falsePositive: row.false_positive,
    fingerprint: row.fingerprint,
    duplicateOf: row.duplicate_of,
    duplicateCount: row.duplicate_count,
    discoveredAt: row.discovered_at?.toISOString(),
    updatedAt: row.updated_at?.toISOString(),
  };
}

function rowToHost(row: any): DiscoveredHost {
  const metadata = row.metadata || {};
  return {
    id: row.id,
    ip: row.ip_address,
    hostname: row.hostname,
    mac: row.mac_address,
    os: row.os,
    osVersion: row.os_version,
    discoveredBy: [],
    firstSeen: row.first_seen?.toISOString(),
    lastSeen: row.last_seen?.toISOString(),
    state: row.is_external ? 'up' : 'up',
    openPorts: [],
    services: [],
    vulnerabilityCount: metadata.vulnerabilityCount || {
      critical: 0, high: 0, medium: 0, low: 0, info: 0
    },
    riskScore: parseFloat(row.risk_score) || 0,
    tags: row.tags,
  };
}

function rowToService(row: any): DiscoveredService {
  return {
    id: row.id,
    hostId: row.asset_id,
    host: row.host || row.ip_address,
    port: row.port,
    protocol: row.protocol,
    service: row.service_name,
    version: row.service_version,
    product: row.product,
    discoveredBy: [],
    firstSeen: row.first_seen?.toISOString(),
    lastSeen: row.last_seen?.toISOString(),
    state: row.state,
    vulnerabilityCount: 0,
    riskScore: parseFloat(row.risk_score) || 0,
    banner: row.banner,
  };
}

function rowToSession(row: any): ScanSession {
  return {
    id: row.id,
    target: row.target,
    scanType: row.scan_type,
    tools: row.tools || [],
    toolResults: {},
    startedAt: row.started_at?.toISOString(),
    completedAt: row.completed_at?.toISOString(),
    duration: row.duration_seconds,
    hostsDiscovered: 0,
    servicesDiscovered: 0,
    vulnerabilitiesFound: 0,
    severityBreakdown: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
    totalFindings: 0,
    uniqueFindings: 0,
    duplicatesRemoved: 0,
    overallRiskScore: 0,
  };
}

export default {
  storeVulnerability,
  storeVulnerabilities,
  getVulnerability,
  queryVulnerabilitiesDB,
  storeHost,
  storeHosts,
  getHost,
  getAllHosts,
  storeService,
  storeServices,
  getAllServices,
  storeScanSession,
  getScanSession,
  storeRawScanOutput,
  getRawScanOutput,
  storeAttackPathDB,
  getAttackPathsByScan,
  getStatistics,
};
