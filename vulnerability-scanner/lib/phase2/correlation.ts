/**
 * Correlation Engine
 * Build relationships between findings, hosts, services, and CVEs
 */

import {
  NormalizedVulnerability,
  DiscoveredHost,
  DiscoveredService,
  Technology,
  CorrelatedFinding,
  ThreatIntelligence
} from './types';

export interface CorrelationResult {
  // Correlated findings
  correlatedFindings: Map<string, CorrelatedFinding>;
  
  // Relationship graphs
  hostToVulnerabilities: Map<string, string[]>;
  cveToHosts: Map<string, string[]>;
  serviceToVulnerabilities: Map<string, string[]>;
  techToVulnerabilities: Map<string, string[]>;
  
  // Cross-scanner verification
  multiScannerFindings: NormalizedVulnerability[];
  singleScannerFindings: NormalizedVulnerability[];
  
  // Statistics
  stats: {
    totalCorrelations: number;
    crossScannerVerified: number;
    cveCorrelations: number;
    hostCorrelations: number;
  };
}

export class CorrelationEngine {
  private threatIntelCache: Map<string, ThreatIntelligence>;

  constructor() {
    this.threatIntelCache = new Map();
  }

  /**
   * Correlate all findings
   */
  correlate(
    vulnerabilities: NormalizedVulnerability[],
    hosts: DiscoveredHost[],
    services: DiscoveredService[],
    technologies: Technology[] = []
  ): CorrelationResult {
    // Build relationship maps
    const hostToVulnerabilities = this.buildHostToVulnMap(vulnerabilities);
    const cveToHosts = this.buildCVEToHostsMap(vulnerabilities);
    const serviceToVulnerabilities = this.buildServiceToVulnMap(vulnerabilities, services);
    const techToVulnerabilities = this.buildTechToVulnMap(vulnerabilities, technologies);

    // Correlate individual findings
    const correlatedFindings = new Map<string, CorrelatedFinding>();
    
    for (const vuln of vulnerabilities) {
      const correlated = this.correlateFinding(
        vuln,
        vulnerabilities,
        hostToVulnerabilities,
        cveToHosts
      );
      correlatedFindings.set(vuln.id, correlated);
    }

    // Identify multi-scanner findings
    const { multiScannerFindings, singleScannerFindings } = this.categorizeByScanner(
      vulnerabilities,
      correlatedFindings
    );

    // Calculate statistics
    const stats = {
      totalCorrelations: correlatedFindings.size,
      crossScannerVerified: multiScannerFindings.length,
      cveCorrelations: cveToHosts.size,
      hostCorrelations: hostToVulnerabilities.size
    };

    return {
      correlatedFindings,
      hostToVulnerabilities,
      cveToHosts,
      serviceToVulnerabilities,
      techToVulnerabilities,
      multiScannerFindings,
      singleScannerFindings,
      stats
    };
  }

  /**
   * Correlate a single finding
   */
  private correlateFinding(
    vuln: NormalizedVulnerability,
    allVulns: NormalizedVulnerability[],
    hostToVulns: Map<string, string[]>,
    cveToHosts: Map<string, string[]>
  ): CorrelatedFinding {
    // Find scanners that confirmed this finding
    const confirmedBy = this.findConfirmingScanners(vuln, allVulns);
    
    // Find related vulnerabilities
    const relatedVulnerabilities = this.findRelatedVulnerabilities(vuln, allVulns);
    
    // Find affected hosts (for CVE-based correlation)
    const affectedHosts = this.findAffectedHosts(vuln, cveToHosts);
    
    // Get threat intelligence
    const threatIntel = this.getThreatIntelligence(vuln);
    
    // Calculate correlated confidence
    const correlatedConfidence = this.calculateCorrelatedConfidence(
      vuln,
      confirmedBy,
      threatIntel
    );

    return {
      vulnerabilityId: vuln.id,
      confirmedBy,
      relatedVulnerabilities,
      affectedHosts,
      threatIntel,
      correlatedConfidence
    };
  }

  /**
   * Find scanners that confirmed the same finding
   */
  private findConfirmingScanners(
    vuln: NormalizedVulnerability,
    allVulns: NormalizedVulnerability[]
  ): string[] {
    const confirming = new Set<string>();
    confirming.add(vuln.scanner);

    for (const other of allVulns) {
      if (other.id === vuln.id) continue;
      if (other.scanner === vuln.scanner) continue;

      // Check for same CVE
      if (vuln.cve && other.cve) {
        const commonCVEs = vuln.cve.filter(c => other.cve!.includes(c));
        if (commonCVEs.length > 0 && other.host === vuln.host) {
          confirming.add(other.scanner);
          continue;
        }
      }

      // Check for same host + port + similar title
      if (other.host === vuln.host && other.port === vuln.port) {
        const similarity = this.calculateTitleSimilarity(vuln.title, other.title);
        if (similarity > 0.7) {
          confirming.add(other.scanner);
        }
      }
    }

    return [...confirming];
  }

  /**
   * Find related vulnerabilities
   */
  private findRelatedVulnerabilities(
    vuln: NormalizedVulnerability,
    allVulns: NormalizedVulnerability[]
  ): string[] {
    const related: string[] = [];

    for (const other of allVulns) {
      if (other.id === vuln.id) continue;

      // Same host, different vulnerability
      if (other.host === vuln.host && other.title !== vuln.title) {
        // Same service/port
        if (other.port === vuln.port) {
          related.push(other.id);
          continue;
        }

        // Same CWE (same vulnerability class)
        if (vuln.cwe && other.cwe) {
          const commonCWEs = vuln.cwe.filter(c => other.cwe!.includes(c));
          if (commonCWEs.length > 0) {
            related.push(other.id);
            continue;
          }
        }
      }

      // Same CVE on different host
      if (vuln.cve && other.cve && other.host !== vuln.host) {
        const commonCVEs = vuln.cve.filter(c => other.cve!.includes(c));
        if (commonCVEs.length > 0) {
          related.push(other.id);
        }
      }
    }

    return related.slice(0, 20); // Limit to 20 related
  }

  /**
   * Find hosts affected by same CVE
   */
  private findAffectedHosts(
    vuln: NormalizedVulnerability,
    cveToHosts: Map<string, string[]>
  ): string[] {
    const hosts = new Set<string>();
    hosts.add(vuln.host);

    if (vuln.cve) {
      for (const cve of vuln.cve) {
        const cveHosts = cveToHosts.get(cve) || [];
        for (const host of cveHosts) {
          hosts.add(host);
        }
      }
    }

    return [...hosts];
  }

  /**
   * Get threat intelligence for vulnerability
   */
  private getThreatIntelligence(vuln: NormalizedVulnerability): ThreatIntelligence | undefined {
    if (!vuln.cve || vuln.cve.length === 0) return undefined;

    const primaryCVE = vuln.cve[0];
    
    // Check cache
    if (this.threatIntelCache.has(primaryCVE)) {
      return this.threatIntelCache.get(primaryCVE);
    }

    // Create basic threat intel (would be enriched from external sources)
    const threatIntel: ThreatIntelligence = {
      cve: primaryCVE,
      nvdScore: vuln.severity.score,
      nvdDescription: vuln.description,
      exploitAvailable: this.isExploitAvailable(primaryCVE),
      inTheWild: this.isExploitedInWild(primaryCVE),
      ransomwareAssociated: this.isRansomwareAssociated(primaryCVE),
      aptAssociated: false,
      references: vuln.references || []
    };

    this.threatIntelCache.set(primaryCVE, threatIntel);
    return threatIntel;
  }

  /**
   * Calculate correlated confidence
   */
  private calculateCorrelatedConfidence(
    vuln: NormalizedVulnerability,
    confirmedBy: string[],
    threatIntel?: ThreatIntelligence
  ): number {
    let confidence = vuln.confidence;

    // Boost for multi-scanner confirmation
    if (confirmedBy.length > 1) {
      confidence += (confirmedBy.length - 1) * 10;
    }

    // Boost for known exploit
    if (threatIntel?.exploitAvailable) {
      confidence += 5;
    }

    // Boost for in-the-wild exploitation
    if (threatIntel?.inTheWild) {
      confidence += 10;
    }

    return Math.min(100, confidence);
  }

  /**
   * Build host to vulnerabilities map
   */
  private buildHostToVulnMap(vulns: NormalizedVulnerability[]): Map<string, string[]> {
    const map = new Map<string, string[]>();
    
    for (const vuln of vulns) {
      if (!map.has(vuln.host)) {
        map.set(vuln.host, []);
      }
      map.get(vuln.host)!.push(vuln.id);
    }

    return map;
  }

  /**
   * Build CVE to hosts map
   */
  private buildCVEToHostsMap(vulns: NormalizedVulnerability[]): Map<string, string[]> {
    const map = new Map<string, string[]>();
    
    for (const vuln of vulns) {
      if (!vuln.cve) continue;
      
      for (const cve of vuln.cve) {
        if (!map.has(cve)) {
          map.set(cve, []);
        }
        if (!map.get(cve)!.includes(vuln.host)) {
          map.get(cve)!.push(vuln.host);
        }
      }
    }

    return map;
  }

  /**
   * Build service to vulnerabilities map
   */
  private buildServiceToVulnMap(
    vulns: NormalizedVulnerability[],
    services: DiscoveredService[]
  ): Map<string, string[]> {
    const map = new Map<string, string[]>();
    
    for (const vuln of vulns) {
      const key = `${vuln.host}:${vuln.port}`;
      if (!map.has(key)) {
        map.set(key, []);
      }
      map.get(key)!.push(vuln.id);
    }

    return map;
  }

  /**
   * Build technology to vulnerabilities map
   */
  private buildTechToVulnMap(
    vulns: NormalizedVulnerability[],
    technologies: Technology[]
  ): Map<string, string[]> {
    const map = new Map<string, string[]>();
    
    // This would match vulnerabilities to detected technologies
    // For now, return empty map
    
    return map;
  }

  /**
   * Categorize findings by scanner count
   */
  private categorizeByScanner(
    vulns: NormalizedVulnerability[],
    correlations: Map<string, CorrelatedFinding>
  ): {
    multiScannerFindings: NormalizedVulnerability[];
    singleScannerFindings: NormalizedVulnerability[];
  } {
    const multi: NormalizedVulnerability[] = [];
    const single: NormalizedVulnerability[] = [];

    for (const vuln of vulns) {
      const correlation = correlations.get(vuln.id);
      if (correlation && correlation.confirmedBy.length > 1) {
        multi.push(vuln);
      } else {
        single.push(vuln);
      }
    }

    return { multiScannerFindings: multi, singleScannerFindings: single };
  }

  /**
   * Calculate title similarity
   */
  private calculateTitleSimilarity(a: string, b: string): number {
    const wordsA = new Set(a.toLowerCase().split(/\s+/));
    const wordsB = new Set(b.toLowerCase().split(/\s+/));
    
    const intersection = [...wordsA].filter(w => wordsB.has(w)).length;
    const union = new Set([...wordsA, ...wordsB]).size;
    
    return intersection / union;
  }

  /**
   * Check if exploit is available (would query ExploitDB, etc.)
   */
  private isExploitAvailable(cve: string): boolean {
    // Known exploited CVEs (sample)
    const exploitedCVEs = new Set([
      'CVE-2021-44228', 'CVE-2021-26855', 'CVE-2021-34527',
      'CVE-2020-1472', 'CVE-2019-19781', 'CVE-2017-0144'
    ]);
    return exploitedCVEs.has(cve);
  }

  /**
   * Check if exploited in the wild
   */
  private isExploitedInWild(cve: string): boolean {
    // CISA KEV catalog (sample)
    const kevCVEs = new Set([
      'CVE-2021-44228', 'CVE-2021-26855', 'CVE-2021-34527',
      'CVE-2020-1472', 'CVE-2019-19781'
    ]);
    return kevCVEs.has(cve);
  }

  /**
   * Check if associated with ransomware
   */
  private isRansomwareAssociated(cve: string): boolean {
    const ransomwareCVEs = new Set([
      'CVE-2021-34527', 'CVE-2020-1472', 'CVE-2019-19781'
    ]);
    return ransomwareCVEs.has(cve);
  }

  /**
   * Enrich with external threat intelligence
   */
  async enrichWithThreatIntel(cve: string): Promise<ThreatIntelligence | null> {
    // This would call external APIs (NVD, ExploitDB, etc.)
    // For now, return cached or basic data
    return this.threatIntelCache.get(cve) || null;
  }
}

/**
 * Quick correlation function
 */
export function correlateFindings(
  vulnerabilities: NormalizedVulnerability[],
  hosts: DiscoveredHost[] = [],
  services: DiscoveredService[] = []
): CorrelationResult {
  const engine = new CorrelationEngine();
  return engine.correlate(vulnerabilities, hosts, services);
}
