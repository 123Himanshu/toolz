/**
 * HTTPx Parser - Parse HTTPx web probe output
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class HttpxParser extends BaseParser {
  constructor() {
    super('httpx', 'recon');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];
    if (!rawOutput) return vulnerabilities;

    const results = this.extractResults(rawOutput);

    for (const result of results) {
      // Check for security issues
      if (this.hasSecurityIssue(result)) {
        const issues = this.extractSecurityIssues(result, scanId);
        vulnerabilities.push(...issues);
      }
    }

    return vulnerabilities;
  }


  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const results = this.extractResults(rawOutput);
    const hostMap = new Map<string, DiscoveredHost>();

    for (const result of results) {
      const host = result.host || this.extractHostFromUrl(result.url || result.input);
      if (!host) continue;

      if (!hostMap.has(host)) {
        hostMap.set(host, {
          id: this.generateId(),
          ip: result.a?.join(', ') || host,
          hostname: host,
          state: 'up',
          discoveredBy: ['httpx'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          openPorts: [],
          services: [],
          vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
          riskScore: 0
        });
      }

      const hostData = hostMap.get(host)!;
      if (result.port) hostData.openPorts.push(result.port);
      if (result.webserver) hostData.services.push(result.webserver);
      if (result.tech) hostData.services.push(...result.tech);
    }

    return Array.from(hostMap.values());
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    const results = this.extractResults(rawOutput);

    for (const result of results) {
      const host = result.host || this.extractHostFromUrl(result.url || result.input);
      if (!host) continue;

      services.push({
        id: this.generateId(),
        hostId: '',
        host,
        port: result.port || (result.url?.startsWith('https') ? 443 : 80),
        protocol: 'tcp',
        service: result.scheme || 'http',
        version: result.webserver,
        product: result.webserver,
        state: 'open',
        discoveredBy: ['httpx'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        vulnerabilityCount: 0,
        riskScore: 0,
        banner: result.title
      });
    }

    return services;
  }


  private extractResults(rawOutput: any): any[] {
    if (Array.isArray(rawOutput)) return rawOutput;
    if (rawOutput.results) return rawOutput.results;
    if (rawOutput.data) return rawOutput.data;
    return [];
  }

  private extractHostFromUrl(url: string): string {
    if (!url) return '';
    try {
      if (url.startsWith('http')) {
        return new URL(url).hostname;
      }
      return url.split('/')[0].split(':')[0];
    } catch {
      return url;
    }
  }

  private hasSecurityIssue(result: any): boolean {
    // Check for missing security headers, outdated servers, etc.
    if (result.status_code === 401 || result.status_code === 403) return false;
    if (result.webserver?.toLowerCase().includes('apache/2.2')) return true;
    if (result.webserver?.toLowerCase().includes('nginx/1.1')) return true;
    if (!result.tls && result.port === 443) return true;
    return false;
  }

  private extractSecurityIssues(result: any, scanId: string): NormalizedVulnerability[] {
    const vulns: NormalizedVulnerability[] = [];
    const host = result.host || this.extractHostFromUrl(result.url || result.input);

    // Outdated web server
    if (result.webserver?.toLowerCase().includes('apache/2.2') ||
        result.webserver?.toLowerCase().includes('nginx/1.1')) {
      vulns.push({
        ...this.createBaseVulnerability(scanId, host, 'Outdated Web Server'),
        port: result.port || 80,
        protocol: 'http',
        service: 'http',
        url: result.url,
        description: `Outdated web server detected: ${result.webserver}`,
        severity: { score: 5.0, label: 'medium' },
        remediation: 'Update the web server to the latest stable version',
        confidence: 85,
        fingerprint: this.generateFingerprint(host, result.port, 'Outdated Web Server')
      } as NormalizedVulnerability);
    }

    return vulns;
  }
}
