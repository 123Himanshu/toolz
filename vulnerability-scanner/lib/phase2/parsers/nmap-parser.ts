/**
 * Nmap Parser - Normalize Nmap scan results
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class NmapParser extends BaseParser {
  constructor() {
    super('nmap', 'network');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];
    
    if (!rawOutput?.data?.hosts) return vulnerabilities;

    const hosts = rawOutput.data.hosts;
    
    for (const [ip, hostData] of Object.entries(hosts as Record<string, any>)) {
      const hostname = hostData.hostname || ip;
      
      // Nmap primarily discovers services, not vulnerabilities
      // But we can flag potentially risky services
      if (hostData.ports) {
        for (const port of hostData.ports) {
          const riskInfo = this.assessServiceRisk(port);
          
          if (riskInfo.isRisky) {
            const vuln: NormalizedVulnerability = {
              ...this.createBaseVulnerability(scanId, ip, riskInfo.title),
              port: this.parsePort(port.port),
              protocol: port.protocol || 'tcp',
              service: port.service,
              description: riskInfo.description,
              severity: this.normalizeSeverity(riskInfo.severity),
              remediation: riskInfo.remediation,
              confidence: 60, // Lower confidence for service-based findings
              fingerprint: this.generateFingerprint(ip, this.parsePort(port.port), riskInfo.title),
              evidence: `Service: ${port.service}, Version: ${port.version || 'unknown'}`
            } as NormalizedVulnerability;
            
            vulnerabilities.push(vuln);
          }
        }
      }
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    
    if (!rawOutput?.data?.hosts) return hosts;

    for (const [ip, hostData] of Object.entries(rawOutput.data.hosts as Record<string, any>)) {
      const ports = hostData.ports || [];
      
      const host: DiscoveredHost = {
        id: this.generateId(),
        ip,
        hostname: hostData.hostname,
        state: 'up',
        discoveredBy: ['nmap'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: ports.filter((p: any) => p.state === 'open').map((p: any) => this.parsePort(p.port)),
        services: ports.map((p: any) => p.service).filter(Boolean),
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      };

      hosts.push(host);
    }

    return hosts;
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    
    if (!rawOutput?.data?.hosts) return services;

    for (const [ip, hostData] of Object.entries(rawOutput.data.hosts as Record<string, any>)) {
      const ports = hostData.ports || [];
      
      for (const port of ports) {
        const service: DiscoveredService = {
          id: this.generateId(),
          hostId: '', // Will be linked later
          host: ip,
          port: this.parsePort(port.port) || 0,
          protocol: port.protocol || 'tcp',
          service: port.service || 'unknown',
          version: port.version,
          state: port.state as 'open' | 'closed' | 'filtered',
          discoveredBy: ['nmap'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          vulnerabilityCount: 0,
          riskScore: 0
        };

        services.push(service);
      }
    }

    return services;
  }

  /**
   * Assess risk of discovered service
   */
  private assessServiceRisk(port: any): {
    isRisky: boolean;
    title: string;
    description: string;
    severity: string;
    remediation: string;
  } {
    const portNum = this.parsePort(port.port);
    const service = port.service?.toLowerCase() || '';
    
    // High-risk services
    const highRiskServices: Record<string, { title: string; desc: string; fix: string }> = {
      'telnet': {
        title: 'Telnet Service Exposed',
        desc: 'Telnet transmits data in cleartext, including credentials',
        fix: 'Replace Telnet with SSH for secure remote access'
      },
      'ftp': {
        title: 'FTP Service Exposed',
        desc: 'FTP transmits credentials in cleartext',
        fix: 'Use SFTP or FTPS instead of plain FTP'
      },
      'rsh': {
        title: 'Remote Shell (RSH) Exposed',
        desc: 'RSH is an insecure remote access protocol',
        fix: 'Disable RSH and use SSH instead'
      },
      'rlogin': {
        title: 'Remote Login (rlogin) Exposed',
        desc: 'rlogin is an insecure remote access protocol',
        fix: 'Disable rlogin and use SSH instead'
      }
    };

    // Medium-risk services
    const mediumRiskServices: Record<string, { title: string; desc: string; fix: string }> = {
      'mysql': {
        title: 'MySQL Database Exposed',
        desc: 'MySQL database is accessible from the network',
        fix: 'Restrict MySQL access to localhost or trusted IPs only'
      },
      'postgresql': {
        title: 'PostgreSQL Database Exposed',
        desc: 'PostgreSQL database is accessible from the network',
        fix: 'Restrict PostgreSQL access to localhost or trusted IPs only'
      },
      'mongodb': {
        title: 'MongoDB Database Exposed',
        desc: 'MongoDB database is accessible from the network',
        fix: 'Enable authentication and restrict network access'
      },
      'redis': {
        title: 'Redis Service Exposed',
        desc: 'Redis is accessible from the network, often without authentication',
        fix: 'Enable Redis authentication and bind to localhost'
      },
      'smb': {
        title: 'SMB/CIFS Service Exposed',
        desc: 'SMB file sharing is accessible from the network',
        fix: 'Restrict SMB access and ensure SMBv1 is disabled'
      }
    };

    // Check high-risk
    for (const [svc, info] of Object.entries(highRiskServices)) {
      if (service.includes(svc)) {
        return {
          isRisky: true,
          title: info.title,
          description: info.desc,
          severity: 'high',
          remediation: info.fix
        };
      }
    }

    // Check medium-risk
    for (const [svc, info] of Object.entries(mediumRiskServices)) {
      if (service.includes(svc)) {
        return {
          isRisky: true,
          title: info.title,
          description: info.desc,
          severity: 'medium',
          remediation: info.fix
        };
      }
    }

    // Check risky ports
    const riskyPorts: Record<number, { title: string; desc: string; sev: string; fix: string }> = {
      23: { title: 'Telnet Port Open', desc: 'Port 23 (Telnet) is open', sev: 'high', fix: 'Close port 23 and use SSH' },
      21: { title: 'FTP Port Open', desc: 'Port 21 (FTP) is open', sev: 'medium', fix: 'Use SFTP instead' },
      3389: { title: 'RDP Port Exposed', desc: 'Remote Desktop Protocol is accessible', sev: 'medium', fix: 'Use VPN for RDP access' },
      5900: { title: 'VNC Port Exposed', desc: 'VNC remote desktop is accessible', sev: 'medium', fix: 'Restrict VNC access via firewall' }
    };

    if (portNum && riskyPorts[portNum]) {
      const info = riskyPorts[portNum];
      return {
        isRisky: true,
        title: info.title,
        description: info.desc,
        severity: info.sev,
        remediation: info.fix
      };
    }

    return { isRisky: false, title: '', description: '', severity: 'info', remediation: '' };
  }
}
