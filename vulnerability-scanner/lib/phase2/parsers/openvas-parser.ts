/**
 * OpenVAS Parser - Normalize OpenVAS/GVM scan results
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class OpenVASParser extends BaseParser {
  constructor() {
    super('openvas', 'system');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];
    
    // Handle "not_configured" status
    if (rawOutput?.status === 'not_configured') {
      return vulnerabilities;
    }

    // Handle running scan (no results yet)
    if (rawOutput?.status === 'running') {
      return vulnerabilities;
    }

    // Parse vulnerabilities from report
    const findings = this.extractFindings(rawOutput);
    
    for (const finding of findings) {
      const vuln: NormalizedVulnerability = {
        ...this.createBaseVulnerability(
          scanId,
          finding.host || rawOutput.target || 'unknown',
          finding.name || finding.nvt?.name || 'Unknown Vulnerability'
        ),
        port: this.parsePort(finding.port),
        protocol: this.extractProtocol(finding.port),
        service: finding.service,
        description: finding.description || finding.nvt?.summary || '',
        severity: this.normalizeSeverity(finding.severity || finding.threat),
        cve: this.extractCVEs(JSON.stringify(finding)),
        cwe: this.extractCWEs(JSON.stringify(finding)),
        scannerId: finding.nvt?.oid || finding.oid,
        evidence: finding.result || finding.description,
        remediation: finding.solution || finding.nvt?.solution,
        references: this.extractReferences(finding),
        confidence: 85, // OpenVAS has high confidence
        fingerprint: this.generateFingerprint(
          finding.host || rawOutput.target || '',
          this.parsePort(finding.port),
          finding.name || finding.nvt?.name || '',
          this.extractCVEs(JSON.stringify(finding))
        )
      } as NormalizedVulnerability;

      vulnerabilities.push(vuln);
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    
    // Handle "not_configured" or "running" status
    if (rawOutput?.status === 'not_configured' || rawOutput?.status === 'running') {
      // Still create a host entry for the target
      if (rawOutput?.target) {
        hosts.push({
          id: this.generateId(),
          ip: rawOutput.target,
          state: 'unknown',
          discoveredBy: ['openvas'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          openPorts: [],
          services: [],
          vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
          riskScore: 0
        });
      }
      return hosts;
    }

    const findings = this.extractFindings(rawOutput);
    const hostMap = new Map<string, DiscoveredHost>();

    for (const finding of findings) {
      const ip = finding.host || rawOutput.target;
      if (!ip) continue;

      if (!hostMap.has(ip)) {
        hostMap.set(ip, {
          id: this.generateId(),
          ip,
          hostname: finding.hostname,
          state: 'up',
          discoveredBy: ['openvas'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          openPorts: [],
          services: [],
          vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
          riskScore: 0
        });
      }

      const host = hostMap.get(ip)!;
      
      // Add port
      const port = this.parsePort(finding.port);
      if (port && !host.openPorts.includes(port)) {
        host.openPorts.push(port);
      }

      // Add service
      if (finding.service && !host.services.includes(finding.service)) {
        host.services.push(finding.service);
      }

      // Update vulnerability count
      const severity = this.normalizeSeverity(finding.severity || finding.threat).label;
      host.vulnerabilityCount[severity]++;
    }

    return Array.from(hostMap.values());
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    
    if (rawOutput?.status === 'not_configured' || rawOutput?.status === 'running') {
      return services;
    }

    const findings = this.extractFindings(rawOutput);
    const serviceMap = new Map<string, DiscoveredService>();

    for (const finding of findings) {
      const host = finding.host || rawOutput.target;
      const port = this.parsePort(finding.port);
      if (!host || !port) continue;

      const key = `${host}:${port}`;

      if (!serviceMap.has(key)) {
        serviceMap.set(key, {
          id: this.generateId(),
          hostId: '',
          host,
          port,
          protocol: this.extractProtocol(finding.port) || 'tcp',
          service: finding.service || 'unknown',
          state: 'open',
          discoveredBy: ['openvas'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          vulnerabilityCount: 0,
          riskScore: 0
        });
      }

      serviceMap.get(key)!.vulnerabilityCount++;
    }

    return Array.from(serviceMap.values());
  }

  /**
   * Extract findings from OpenVAS output
   */
  private extractFindings(rawOutput: any): any[] {
    if (!rawOutput) return [];

    // Direct vulnerabilities array
    if (rawOutput.vulnerabilities && Array.isArray(rawOutput.vulnerabilities)) {
      return rawOutput.vulnerabilities;
    }

    // Results array
    if (rawOutput.results && Array.isArray(rawOutput.results)) {
      return rawOutput.results;
    }

    // Report results
    if (rawOutput.report?.results) {
      return Array.isArray(rawOutput.report.results) 
        ? rawOutput.report.results 
        : [rawOutput.report.results];
    }

    return [];
  }

  /**
   * Extract protocol from port string (e.g., "443/tcp")
   */
  private extractProtocol(portStr: string | undefined): string {
    if (!portStr) return 'tcp';
    const parts = portStr.toString().split('/');
    return parts[1] || 'tcp';
  }

  /**
   * Extract references from finding
   */
  private extractReferences(finding: any): string[] {
    const refs: string[] = [];

    if (finding.nvt?.refs) {
      if (Array.isArray(finding.nvt.refs)) {
        refs.push(...finding.nvt.refs);
      } else if (typeof finding.nvt.refs === 'string') {
        refs.push(finding.nvt.refs);
      }
    }

    if (finding.references) {
      if (Array.isArray(finding.references)) {
        refs.push(...finding.references);
      } else if (typeof finding.references === 'string') {
        refs.push(finding.references);
      }
    }

    // Extract URLs from description
    const urlPattern = /https?:\/\/[^\s<>"]+/g;
    const desc = finding.description || finding.nvt?.summary || '';
    const urlMatches = desc.match(urlPattern) || [];
    refs.push(...urlMatches);

    return [...new Set(refs)];
  }
}
