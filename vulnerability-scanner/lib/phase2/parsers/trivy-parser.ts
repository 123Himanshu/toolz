/**
 * Trivy Parser - Parse Trivy container/image vulnerability scanner output
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class TrivyParser extends BaseParser {
  constructor() {
    super('trivy', 'system');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];

    if (!rawOutput) return vulnerabilities;

    // Trivy JSON format has Results array
    const results = rawOutput.Results || [rawOutput];
    const target = rawOutput.ArtifactName || rawOutput.target || 'unknown';

    for (const result of results) {
      const vulns = result.Vulnerabilities || [];
      const targetType = result.Target || result.Type || 'unknown';

      for (const v of vulns) {
        const severity = this.normalizeSeverity(v.Severity);

        const vuln: NormalizedVulnerability = {
          ...this.createBaseVulnerability(
            scanId,
            target,
            v.Title || v.VulnerabilityID || 'Unknown Vulnerability'
          ),
          description: this.buildDescription(v, targetType),
          severity,
          cve: v.VulnerabilityID ? [v.VulnerabilityID] : [],
          cwe: v.CweIDs || [],
          scannerId: v.VulnerabilityID,
          evidence: this.buildEvidence(v),
          remediation: this.buildRemediation(v),
          references: v.References || [],
          confidence: this.calculateConfidence(v),
          fingerprint: this.generateFingerprint(
            target,
            undefined,
            v.VulnerabilityID || v.Title || '',
            v.VulnerabilityID ? [v.VulnerabilityID] : []
          )
        } as NormalizedVulnerability;

        vulnerabilities.push(vuln);
      }
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const target = rawOutput.ArtifactName || rawOutput.target;

    if (target) {
      hosts.push({
        id: this.generateId(),
        ip: target,
        hostname: target,
        state: 'up',
        discoveredBy: ['trivy'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: [],
        services: [],
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      });
    }

    return hosts;
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    return []; // Trivy doesn't discover network services
  }


  private buildDescription(v: any, targetType: string): string {
    let desc = v.Description || '';
    
    if (v.PkgName) {
      desc += `\n\nAffected Package: ${v.PkgName}`;
    }
    if (v.InstalledVersion) {
      desc += `\nInstalled Version: ${v.InstalledVersion}`;
    }
    if (v.FixedVersion) {
      desc += `\nFixed Version: ${v.FixedVersion}`;
    }
    if (targetType) {
      desc += `\nTarget Type: ${targetType}`;
    }

    return desc.trim();
  }

  private buildEvidence(v: any): string {
    const parts: string[] = [];
    
    if (v.PkgName) parts.push(`Package: ${v.PkgName}`);
    if (v.InstalledVersion) parts.push(`Version: ${v.InstalledVersion}`);
    if (v.Layer?.DiffID) parts.push(`Layer: ${v.Layer.DiffID}`);
    if (v.PrimaryURL) parts.push(`URL: ${v.PrimaryURL}`);

    return parts.join('\n');
  }

  private buildRemediation(v: any): string {
    if (v.FixedVersion) {
      return `Update ${v.PkgName || 'the package'} to version ${v.FixedVersion} or later`;
    }
    return 'No fix available yet. Monitor for updates or consider alternative packages.';
  }

  private calculateConfidence(v: any): number {
    let confidence = 90; // Trivy has high confidence

    if (v.VulnerabilityID?.startsWith('CVE-')) confidence = 95;
    if (v.FixedVersion) confidence += 2;
    if (v.CVSS) confidence += 3;

    return Math.min(confidence, 99);
  }
}
