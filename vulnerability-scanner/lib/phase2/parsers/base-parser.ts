/**
 * Base Parser - Abstract class for all tool parsers
 */

import { NormalizedVulnerability, Severity, DiscoveredHost, DiscoveredService } from '../types';
import crypto from 'crypto';

export abstract class BaseParser {
  protected scanner: string;
  protected category: 'network' | 'web' | 'system' | 'recon';

  constructor(scanner: string, category: 'network' | 'web' | 'system' | 'recon') {
    this.scanner = scanner;
    this.category = category;
  }

  /**
   * Parse raw scanner output into normalized vulnerabilities
   */
  abstract parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[];

  /**
   * Parse raw scanner output into discovered hosts
   */
  abstract parseHosts(rawOutput: any): DiscoveredHost[];

  /**
   * Parse raw scanner output into discovered services
   */
  abstract parseServices(rawOutput: any): DiscoveredService[];

  /**
   * Generate unique ID
   */
  protected generateId(): string {
    return crypto.randomUUID();
  }

  /**
   * Generate fingerprint for deduplication
   * Based on: host + port + CVE/title + severity
   */
  protected generateFingerprint(
    host: string,
    port: number | undefined,
    title: string,
    cve?: string[]
  ): string {
    const data = [
      host.toLowerCase(),
      port?.toString() || '',
      title.toLowerCase().replace(/\s+/g, ''),
      ...(cve || []).sort()
    ].join('|');
    
    return crypto.createHash('sha256').update(data).digest('hex').substring(0, 16);
  }

  /**
   * Normalize severity from various formats
   */
  protected normalizeSeverity(input: any): Severity {
    // Handle numeric scores
    if (typeof input === 'number') {
      return this.scoreToSeverity(input);
    }

    // Handle string labels
    if (typeof input === 'string') {
      const lower = input.toLowerCase();
      
      // Try to parse as number
      const num = parseFloat(lower);
      if (!isNaN(num)) {
        return this.scoreToSeverity(num);
      }

      // Map common labels
      const labelMap: Record<string, Severity['label']> = {
        'critical': 'critical',
        'crit': 'critical',
        'high': 'high',
        'medium': 'medium',
        'med': 'medium',
        'moderate': 'medium',
        'low': 'low',
        'info': 'info',
        'informational': 'info',
        'none': 'info',
        'unknown': 'info'
      };

      const label = labelMap[lower] || 'info';
      return {
        score: this.labelToScore(label),
        label
      };
    }

    // Handle object with score/severity
    if (typeof input === 'object' && input !== null) {
      if ('score' in input) {
        return this.scoreToSeverity(input.score);
      }
      if ('severity' in input) {
        return this.normalizeSeverity(input.severity);
      }
      if ('cvss' in input) {
        return this.scoreToSeverity(parseFloat(input.cvss) || 0);
      }
    }

    // Default
    return { score: 0, label: 'info' };
  }

  /**
   * Convert numeric score to severity object
   */
  protected scoreToSeverity(score: number): Severity {
    let label: Severity['label'];
    
    if (score >= 9.0) label = 'critical';
    else if (score >= 7.0) label = 'high';
    else if (score >= 4.0) label = 'medium';
    else if (score >= 0.1) label = 'low';
    else label = 'info';

    return { score, label };
  }

  /**
   * Convert severity label to numeric score
   */
  protected labelToScore(label: Severity['label']): number {
    const scores: Record<Severity['label'], number> = {
      'critical': 9.5,
      'high': 7.5,
      'medium': 5.0,
      'low': 2.5,
      'info': 0
    };
    return scores[label];
  }

  /**
   * Extract CVEs from text
   */
  protected extractCVEs(text: string): string[] {
    if (!text) return [];
    const cvePattern = /CVE-\d{4}-\d{4,}/gi;
    const matches = text.match(cvePattern) || [];
    return [...new Set(matches.map(cve => cve.toUpperCase()))];
  }

  /**
   * Extract CWEs from text
   */
  protected extractCWEs(text: string): string[] {
    if (!text) return [];
    const cwePattern = /CWE-\d+/gi;
    const matches = text.match(cwePattern) || [];
    return [...new Set(matches.map(cwe => cwe.toUpperCase()))];
  }

  /**
   * Clean and truncate text
   */
  protected cleanText(text: string | undefined, maxLength: number = 5000): string {
    if (!text) return '';
    return text.trim().substring(0, maxLength);
  }

  /**
   * Parse port from various formats
   */
  protected parsePort(input: any): number | undefined {
    if (typeof input === 'number') return input;
    if (typeof input === 'string') {
      const num = parseInt(input.split('/')[0], 10);
      return isNaN(num) ? undefined : num;
    }
    return undefined;
  }

  /**
   * Get current ISO timestamp
   */
  protected now(): string {
    return new Date().toISOString();
  }

  /**
   * Create base vulnerability object
   */
  protected createBaseVulnerability(
    scanId: string,
    host: string,
    title: string
  ): Partial<NormalizedVulnerability> {
    return {
      id: this.generateId(),
      scanId,
      scanner: this.scanner,
      scannerCategory: this.category,
      host,
      title,
      confidence: 80,
      verified: false,
      falsePositive: false,
      discoveredAt: this.now(),
      updatedAt: this.now()
    };
  }
}
