/**
 * Masscan Parser - Parse Masscan port scanner output
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class MasscanParser extends BaseParser {
  constructor() {
    super('masscan', 'network');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    // Masscan is a port scanner, not a vulnerability scanner
    // We create info-level findings for interesting ports
    const vulnerabilities: NormalizedVulnerability[] = [];

    if (!rawOutput) return vulnerabilities;

    const ports = this.extractPorts(rawOutput);
    const criticalPorts = [21, 22, 23, 25, 445, 1433, 3306, 3389, 5432, 5900];

    for (const portData of ports) {
      if (criticalPorts.includes(portData.port)) {
        const severity = this.getPortSeverity(portData.port);

        const vuln: NormalizedVulnerability = {
          ...this.createBaseVulnerability(
            scanId,
            portData.host,
            this.getPortTitle(portData.port)
          ),
          port: portData.port,
          protocol: portData.protocol || 'tcp',
          service: this.getServiceName(portData.port),
          description: this.getPortDescription(portData.port),
          severity,
          remediation: this.getPortRemediation(portData.port),
          confidence: 80,
          fingerprint: this.generateFingerprint(portData.host, portData.port, this.getPortTitle(portData.port))
        } as NormalizedVulnerability;

        vulnerabilities.push(vuln);
      }
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const hostMap = new Map<string, { ports: number[]; services: string[] }>();

    const ports = this.extractPorts(rawOutput);

    for (const portData of ports) {
      if (!hostMap.has(portData.host)) {
        hostMap.set(portData.host, { ports: [], services: [] });
      }
      const data = hostMap.get(portData.host)!;
      data.ports.push(portData.port);
      data.services.push(this.getServiceName(portData.port));
    }

    for (const [ip, data] of hostMap) {
      hosts.push({
        id: this.generateId(),
        ip,
        state: 'up',
        discoveredBy: ['masscan'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: [...new Set(data.ports)],
        services: [...new Set(data.services)],
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      });
    }

    return hosts;
  }


  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    const ports = this.extractPorts(rawOutput);

    for (const portData of ports) {
      services.push({
        id: this.generateId(),
        hostId: '',
        host: portData.host,
        port: portData.port,
        protocol: portData.protocol || 'tcp',
        service: this.getServiceName(portData.port),
        state: 'open',
        discoveredBy: ['masscan'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        vulnerabilityCount: 0,
        riskScore: 0
      });
    }

    return services;
  }

  private extractPorts(rawOutput: any): Array<{ host: string; port: number; protocol?: string }> {
    const ports: Array<{ host: string; port: number; protocol?: string }> = [];

    // Masscan JSON format
    if (Array.isArray(rawOutput)) {
      for (const entry of rawOutput) {
        if (entry.ports && Array.isArray(entry.ports)) {
          for (const p of entry.ports) {
            ports.push({
              host: entry.ip,
              port: p.port,
              protocol: p.proto
            });
          }
        }
      }
    }

    // Alternative format
    if (rawOutput.hosts) {
      for (const [ip, data] of Object.entries(rawOutput.hosts as Record<string, any>)) {
        if (data.ports && Array.isArray(data.ports)) {
          for (const p of data.ports) {
            ports.push({ host: ip, port: typeof p === 'number' ? p : p.port, protocol: p.proto });
          }
        }
      }
    }

    if (rawOutput.open_ports) {
      const host = rawOutput.target || rawOutput.host || 'unknown';
      for (const p of rawOutput.open_ports) {
        ports.push({ host, port: typeof p === 'number' ? p : p.port });
      }
    }

    return ports;
  }


  private getServiceName(port: number): string {
    const services: Record<number, string> = {
      21: 'ftp', 22: 'ssh', 23: 'telnet', 25: 'smtp', 53: 'dns',
      80: 'http', 110: 'pop3', 143: 'imap', 443: 'https', 445: 'smb',
      1433: 'mssql', 1521: 'oracle', 3306: 'mysql', 3389: 'rdp',
      5432: 'postgresql', 5900: 'vnc', 6379: 'redis', 8080: 'http-proxy',
      8443: 'https-alt', 27017: 'mongodb'
    };
    return services[port] || 'unknown';
  }

  private getPortSeverity(port: number): { score: number; label: 'critical' | 'high' | 'medium' | 'low' | 'info' } {
    const critical = [23, 445, 3389, 5900]; // Telnet, SMB, RDP, VNC
    const high = [21, 1433, 3306, 5432, 6379, 27017]; // FTP, databases
    const medium = [22, 25, 110, 143]; // SSH, mail

    if (critical.includes(port)) return { score: 8.0, label: 'high' };
    if (high.includes(port)) return { score: 6.0, label: 'medium' };
    if (medium.includes(port)) return { score: 4.0, label: 'medium' };
    return { score: 2.0, label: 'low' };
  }

  private getPortTitle(port: number): string {
    const titles: Record<number, string> = {
      21: 'FTP Service Exposed',
      22: 'SSH Service Exposed',
      23: 'Telnet Service Exposed (Insecure)',
      25: 'SMTP Service Exposed',
      445: 'SMB Service Exposed',
      1433: 'MSSQL Database Exposed',
      3306: 'MySQL Database Exposed',
      3389: 'RDP Service Exposed',
      5432: 'PostgreSQL Database Exposed',
      5900: 'VNC Service Exposed',
      6379: 'Redis Service Exposed',
      27017: 'MongoDB Service Exposed'
    };
    return titles[port] || `Port ${port} Open`;
  }

  private getPortDescription(port: number): string {
    const descriptions: Record<number, string> = {
      21: 'FTP service is accessible. FTP transmits credentials in cleartext.',
      23: 'Telnet service is accessible. Telnet is insecure and should be replaced with SSH.',
      445: 'SMB service is accessible. SMB has been target of many attacks including WannaCry.',
      3389: 'Remote Desktop Protocol is accessible. RDP should be protected by VPN or firewall.',
      5900: 'VNC service is accessible. VNC should be protected and use strong authentication.',
      6379: 'Redis service is accessible. Redis should not be exposed to the internet.',
      27017: 'MongoDB service is accessible. MongoDB should require authentication.'
    };
    return descriptions[port] || `Port ${port} is open and accessible from the network.`;
  }

  private getPortRemediation(port: number): string {
    const remediations: Record<number, string> = {
      21: 'Use SFTP instead of FTP. If FTP is required, use FTPS.',
      23: 'Disable Telnet and use SSH instead.',
      445: 'Restrict SMB access to trusted networks. Apply latest security patches.',
      3389: 'Use VPN or restrict RDP access. Enable Network Level Authentication.',
      5900: 'Use VPN for VNC access. Enable strong authentication.',
      6379: 'Bind Redis to localhost. Enable authentication. Use firewall rules.',
      27017: 'Enable MongoDB authentication. Bind to localhost or use firewall.'
    };
    return remediations[port] || 'Review if this service needs to be exposed. Apply firewall rules as needed.';
  }
}
