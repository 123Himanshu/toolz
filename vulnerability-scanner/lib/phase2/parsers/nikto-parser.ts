/**
 * Nikto Parser - Parse Nikto web vulnerability scanner output
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class NiktoParser extends BaseParser {
  constructor() {
    super('nikto', 'web');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];

    if (!rawOutput) return vulnerabilities;

    // Handle different Nikto output formats
    const findings = this.extractFindings(rawOutput);
    const target = this.extractTarget(rawOutput);

    for (const finding of findings) {
      const severity = this.determineSeverity(finding);
      const title = this.extractTitle(finding);
      const host = this.extractHost(finding, target);

      const vuln: NormalizedVulnerability = {
        ...this.createBaseVulnerability(scanId, host, title),
        port: this.parsePort(finding.port || target.port || 80),
        protocol: 'http',
        service: 'http',
        url: finding.url || finding.uri || `http://${host}${finding.path || '/'}`,
        description: finding.description || finding.msg || finding.message || '',
        severity,
        cve: this.extractCVEs(JSON.stringify(finding)),
        cwe: this.extractCWEs(JSON.stringify(finding)),
        scannerId: finding.id || finding.nikto_id || finding.OSVDB,
        evidence: finding.evidence || finding.output || '',
        matchedAt: finding.url || finding.uri || finding.path,
        remediation: this.generateRemediation(finding),
        references: this.extractReferences(finding),
        confidence: this.calculateConfidence(finding),
        fingerprint: this.generateFingerprint(
          host,
          this.parsePort(finding.port || target.port || 80),
          title,
          this.extractCVEs(JSON.stringify(finding))
        )
      } as NormalizedVulnerability;

      vulnerabilities.push(vuln);
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const target = this.extractTarget(rawOutput);

    if (target.host) {
      hosts.push({
        id: this.generateId(),
        ip: target.host,
        hostname: target.hostname,
        state: 'up',
        discoveredBy: ['nikto'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: target.port ? [target.port] : [80],
        services: ['http'],
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      });
    }

    return hosts;
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    const target = this.extractTarget(rawOutput);

    if (target.host) {
      services.push({
        id: this.generateId(),
        hostId: '',
        host: target.host,
        port: target.port || 80,
        protocol: 'tcp',
        service: 'http',
        version: target.server,
        product: target.server,
        state: 'open',
        discoveredBy: ['nikto'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        vulnerabilityCount: 0,
        riskScore: 0
      });
    }

    return services;
  }

  private extractFindings(rawOutput: any): any[] {
    if (Array.isArray(rawOutput)) return rawOutput;
    if (rawOutput.vulnerabilities) return rawOutput.vulnerabilities;
    if (rawOutput.findings) return rawOutput.findings;
    if (rawOutput.items) return rawOutput.items;
    if (rawOutput.results) return rawOutput.results;
    
    // Nikto JSON format
    if (rawOutput.host && Array.isArray(rawOutput.host)) {
      const findings: any[] = [];
      for (const host of rawOutput.host) {
        if (host.item && Array.isArray(host.item)) {
          findings.push(...host.item.map((item: any) => ({
            ...item,
            host: host.ip || host.hostname
          })));
        }
      }
      return findings;
    }

    return [];
  }

  private extractTarget(rawOutput: any): { host: string; hostname?: string; port?: number; server?: string } {
    if (rawOutput.target) {
      return {
        host: rawOutput.target,
        port: rawOutput.port || 80
      };
    }

    if (rawOutput.host && !Array.isArray(rawOutput.host)) {
      return {
        host: rawOutput.host,
        hostname: rawOutput.hostname,
        port: rawOutput.port,
        server: rawOutput.server
      };
    }

    if (rawOutput.host && Array.isArray(rawOutput.host) && rawOutput.host[0]) {
      const h = rawOutput.host[0];
      return {
        host: h.ip || h.hostname || 'unknown',
        hostname: h.hostname,
        port: h.port,
        server: h.banner
      };
    }

    return { host: 'unknown' };
  }

  private extractHost(finding: any, target: { host: string }): string {
    return finding.host || finding.ip || target.host || 'unknown';
  }

  private extractTitle(finding: any): string {
    // Nikto findings often have descriptive messages
    const msg = finding.description || finding.msg || finding.message || '';
    
    // Try to create a concise title
    if (msg.length > 100) {
      // Extract first sentence or truncate
      const firstSentence = msg.split(/[.!?]/)[0];
      return firstSentence.length > 100 ? firstSentence.substring(0, 97) + '...' : firstSentence;
    }
    
    return msg || finding.id || 'Nikto Finding';
  }

  private determineSeverity(finding: any): { score: number; label: 'critical' | 'high' | 'medium' | 'low' | 'info' } {
    // Check explicit severity
    if (finding.severity) {
      return this.normalizeSeverity(finding.severity);
    }

    // Nikto categorization based on OSVDB/finding type
    const msg = (finding.description || finding.msg || '').toLowerCase();
    const id = (finding.id || finding.nikto_id || '').toString();

    // Critical indicators
    if (msg.includes('remote code execution') || msg.includes('rce') ||
        msg.includes('sql injection') || msg.includes('command injection')) {
      return { score: 9.5, label: 'critical' };
    }

    // High indicators
    if (msg.includes('xss') || msg.includes('cross-site scripting') ||
        msg.includes('file inclusion') || msg.includes('directory traversal') ||
        msg.includes('authentication bypass') || msg.includes('default credentials')) {
      return { score: 7.5, label: 'high' };
    }

    // Medium indicators
    if (msg.includes('information disclosure') || msg.includes('sensitive') ||
        msg.includes('backup file') || msg.includes('configuration file') ||
        msg.includes('phpinfo') || msg.includes('server-status')) {
      return { score: 5.0, label: 'medium' };
    }

    // Low indicators
    if (msg.includes('outdated') || msg.includes('version') ||
        msg.includes('header') || msg.includes('cookie')) {
      return { score: 3.0, label: 'low' };
    }

    // Default to info
    return { score: 1.0, label: 'info' };
  }

  private generateRemediation(finding: any): string {
    const msg = (finding.description || finding.msg || '').toLowerCase();

    if (msg.includes('directory listing')) {
      return 'Disable directory listing in web server configuration';
    }
    if (msg.includes('default') && msg.includes('credential')) {
      return 'Change default credentials immediately';
    }
    if (msg.includes('outdated')) {
      return 'Update the software to the latest version';
    }
    if (msg.includes('header')) {
      return 'Configure appropriate security headers';
    }
    if (msg.includes('backup')) {
      return 'Remove backup files from web-accessible directories';
    }

    return finding.solution || finding.remediation || 'Review and address the finding based on security best practices';
  }

  private extractReferences(finding: any): string[] {
    const refs: string[] = [];

    if (finding.references) {
      if (Array.isArray(finding.references)) {
        refs.push(...finding.references);
      } else {
        refs.push(finding.references);
      }
    }

    if (finding.OSVDB) {
      refs.push(`https://osvdb.org/${finding.OSVDB}`);
    }

    // Extract CVE references
    const cves = this.extractCVEs(JSON.stringify(finding));
    for (const cve of cves) {
      refs.push(`https://nvd.nist.gov/vuln/detail/${cve}`);
    }

    return refs;
  }

  private calculateConfidence(finding: any): number {
    let confidence = 70; // Base confidence for Nikto

    // Boost for specific indicators
    if (finding.OSVDB) confidence += 10;
    if (finding.evidence) confidence += 10;
    if (this.extractCVEs(JSON.stringify(finding)).length > 0) confidence += 10;

    return Math.min(confidence, 95);
  }
}
