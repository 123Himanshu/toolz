/**
 * Nuclei Parser - Normalize Nuclei scan results
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class NucleiParser extends BaseParser {
  constructor() {
    super('nuclei', 'web');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];
    
    // Handle different Nuclei output formats
    const findings = this.extractFindings(rawOutput);
    
    for (const finding of findings) {
      const host = this.extractHost(finding);
      const port = this.extractPort(finding);
      
      const vuln: NormalizedVulnerability = {
        ...this.createBaseVulnerability(scanId, host, finding.info?.name || finding.templateID || 'Unknown'),
        port,
        protocol: finding.type || 'http',
        service: 'http',
        url: finding.matched || finding.host,
        description: finding.info?.description || finding.info?.name || '',
        severity: this.normalizeSeverity(finding.info?.severity || finding.severity || 'info'),
        cve: this.extractCVEs(JSON.stringify(finding)),
        cwe: this.extractCWEs(JSON.stringify(finding)),
        scannerId: finding.templateID || finding['template-id'],
        evidence: finding.extracted || finding.matcher_name,
        matchedAt: finding.matched,
        request: finding.request,
        response: this.cleanText(finding.response, 2000),
        remediation: finding.info?.remediation,
        references: finding.info?.reference || [],
        confidence: this.calculateConfidence(finding),
        fingerprint: this.generateFingerprint(
          host,
          port,
          finding.templateID || finding.info?.name || '',
          this.extractCVEs(JSON.stringify(finding))
        )
      } as NormalizedVulnerability;

      vulnerabilities.push(vuln);
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const findings = this.extractFindings(rawOutput);
    const hostMap = new Map<string, DiscoveredHost>();

    for (const finding of findings) {
      const ip = this.extractHost(finding);
      
      if (!hostMap.has(ip)) {
        hostMap.set(ip, {
          id: this.generateId(),
          ip,
          hostname: this.extractHostname(finding),
          state: 'up',
          discoveredBy: ['nuclei'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          openPorts: [],
          services: ['http'],
          vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
          riskScore: 0
        });
      }

      // Update vulnerability count
      const host = hostMap.get(ip)!;
      const severity = this.normalizeSeverity(finding.info?.severity || 'info').label;
      host.vulnerabilityCount[severity]++;
    }

    return Array.from(hostMap.values());
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    const findings = this.extractFindings(rawOutput);
    const serviceMap = new Map<string, DiscoveredService>();

    for (const finding of findings) {
      const host = this.extractHost(finding);
      const port = this.extractPort(finding) || 80;
      const key = `${host}:${port}`;

      if (!serviceMap.has(key)) {
        serviceMap.set(key, {
          id: this.generateId(),
          hostId: '',
          host,
          port,
          protocol: 'tcp',
          service: 'http',
          state: 'open',
          discoveredBy: ['nuclei'],
          firstSeen: this.now(),
          lastSeen: this.now(),
          vulnerabilityCount: 0,
          riskScore: 0
        });
      }

      serviceMap.get(key)!.vulnerabilityCount++;
    }

    return Array.from(serviceMap.values());
  }

  /**
   * Extract findings from various Nuclei output formats
   */
  private extractFindings(rawOutput: any): any[] {
    if (!rawOutput) return [];

    // Direct array of findings
    if (Array.isArray(rawOutput)) {
      return rawOutput;
    }

    // Vulnerabilities array
    if (rawOutput.vulnerabilities && Array.isArray(rawOutput.vulnerabilities)) {
      return rawOutput.vulnerabilities;
    }

    // Results array
    if (rawOutput.results && Array.isArray(rawOutput.results)) {
      return rawOutput.results;
    }

    // JSONL format (newline-delimited JSON in stdout)
    if (rawOutput.stdout && typeof rawOutput.stdout === 'string') {
      try {
        return rawOutput.stdout
          .split('\n')
          .filter((line: string) => line.trim())
          .map((line: string) => JSON.parse(line));
      } catch {
        return [];
      }
    }

    // Single finding
    if (rawOutput.templateID || rawOutput['template-id']) {
      return [rawOutput];
    }

    return [];
  }

  /**
   * Extract host/IP from finding
   */
  private extractHost(finding: any): string {
    if (finding.ip) return finding.ip;
    if (finding.host) {
      try {
        const url = new URL(finding.host);
        return url.hostname;
      } catch {
        return finding.host;
      }
    }
    if (finding.matched) {
      try {
        const url = new URL(finding.matched);
        return url.hostname;
      } catch {
        return finding.matched;
      }
    }
    return 'unknown';
  }

  /**
   * Extract hostname from finding
   */
  private extractHostname(finding: any): string | undefined {
    if (finding.host) {
      try {
        const url = new URL(finding.host);
        return url.hostname;
      } catch {
        return finding.host;
      }
    }
    return undefined;
  }

  /**
   * Extract port from finding
   */
  private extractPort(finding: any): number | undefined {
    if (finding.port) return finding.port;
    
    const url = finding.host || finding.matched;
    if (url) {
      try {
        const parsed = new URL(url);
        if (parsed.port) return parseInt(parsed.port, 10);
        if (parsed.protocol === 'https:') return 443;
        if (parsed.protocol === 'http:') return 80;
      } catch {
        // Not a valid URL
      }
    }
    
    return undefined;
  }

  /**
   * Calculate confidence based on finding details
   */
  private calculateConfidence(finding: any): number {
    let confidence = 70; // Base confidence

    // Increase for CVE
    if (finding.info?.classification?.cve) {
      confidence += 15;
    }

    // Increase for extracted data
    if (finding.extracted) {
      confidence += 10;
    }

    // Increase for matcher evidence
    if (finding.matcher_name) {
      confidence += 5;
    }

    // Decrease for info severity
    if (finding.info?.severity === 'info') {
      confidence -= 20;
    }

    return Math.min(100, Math.max(0, confidence));
  }
}
