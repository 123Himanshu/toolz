/**
 * Parser Index - Export all parsers and factory function
 */

import { BaseParser } from './base-parser';
import { NmapParser } from './nmap-parser';
import { NucleiParser } from './nuclei-parser';
import { OpenVASParser } from './openvas-parser';
import { NiktoParser } from './nikto-parser';
import { WapitiParser } from './wapiti-parser';
import { TrivyParser } from './trivy-parser';
import { MasscanParser } from './masscan-parser';
import { HttpxParser } from './httpx-parser';
import { SubfinderParser } from './subfinder-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

// Parser registry - all 12+ tools supported
const parsers: Record<string, () => BaseParser> = {
  // Network scanners
  nmap: () => new NmapParser(),
  masscan: () => new MasscanParser(),
  rustscan: () => new MasscanParser(), // Similar format to masscan
  naabu: () => new MasscanParser(),    // Similar format
  zmap: () => new MasscanParser(),
  
  // Web scanners
  nuclei: () => new NucleiParser(),
  nikto: () => new NiktoParser(),
  wapiti: () => new WapitiParser(),
  zap: () => new WapitiParser(),       // Similar format
  jaeles: () => new NucleiParser(),    // Similar to nuclei
  
  // System/Container scanners
  openvas: () => new OpenVASParser(),
  nessus: () => new OpenVASParser(),
  trivy: () => new TrivyParser(),
  grype: () => new TrivyParser(),      // Similar format
  
  // Recon tools
  subfinder: () => new SubfinderParser(),
  httpx: () => new HttpxParser(),
  amass: () => new SubfinderParser(),  // Similar format
};


/**
 * Get parser for a specific tool
 */
export function getParser(tool: string): BaseParser {
  const factory = parsers[tool.toLowerCase()];
  if (factory) {
    return factory();
  }
  // Default to generic parser
  return new GenericParser(tool);
}

/**
 * Parse raw output from any tool
 */
export function parseToolOutput(
  tool: string,
  rawOutput: any,
  scanId: string
): {
  vulnerabilities: NormalizedVulnerability[];
  hosts: DiscoveredHost[];
  services: DiscoveredService[];
} {
  const parser = getParser(tool);
  
  return {
    vulnerabilities: parser.parseVulnerabilities(rawOutput, scanId),
    hosts: parser.parseHosts(rawOutput),
    services: parser.parseServices(rawOutput)
  };
}

/**
 * Get list of supported parsers
 */
export function getSupportedParsers(): string[] {
  return Object.keys(parsers);
}

// Generic fallback parser
class GenericParser extends BaseParser {
  constructor(scanner: string) {
    super(scanner, 'network');
  }

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];
    const findings = this.extractFindings(rawOutput);

    for (const finding of findings) {
      const vuln: NormalizedVulnerability = {
        ...this.createBaseVulnerability(
          scanId,
          finding.host || finding.ip || finding.target || 'unknown',
          finding.title || finding.name || finding.vulnerability || 'Unknown Finding'
        ),
        port: this.parsePort(finding.port),
        description: finding.description || finding.message || '',
        severity: this.normalizeSeverity(finding.severity || finding.risk || 'info'),
        cve: this.extractCVEs(JSON.stringify(finding)),
        confidence: 60,
        fingerprint: this.generateFingerprint(
          finding.host || finding.ip || '',
          this.parsePort(finding.port),
          finding.title || finding.name || ''
        )
      } as NormalizedVulnerability;

      vulnerabilities.push(vuln);
    }

    return vulnerabilities;
  }


  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const hostData = this.extractHostData(rawOutput);

    for (const data of hostData) {
      hosts.push({
        id: this.generateId(),
        ip: data.ip,
        hostname: data.hostname,
        state: 'up',
        discoveredBy: [this.scanner],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: data.ports || [],
        services: [],
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      });
    }

    return hosts;
  }

  parseServices(): DiscoveredService[] {
    return [];
  }

  private extractFindings(rawOutput: any): any[] {
    if (!rawOutput) return [];
    if (Array.isArray(rawOutput)) return rawOutput;
    if (rawOutput.vulnerabilities) return rawOutput.vulnerabilities;
    if (rawOutput.results) return rawOutput.results;
    if (rawOutput.findings) return rawOutput.findings;
    return [];
  }

  private extractHostData(rawOutput: any): Array<{ ip: string; hostname?: string; ports?: number[] }> {
    const hosts: Array<{ ip: string; hostname?: string; ports?: number[] }> = [];

    if (rawOutput?.target) {
      hosts.push({ ip: rawOutput.target });
    }

    if (rawOutput?.hosts) {
      if (Array.isArray(rawOutput.hosts)) {
        for (const h of rawOutput.hosts) {
          hosts.push({ ip: h.ip || h.host || h, hostname: h.hostname });
        }
      } else if (typeof rawOutput.hosts === 'object') {
        for (const [ip, data] of Object.entries(rawOutput.hosts as Record<string, any>)) {
          hosts.push({ ip, hostname: data?.hostname });
        }
      }
    }

    return hosts;
  }
}

// Export all parsers
export {
  BaseParser,
  NmapParser,
  NucleiParser,
  OpenVASParser,
  NiktoParser,
  WapitiParser,
  TrivyParser,
  MasscanParser,
  HttpxParser,
  SubfinderParser
};
