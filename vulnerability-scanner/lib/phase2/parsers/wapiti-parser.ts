/**
 * Wapiti Parser - Parse Wapiti web vulnerability scanner output
 */

import { BaseParser } from './base-parser';
import { NormalizedVulnerability, DiscoveredHost, DiscoveredService } from '../types';

export class WapitiParser extends BaseParser {
  constructor() {
    super('wapiti', 'web');
  }

  // Wapiti vulnerability type to severity mapping
  private readonly severityMap: Record<string, { score: number; label: 'critical' | 'high' | 'medium' | 'low' | 'info' }> = {
    'SQL Injection': { score: 9.5, label: 'critical' },
    'Blind SQL Injection': { score: 9.5, label: 'critical' },
    'Command execution': { score: 9.5, label: 'critical' },
    'Path Traversal': { score: 8.0, label: 'high' },
    'Cross Site Scripting': { score: 7.5, label: 'high' },
    'CRLF Injection': { score: 7.0, label: 'high' },
    'File Handling': { score: 7.0, label: 'high' },
    'Htaccess Bypass': { score: 6.5, label: 'medium' },
    'Backup file': { score: 5.5, label: 'medium' },
    'Potentially dangerous file': { score: 5.0, label: 'medium' },
    'Server Side Request Forgery': { score: 8.5, label: 'high' },
    'Open Redirect': { score: 5.0, label: 'medium' },
    'XXE': { score: 8.5, label: 'high' },
    'Internal Server Error': { score: 3.0, label: 'low' },
    'Resource consumption': { score: 4.0, label: 'medium' },
    'Fingerprint web technology': { score: 1.0, label: 'info' },
    'Fingerprint web server': { score: 1.0, label: 'info' },
    'HTTP Secure Headers': { score: 3.0, label: 'low' },
    'Content Security Policy Configuration': { score: 3.0, label: 'low' },
    'Secure Flag cookie': { score: 3.0, label: 'low' },
    'HttpOnly Flag cookie': { score: 3.0, label: 'low' }
  };

  parseVulnerabilities(rawOutput: any, scanId: string): NormalizedVulnerability[] {
    const vulnerabilities: NormalizedVulnerability[] = [];

    if (!rawOutput) return vulnerabilities;

    // Handle Wapiti JSON report format
    const findings = this.extractFindings(rawOutput);
    const target = rawOutput.target || rawOutput.info?.target || 'unknown';

    for (const [vulnType, vulnList] of Object.entries(findings)) {
      if (!Array.isArray(vulnList)) continue;

      for (const finding of vulnList) {
        const severity = this.getSeverity(vulnType, finding);
        const host = this.extractHost(finding, target);

        const vuln: NormalizedVulnerability = {
          ...this.createBaseVulnerability(scanId, host, vulnType),
          port: this.parsePort(finding.port) || 80,
          protocol: 'http',
          service: 'http',
          url: finding.path || finding.url || target,
          description: this.buildDescription(vulnType, finding),
          severity,
          cve: finding.cve ? [finding.cve] : this.extractCVEs(JSON.stringify(finding)),
          cwe: finding.wstg ? [`WSTG-${finding.wstg}`] : this.extractCWEs(JSON.stringify(finding)),
          scannerId: `wapiti-${vulnType.toLowerCase().replace(/\s+/g, '-')}`,
          evidence: finding.info || finding.evidence || '',
          request: finding.http_request || finding.request || '',
          response: finding.curl_command || '',
          matchedAt: finding.path || finding.url,
          remediation: this.getRemediation(vulnType, finding),
          references: this.buildReferences(vulnType, finding),
          confidence: this.calculateConfidence(vulnType, finding),
          fingerprint: this.generateFingerprint(
            host,
            this.parsePort(finding.port) || 80,
            vulnType,
            finding.cve ? [finding.cve] : []
          )
        } as NormalizedVulnerability;

        vulnerabilities.push(vuln);
      }
    }

    return vulnerabilities;
  }

  parseHosts(rawOutput: any): DiscoveredHost[] {
    const hosts: DiscoveredHost[] = [];
    const target = rawOutput.target || rawOutput.info?.target;

    if (target) {
      const host = this.parseHostFromUrl(target);
      hosts.push({
        id: this.generateId(),
        ip: host,
        hostname: host,
        state: 'up',
        discoveredBy: ['wapiti'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        openPorts: [80, 443],
        services: ['http', 'https'],
        vulnerabilityCount: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
        riskScore: 0
      });
    }

    return hosts;
  }

  parseServices(rawOutput: any): DiscoveredService[] {
    const services: DiscoveredService[] = [];
    const target = rawOutput.target || rawOutput.info?.target;

    if (target) {
      const host = this.parseHostFromUrl(target);
      const isHttps = target.startsWith('https');

      services.push({
        id: this.generateId(),
        hostId: '',
        host,
        port: isHttps ? 443 : 80,
        protocol: 'tcp',
        service: isHttps ? 'https' : 'http',
        state: 'open',
        discoveredBy: ['wapiti'],
        firstSeen: this.now(),
        lastSeen: this.now(),
        vulnerabilityCount: 0,
        riskScore: 0
      });
    }

    return services;
  }

  private extractFindings(rawOutput: any): Record<string, any[]> {
    // Wapiti JSON format has vulnerabilities grouped by type
    if (rawOutput.vulnerabilities) {
      return rawOutput.vulnerabilities;
    }

    // Alternative format
    if (rawOutput.classifications) {
      return rawOutput.classifications;
    }

    // Flat list format
    if (Array.isArray(rawOutput)) {
      const grouped: Record<string, any[]> = {};
      for (const item of rawOutput) {
        const type = item.type || item.category || 'Unknown';
        if (!grouped[type]) grouped[type] = [];
        grouped[type].push(item);
      }
      return grouped;
    }

    return {};
  }

  private extractHost(finding: any, target: string): string {
    if (finding.host) return finding.host;
    if (finding.ip) return finding.ip;
    return this.parseHostFromUrl(finding.url || finding.path || target);
  }

  private parseHostFromUrl(url: string): string {
    try {
      if (url.startsWith('http')) {
        const parsed = new URL(url);
        return parsed.hostname;
      }
      return url.split('/')[0].split(':')[0];
    } catch {
      return url;
    }
  }

  private getSeverity(vulnType: string, finding: any): { score: number; label: 'critical' | 'high' | 'medium' | 'low' | 'info' } {
    // Check explicit severity first
    if (finding.severity) {
      return this.normalizeSeverity(finding.severity);
    }

    // Use type mapping
    if (this.severityMap[vulnType]) {
      return this.severityMap[vulnType];
    }

    // Default based on keywords
    const type = vulnType.toLowerCase();
    if (type.includes('injection') || type.includes('execution')) {
      return { score: 9.0, label: 'critical' };
    }
    if (type.includes('xss') || type.includes('traversal')) {
      return { score: 7.5, label: 'high' };
    }
    if (type.includes('disclosure') || type.includes('bypass')) {
      return { score: 5.0, label: 'medium' };
    }

    return { score: 3.0, label: 'low' };
  }

  private buildDescription(vulnType: string, finding: any): string {
    let desc = finding.info || finding.description || '';
    
    if (!desc) {
      desc = `${vulnType} vulnerability detected`;
    }

    if (finding.parameter) {
      desc += `\n\nAffected parameter: ${finding.parameter}`;
    }

    if (finding.method) {
      desc += `\nHTTP Method: ${finding.method}`;
    }

    return desc;
  }

  private getRemediation(vulnType: string, finding: any): string {
    if (finding.solution || finding.remediation) {
      return finding.solution || finding.remediation;
    }

    const remediations: Record<string, string> = {
      'SQL Injection': 'Use parameterized queries or prepared statements. Implement input validation and sanitization.',
      'Cross Site Scripting': 'Encode output data. Implement Content Security Policy. Use HttpOnly and Secure flags for cookies.',
      'Command execution': 'Avoid passing user input to system commands. Use allowlists for permitted values.',
      'Path Traversal': 'Validate and sanitize file paths. Use a whitelist of allowed files.',
      'CRLF Injection': 'Sanitize user input by removing CR and LF characters.',
      'File Handling': 'Validate file uploads. Store files outside web root.',
      'Server Side Request Forgery': 'Validate and sanitize URLs. Use allowlists for permitted domains.',
      'Open Redirect': 'Validate redirect URLs against a whitelist of allowed destinations.',
      'XXE': 'Disable external entity processing in XML parsers.',
      'HTTP Secure Headers': 'Implement security headers: X-Frame-Options, X-Content-Type-Options, X-XSS-Protection, etc.'
    };

    return remediations[vulnType] || 'Review and remediate based on security best practices.';
  }

  private buildReferences(vulnType: string, finding: any): string[] {
    const refs: string[] = [];

    if (finding.references) {
      refs.push(...(Array.isArray(finding.references) ? finding.references : [finding.references]));
    }

    if (finding.wstg) {
      refs.push(`https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/${finding.wstg}`);
    }

    // Add OWASP references based on type
    const owaspRefs: Record<string, string> = {
      'SQL Injection': 'https://owasp.org/www-community/attacks/SQL_Injection',
      'Cross Site Scripting': 'https://owasp.org/www-community/attacks/xss/',
      'Command execution': 'https://owasp.org/www-community/attacks/Command_Injection',
      'Path Traversal': 'https://owasp.org/www-community/attacks/Path_Traversal',
      'CRLF Injection': 'https://owasp.org/www-community/vulnerabilities/CRLF_Injection',
      'Server Side Request Forgery': 'https://owasp.org/www-community/attacks/Server_Side_Request_Forgery',
      'XXE': 'https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing'
    };

    if (owaspRefs[vulnType]) {
      refs.push(owaspRefs[vulnType]);
    }

    return refs;
  }

  private calculateConfidence(vulnType: string, finding: any): number {
    let confidence = 75; // Base confidence for Wapiti

    // High confidence for injection types (usually verified)
    if (vulnType.toLowerCase().includes('injection')) {
      confidence = 90;
    }

    // Boost for evidence
    if (finding.http_request || finding.evidence) {
      confidence += 5;
    }

    // Boost for CVE
    if (finding.cve) {
      confidence += 5;
    }

    return Math.min(confidence, 95);
  }
}
