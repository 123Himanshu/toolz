/**
 * Export Module - Export vulnerabilities in various formats
 * Supports: CSV, JSON, SARIF, HTML
 */

import { NormalizedVulnerability, DiscoveredHost, ScanSession, AttackPath } from './types';

export type ExportFormat = 'csv' | 'json' | 'sarif' | 'html';

export interface ExportOptions {
  format: ExportFormat;
  includeHosts?: boolean;
  includeAttackPaths?: boolean;
  includeSummary?: boolean;
  severityFilter?: string[];
}

export interface ExportData {
  vulnerabilities: NormalizedVulnerability[];
  hosts?: DiscoveredHost[];
  attackPaths?: AttackPath[];
  session?: ScanSession;
}

/**
 * Export scan results to specified format
 */
export function exportResults(data: ExportData, options: ExportOptions): string {
  switch (options.format) {
    case 'csv':
      return exportToCSV(data, options);
    case 'json':
      return exportToJSON(data, options);
    case 'sarif':
      return exportToSARIF(data, options);
    case 'html':
      return exportToHTML(data, options);
    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }
}


/**
 * Export to CSV format
 */
function exportToCSV(data: ExportData, options: ExportOptions): string {
  const headers = [
    'ID', 'Title', 'Severity', 'Score', 'Host', 'Port', 'Service',
    'CVE', 'CWE', 'Description', 'Remediation', 'Scanner', 'Confidence',
    'Discovered At', 'URL'
  ];

  const rows: string[][] = [headers];

  let vulns = data.vulnerabilities;
  if (options.severityFilter?.length) {
    vulns = vulns.filter(v => options.severityFilter!.includes(v.severity.label));
  }

  for (const v of vulns) {
    rows.push([
      v.id,
      escapeCSV(v.title),
      v.severity.label.toUpperCase(),
      v.severity.score.toString(),
      v.host,
      v.port?.toString() || '',
      v.service || '',
      (v.cve || []).join('; '),
      (v.cwe || []).join('; '),
      escapeCSV(v.description?.substring(0, 500) || ''),
      escapeCSV(v.remediation || ''),
      v.scanner,
      v.confidence.toString(),
      v.discoveredAt,
      v.url || ''
    ]);
  }

  return rows.map(row => row.join(',')).join('\n');
}

function escapeCSV(str: string): string {
  if (!str) return '';
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}

/**
 * Export to JSON format
 */
function exportToJSON(data: ExportData, options: ExportOptions): string {
  const output: any = {
    exportedAt: new Date().toISOString(),
    vulnerabilities: data.vulnerabilities
  };

  if (options.includeHosts && data.hosts) {
    output.hosts = data.hosts;
  }

  if (options.includeAttackPaths && data.attackPaths) {
    output.attackPaths = data.attackPaths;
  }

  if (options.includeSummary && data.session) {
    output.summary = {
      target: data.session.target,
      scanId: data.session.id,
      duration: data.session.duration,
      totalVulnerabilities: data.vulnerabilities.length,
      severityBreakdown: data.session.severityBreakdown,
      riskScore: data.session.overallRiskScore
    };
  }

  return JSON.stringify(output, null, 2);
}


/**
 * Export to SARIF format (Static Analysis Results Interchange Format)
 * Compatible with GitHub Security, Azure DevOps, etc.
 */
function exportToSARIF(data: ExportData, options: ExportOptions): string {
  const sarif = {
    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',
    version: '2.1.0',
    runs: [{
      tool: {
        driver: {
          name: 'Vulnerability Scanner',
          version: '1.0.0',
          informationUri: 'https://github.com/vulnerability-scanner',
          rules: generateSARIFRules(data.vulnerabilities)
        }
      },
      results: generateSARIFResults(data.vulnerabilities),
      invocations: [{
        executionSuccessful: true,
        startTimeUtc: data.session?.startedAt,
        endTimeUtc: data.session?.completedAt
      }]
    }]
  };

  return JSON.stringify(sarif, null, 2);
}

function generateSARIFRules(vulns: NormalizedVulnerability[]): any[] {
  const rulesMap = new Map<string, any>();

  for (const v of vulns) {
    const ruleId = v.scannerId || v.cve?.[0] || `vuln-${v.fingerprint}`;
    if (rulesMap.has(ruleId)) continue;

    rulesMap.set(ruleId, {
      id: ruleId,
      name: v.title,
      shortDescription: { text: v.title },
      fullDescription: { text: v.description || v.title },
      helpUri: v.references?.[0],
      defaultConfiguration: {
        level: severityToSARIFLevel(v.severity.label)
      },
      properties: {
        'security-severity': v.severity.score.toString(),
        tags: ['security', 'vulnerability', v.scanner]
      }
    });
  }

  return Array.from(rulesMap.values());
}

function generateSARIFResults(vulns: NormalizedVulnerability[]): any[] {
  return vulns.map(v => ({
    ruleId: v.scannerId || v.cve?.[0] || `vuln-${v.fingerprint}`,
    level: severityToSARIFLevel(v.severity.label),
    message: { text: v.description || v.title },
    locations: [{
      physicalLocation: {
        artifactLocation: {
          uri: v.url || `${v.host}:${v.port || 0}`
        }
      },
      logicalLocations: [{
        name: v.host,
        kind: 'host'
      }]
    }],
    fingerprints: {
      'vulnerability/v1': v.fingerprint
    },
    properties: {
      host: v.host,
      port: v.port,
      service: v.service,
      scanner: v.scanner,
      confidence: v.confidence,
      cve: v.cve,
      cwe: v.cwe
    }
  }));
}

function severityToSARIFLevel(severity: string): string {
  const mapping: Record<string, string> = {
    critical: 'error',
    high: 'error',
    medium: 'warning',
    low: 'note',
    info: 'none'
  };
  return mapping[severity] || 'warning';
}


/**
 * Export to HTML report format
 */
function exportToHTML(data: ExportData, options: ExportOptions): string {
  const severityCounts = {
    critical: data.vulnerabilities.filter(v => v.severity.label === 'critical').length,
    high: data.vulnerabilities.filter(v => v.severity.label === 'high').length,
    medium: data.vulnerabilities.filter(v => v.severity.label === 'medium').length,
    low: data.vulnerabilities.filter(v => v.severity.label === 'low').length,
    info: data.vulnerabilities.filter(v => v.severity.label === 'info').length
  };

  const vulnRows = data.vulnerabilities.map(v => `
    <tr class="severity-${v.severity.label}">
      <td><span class="badge badge-${v.severity.label}">${v.severity.label.toUpperCase()}</span></td>
      <td>${escapeHTML(v.title)}</td>
      <td>${v.host}${v.port ? ':' + v.port : ''}</td>
      <td>${(v.cve || []).join(', ') || '-'}</td>
      <td>${v.scanner}</td>
      <td>${v.confidence}%</td>
    </tr>
  `).join('');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vulnerability Scan Report</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; padding: 20px; }
    .container { max-width: 1200px; margin: 0 auto; }
    .header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); color: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; }
    .header h1 { font-size: 24px; margin-bottom: 10px; }
    .header .meta { opacity: 0.8; font-size: 14px; }
    .summary { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-bottom: 20px; }
    .summary-card { background: white; padding: 20px; border-radius: 8px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .summary-card .count { font-size: 32px; font-weight: bold; }
    .summary-card .label { font-size: 12px; text-transform: uppercase; opacity: 0.7; }
    .summary-card.critical .count { color: #dc2626; }
    .summary-card.high .count { color: #ea580c; }
    .summary-card.medium .count { color: #ca8a04; }
    .summary-card.low .count { color: #2563eb; }
    .summary-card.info .count { color: #6b7280; }
    .table-container { background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    table { width: 100%; border-collapse: collapse; }
    th { background: #f8fafc; padding: 12px; text-align: left; font-size: 12px; text-transform: uppercase; color: #64748b; border-bottom: 2px solid #e2e8f0; }
    td { padding: 12px; border-bottom: 1px solid #e2e8f0; }
    .badge { padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: 600; }
    .badge-critical { background: #fef2f2; color: #dc2626; }
    .badge-high { background: #fff7ed; color: #ea580c; }
    .badge-medium { background: #fefce8; color: #ca8a04; }
    .badge-low { background: #eff6ff; color: #2563eb; }
    .badge-info { background: #f3f4f6; color: #6b7280; }
    tr:hover { background: #f8fafc; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ðŸ”’ Vulnerability Scan Report</h1>
      <div class="meta">
        Target: ${data.session?.target || 'Unknown'} | 
        Scan ID: ${data.session?.id || 'N/A'} | 
        Generated: ${new Date().toLocaleString()}
      </div>
    </div>
    <div class="summary">
      <div class="summary-card critical"><div class="count">${severityCounts.critical}</div><div class="label">Critical</div></div>
      <div class="summary-card high"><div class="count">${severityCounts.high}</div><div class="label">High</div></div>
      <div class="summary-card medium"><div class="count">${severityCounts.medium}</div><div class="label">Medium</div></div>
      <div class="summary-card low"><div class="count">${severityCounts.low}</div><div class="label">Low</div></div>
      <div class="summary-card info"><div class="count">${severityCounts.info}</div><div class="label">Info</div></div>
    </div>
    <div class="table-container">
      <table>
        <thead><tr><th>Severity</th><th>Title</th><th>Target</th><th>CVE</th><th>Scanner</th><th>Confidence</th></tr></thead>
        <tbody>${vulnRows}</tbody>
      </table>
    </div>
  </div>
</body>
</html>`;
}

function escapeHTML(str: string): string {
  if (!str) return '';
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}
