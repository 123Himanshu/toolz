/**
 * AI-Powered File Parser
 * Intelligently parses and corrects malformed CSV/TXT files
 */

import { getAICompletion } from './multi-ai-provider';

interface ParsedTargets {
  targets: string[];
  corrections: string[];
  warnings: string[];
}

/**
 * Parse file content with AI assistance for malformed data
 */
export async function parseFileWithAI(
  content: string,
  filename: string
): Promise<ParsedTargets> {
  // First try basic parsing
  const basicResult = basicParse(content);
  
  // If basic parsing works well, return it
  if (basicResult.targets.length > 0 && basicResult.warnings.length === 0) {
    return basicResult;
  }
  
  // If we have issues, try AI to fix
  if (basicResult.warnings.length > 0) {
    try {
      return await aiAssistedParse(content, filename);
    } catch (error) {
      console.error('AI parsing failed, using basic parse:', error);
      return basicResult;
    }
  }
  
  return basicResult;
}

/**
 * Basic parsing without AI
 */
function basicParse(content: string): ParsedTargets {
  const targets: string[] = [];
  const corrections: string[] = [];
  const warnings: string[] = [];
  
  const lines = content.split(/\r?\n/);
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    // Skip empty lines and comments
    if (!line || line.startsWith('#') || line.startsWith('//')) {
      continue;
    }
    
    // Try to extract target from CSV (handle various formats)
    const parts = line.split(/[,;\t|]/);
    
    for (const part of parts) {
      const cleaned = part.trim().replace(/["']/g, '');
      
      if (isValidTarget(cleaned)) {
        targets.push(cleaned);
      } else if (cleaned.length > 0) {
        warnings.push(`Line ${i + 1}: Could not parse "${cleaned}"`);
      }
    }
  }
  
  return { targets, corrections, warnings };
}

/**
 * AI-assisted parsing for malformed files
 */
async function aiAssistedParse(
  content: string,
  filename: string
): Promise<ParsedTargets> {
  const systemPrompt = 'You are a data parsing expert. Extract and clean target data from malformed files. Return ONLY the cleaned data, no explanations.';
  
  const userPrompt = `You are a data parsing expert. Extract valid security scan targets from this file.

Filename: ${filename}
Content:
${content.slice(0, 2000)}

RULES:
1. Extract all valid targets (IPs, domains, URLs, IP ranges)
2. Fix common formatting issues (extra spaces, quotes, wrong delimiters)
3. Skip headers, comments, and invalid entries
4. Return ONLY valid targets, one per line

Valid target formats:
- IP: 192.168.1.1
- Domain: example.com
- URL: https://example.com
- IP Range: 192.168.1.0/24

Respond with ONLY the cleaned targets, one per line. No explanations.`;

  const result = await getAICompletion(systemPrompt, userPrompt, {
    temperature: 0.1,
    maxTokens: 500
  });

  const aiOutput = result.content;
  
  // Parse AI output
  const targets: string[] = [];
  const corrections: string[] = [];
  
  const lines = aiOutput.split(/\r?\n/);
  for (const line of lines) {
    const cleaned = line.trim();
    if (cleaned && isValidTarget(cleaned)) {
      targets.push(cleaned);
      corrections.push(`AI corrected: ${cleaned}`);
    }
  }
  
  return {
    targets,
    corrections,
    warnings: corrections.length > 0 
      ? [`AI corrected ${corrections.length} malformed entries`]
      : []
  };
}

/**
 * Validate if string is a valid scan target
 */
function isValidTarget(target: string): boolean {
  // IP address
  if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(\/\d{1,2})?$/.test(target)) {
    return true;
  }
  
  // Domain
  if (/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}$/.test(target)) {
    return true;
  }
  
  // URL
  if (/^https?:\/\/.+/.test(target)) {
    return true;
  }
  
  return false;
}

/**
 * Get AI recommendations for scan configuration
 */
export async function getAIScanRecommendations(
  targets: string[]
): Promise<string> {
  const systemPrompt = 'You are a cybersecurity expert. Analyze scan targets and provide practical recommendations.';
  
  const userPrompt = `Analyze these scan targets and provide security scanning recommendations:

Targets:
${targets.slice(0, 10).join('\n')}
${targets.length > 10 ? `... and ${targets.length - 10} more` : ''}

Provide:
1. Target type analysis (web apps, networks, mixed)
2. Recommended scan approach (passive, active, comprehensive)
3. Estimated scan time
4. Any warnings or considerations

Keep it brief (3-4 sentences).`;

  try {
    const result = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.7,
      maxTokens: 500
    });
    
    return result.content || getLocalRecommendations(targets);
  } catch (error) {
    console.error('AI recommendations failed:', error);
    return getLocalRecommendations(targets);
  }
}

/**
 * Local recommendations fallback
 */
function getLocalRecommendations(targets: string[]): string {
  const hasURLs = targets.some(t => t.startsWith('http'));
  const hasIPs = targets.some(t => /^\d{1,3}\.\d{1,3}/.test(t));
  const hasDomains = targets.some(t => /^[a-z]/.test(t) && !t.startsWith('http'));
  
  let recommendation = `Detected ${targets.length} target(s). `;
  
  if (hasURLs) {
    recommendation += 'Web application scanning recommended with Nuclei and Wapiti. ';
  }
  if (hasIPs) {
    recommendation += 'Network scanning with Nmap and RustScan recommended. ';
  }
  if (hasDomains) {
    recommendation += 'DNS enumeration and subdomain discovery recommended. ';
  }
  
  recommendation += `Estimated scan time: ${Math.ceil(targets.length * 2)} minutes.`;
  
  return recommendation;
}
