/**
 * Gemini AI Integration
 * Real AI-powered scan recommendations using Google Gemini 2.0 Flash
 */

import { getAICompletion } from './multi-ai-provider';

/**
 * Smart tool selection based on target analysis
 */
export interface SmartToolRecommendation {
  scanType: 'passive' | 'active' | 'both';
  tools: {
    network: string[];
    web: string[];
    system: string[];
  };
  reasoning: string;
  aiInsight: string;
}

/**
 * Get AI-powered SMART scan recommendations from Gemini
 */
export async function getGrokRecommendation(target: string): Promise<string> {
  const systemPrompt = 'You are a cybersecurity expert specializing in vulnerability assessment and penetration testing. Provide concise, actionable security recommendations.';
  
  const userPrompt = `You are a cybersecurity expert. Analyze this target and recommend the best security scanning tools.

Target: ${target}

Provide a brief analysis (2-3 sentences) covering:
1. What type of target this is (web app, IP, domain, etc.)
2. What technologies might be present
3. What security risks to look for
4. Which scanning approach is best (passive, active, or both)

Keep it concise and actionable.`;

  try {
    const result = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.7,
      maxTokens: 1000
    });
    
    return result.content || 'Unable to generate recommendation';
  } catch (error: any) {
    // Return friendly message instead of throwing
    return 'AI temporarily unavailable. Using smart local analysis for recommendations.';
  }
}

/**
 * Get SMART tool recommendations (no duplication, maximum efficiency)
 */
export async function getSmartToolRecommendation(target: string): Promise<SmartToolRecommendation> {

  const prompt = `You are a cybersecurity tool selection expert. Analyze this target and recommend the OPTIMAL set of scanning tools.

Target: ${target}

AVAILABLE TOOLS:
Network: nmap (core), rustscan (fast port discovery), masscan (large ranges), naabu (JSON output)
Web: nuclei (core CVE scanner), wapiti (web vulnerability scanner), nikto (legacy servers)
System: trivy (core container/IaC), openvas (core CVE scanner), nessus (industry-leading, 65k+ plugins)

RULES:
1. ALWAYS include core tools: nmap, nuclei, wapiti, trivy, nessus
2. Add rustscan ONLY if you need fast port discovery before nmap
3. Add masscan ONLY if target is large IP range (/16, /24)
4. Add wapiti ONLY for quick web checks
5. Add nikto ONLY if target appears to be legacy server
6. NO DUPLICATION - each tool must provide unique value

Respond in JSON format:
{
  "scanType": "passive|active|both",
  "tools": {
    "network": ["tool1", "tool2"],
    "web": ["tool1", "tool2"],
    "system": ["tool1"]
  },
  "reasoning": "Brief explanation of tool selection"
}`;

  try {
    const systemPrompt = 'You are a cybersecurity tool selection expert. Select the optimal set of tools with NO duplication. Always respond with valid JSON.';
    const result = await getAICompletion(systemPrompt, prompt, {
      temperature: 0.3,
      maxTokens: 1500
    });
    
    const content = result.content;
    
    // Extract JSON from response
    const jsonMatch = content.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const recommendation = JSON.parse(jsonMatch[0]);
      return {
        ...recommendation,
        aiInsight: content.replace(jsonMatch[0], '').trim()
      };
    }
    
    return getLocalSmartRecommendation(target);
  } catch (error: any) {
    // Silently fall back to local analysis
    return getLocalSmartRecommendation(target);
  }
}

/**
 * Local smart recommendation logic (fallback)
 */
function getLocalSmartRecommendation(target: string): SmartToolRecommendation {
  const isIP = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(target);
  const isIPRange = target.includes('/');
  const isDomain = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}/.test(target);
  const isURL = target.startsWith('http://') || target.startsWith('https://');
  
  let recommendation: SmartToolRecommendation = {
    scanType: 'both',
    tools: {
      network: [],
      web: [],
      system: []
    },
    reasoning: '',
    aiInsight: ''
  };

  // NETWORK TOOLS
  if (isIPRange) {
    // Large IP range - use Masscan for speed, then Nmap for depth
    recommendation.tools.network = ['masscan', 'nmap'];
    recommendation.reasoning = 'Large IP range detected. Using Masscan for fast discovery, then Nmap for detailed analysis.';
  } else if (isIP || isDomain) {
    // Single target - use RustScan for speed, then Nmap for depth
    recommendation.tools.network = ['rustscan', 'nmap'];
    recommendation.reasoning = 'Single target detected. Using RustScan for fast port discovery, then Nmap for service detection.';
  } else {
    // Default - just Nmap
    recommendation.tools.network = ['nmap'];
    recommendation.reasoning = 'Standard network scan with Nmap.';
  }

  // WEB TOOLS
  if (isURL || isDomain) {
    // Web target - use core tools
    recommendation.tools.web = ['nuclei', 'wapiti'];
    recommendation.reasoning += ' Web target detected. Using Nuclei for CVE scanning and Wapiti for web vulnerability scanning.';
    
    // Add Wapiti for quick checks
    if (target.includes('http://')) {
      recommendation.tools.web.push('wapiti');
      recommendation.reasoning += ' Added Wapiti for fast vulnerability checks.';
    }
  }

  // SYSTEM TOOLS
  if (target.includes('docker') || target.includes('container') || target.includes(':')) {
    // Container target
    recommendation.tools.system = ['trivy'];
    recommendation.reasoning += ' Container/image detected. Using Trivy for vulnerability scanning.';
  } else {
    // Standard target - use both
    recommendation.tools.system = ['trivy', 'nessus'];
    recommendation.reasoning += ' Using Trivy and Nessus Professional for comprehensive system scanning.';
  }

  // SCAN TYPE
  if (isURL || isDomain) {
    recommendation.scanType = 'both';
  } else if (isIP) {
    recommendation.scanType = 'active';
  } else {
    recommendation.scanType = 'both';
  }

  recommendation.aiInsight = `Smart tool selection applied: ${recommendation.tools.network.length + recommendation.tools.web.length + recommendation.tools.system.length} tools selected with zero duplication.`;

  return recommendation;
}

/**
 * Analyze scan results with Gemini AI
 */
export async function analyzeResultsWithGrok(
  target: string,
  results: Record<string, any>
): Promise<string> {

  const resultsummary = Object.entries(results)
    .map(([tool, result]) => `${tool}: ${JSON.stringify(result).slice(0, 200)}`)
    .join('\n');

  const prompt = `Analyze these vulnerability scan results and provide a security assessment:

Target: ${target}

Scan Results:
${resultsummary}

Provide:
1. Overall security posture (1-2 sentences)
2. Top 3 critical findings
3. Recommended immediate actions

Keep it concise and actionable.`;

  try {
    const systemPrompt = 'You are a cybersecurity analyst. Analyze vulnerability scan results and provide clear, actionable security recommendations.';
    const result = await getAICompletion(systemPrompt, prompt, {
      temperature: 0.7,
      maxTokens: 800
    });
    
    return result.content || 'Unable to analyze results';
  } catch (error) {
    console.error('Gemini AI error:', error);
    throw error;
  }
}

/**
 * Get remediation suggestions from Gemini AI
 */
export async function getRemediationSuggestions(
  vulnerability: string,
  context: string
): Promise<string> {
  const prompt = `Provide remediation steps for this security vulnerability:

Vulnerability: ${vulnerability}
Context: ${context}

Provide:
1. Severity assessment
2. Step-by-step remediation
3. Prevention measures

Keep it practical and actionable.`;

  try {
    const systemPrompt = 'You are a security remediation expert. Provide clear, step-by-step guidance for fixing security vulnerabilities.';
    const result = await getAICompletion(systemPrompt, prompt, {
      temperature: 0.7,
      maxTokens: 600
    });
    
    return result.content || 'Unable to generate remediation';
  } catch (error) {
    console.error('Gemini AI error:', error);
    throw error;
  }
}
