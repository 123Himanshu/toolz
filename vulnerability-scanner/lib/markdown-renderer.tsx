/**
 * Markdown Renderer for Chatbot
 * Converts markdown to beautiful React components
 */

import React from 'react';
import { CheckCircle, AlertTriangle, Info, XCircle, Code, List, Hash } from 'lucide-react';

interface MarkdownRendererProps {
  content: string;
  className?: string;
}

export function MarkdownRenderer({ content, className = '' }: MarkdownRendererProps) {
  const renderContent = () => {
    const lines = content.split('\n');
    const elements: React.ReactNode[] = [];
    let inCodeBlock = false;
    let codeContent: string[] = [];
    let codeLanguage = '';
    let inList = false;
    let listItems: string[] = [];
    let listType: 'ul' | 'ol' = 'ul';

    const flushList = () => {
      if (listItems.length > 0) {
        const ListTag = listType;
        elements.push(
          <ListTag key={`list-${elements.length}`} className="my-2 ml-4 space-y-1">
            {listItems.map((item, i) => (
              <li key={i} className="text-gray-300 flex items-start gap-2">
                <span className="text-blue-400 mt-1">•</span>
                <span>{renderInlineMarkdown(item)}</span>
              </li>
            ))}
          </ListTag>
        );
        listItems = [];
        inList = false;
      }
    };

    const flushCodeBlock = () => {
      if (codeContent.length > 0) {
        elements.push(
          <div key={`code-${elements.length}`} className="my-3 rounded-lg overflow-hidden">
            <div className="bg-gray-800 px-3 py-1 text-xs text-gray-400 flex items-center gap-2 border-b border-gray-700">
              <Code size={12} />
              {codeLanguage || 'code'}
            </div>
            <pre className="bg-gray-900 p-3 overflow-x-auto">
              <code className="text-sm text-green-400 font-mono">
                {codeContent.join('\n')}
              </code>
            </pre>
          </div>
        );
        codeContent = [];
        codeLanguage = '';
        inCodeBlock = false;
      }
    };

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];

      // Code block handling
      if (line.startsWith('```')) {
        if (inCodeBlock) {
          flushCodeBlock();
        } else {
          flushList();
          inCodeBlock = true;
          codeLanguage = line.slice(3).trim();
        }
        continue;
      }

      if (inCodeBlock) {
        codeContent.push(line);
        continue;
      }

      // Empty line
      if (!line.trim()) {
        flushList();
        continue;
      }

      // Headers
      if (line.startsWith('### ')) {
        flushList();
        elements.push(
          <h3 key={`h3-${i}`} className="text-lg font-semibold text-white mt-4 mb-2 flex items-center gap-2">
            <Hash size={16} className="text-blue-400" />
            {renderInlineMarkdown(line.slice(4))}
          </h3>
        );
        continue;
      }

      if (line.startsWith('## ')) {
        flushList();
        elements.push(
          <h2 key={`h2-${i}`} className="text-xl font-bold text-white mt-4 mb-2">
            {renderInlineMarkdown(line.slice(3))}
          </h2>
        );
        continue;
      }

      if (line.startsWith('# ')) {
        flushList();
        elements.push(
          <h1 key={`h1-${i}`} className="text-2xl font-bold text-white mt-4 mb-3">
            {renderInlineMarkdown(line.slice(2))}
          </h1>
        );
        continue;
      }

      // List items
      if (line.match(/^[\-\*]\s/)) {
        if (!inList) {
          inList = true;
          listType = 'ul';
        }
        listItems.push(line.slice(2));
        continue;
      }

      if (line.match(/^\d+\.\s/)) {
        if (!inList) {
          inList = true;
          listType = 'ol';
        }
        listItems.push(line.replace(/^\d+\.\s/, ''));
        continue;
      }

      // Alert boxes
      if (line.startsWith('> ⚠️') || line.startsWith('> Warning:')) {
        flushList();
        elements.push(
          <div key={`warn-${i}`} className="my-2 p-3 bg-yellow-500/10 border border-yellow-500/30 rounded-lg flex items-start gap-2">
            <AlertTriangle size={18} className="text-yellow-500 mt-0.5 flex-shrink-0" />
            <span className="text-yellow-200">{renderInlineMarkdown(line.replace(/^>\s*(⚠️|Warning:)\s*/, ''))}</span>
          </div>
        );
        continue;
      }

      if (line.startsWith('> ✅') || line.startsWith('> Success:')) {
        flushList();
        elements.push(
          <div key={`success-${i}`} className="my-2 p-3 bg-green-500/10 border border-green-500/30 rounded-lg flex items-start gap-2">
            <CheckCircle size={18} className="text-green-500 mt-0.5 flex-shrink-0" />
            <span className="text-green-200">{renderInlineMarkdown(line.replace(/^>\s*(✅|Success:)\s*/, ''))}</span>
          </div>
        );
        continue;
      }

      if (line.startsWith('> ❌') || line.startsWith('> Error:')) {
        flushList();
        elements.push(
          <div key={`error-${i}`} className="my-2 p-3 bg-red-500/10 border border-red-500/30 rounded-lg flex items-start gap-2">
            <XCircle size={18} className="text-red-500 mt-0.5 flex-shrink-0" />
            <span className="text-red-200">{renderInlineMarkdown(line.replace(/^>\s*(❌|Error:)\s*/, ''))}</span>
          </div>
        );
        continue;
      }

      if (line.startsWith('> ')) {
        flushList();
        elements.push(
          <div key={`info-${i}`} className="my-2 p-3 bg-blue-500/10 border border-blue-500/30 rounded-lg flex items-start gap-2">
            <Info size={18} className="text-blue-500 mt-0.5 flex-shrink-0" />
            <span className="text-blue-200">{renderInlineMarkdown(line.slice(2))}</span>
          </div>
        );
        continue;
      }

      // Regular paragraph
      flushList();
      elements.push(
        <p key={`p-${i}`} className="text-gray-300 my-2 leading-relaxed">
          {renderInlineMarkdown(line)}
        </p>
      );
    }

    // Flush remaining
    flushList();
    flushCodeBlock();

    return elements;
  };

  return <div className={`markdown-content ${className}`}>{renderContent()}</div>;
}

/**
 * Render inline markdown (bold, italic, code, links)
 */
function renderInlineMarkdown(text: string): React.ReactNode {
  const parts: React.ReactNode[] = [];
  let remaining = text;
  let key = 0;

  while (remaining.length > 0) {
    // Inline code
    const codeMatch = remaining.match(/`([^`]+)`/);
    if (codeMatch && codeMatch.index !== undefined) {
      if (codeMatch.index > 0) {
        parts.push(processTextPart(remaining.slice(0, codeMatch.index), key++));
      }
      parts.push(
        <code key={key++} className="px-1.5 py-0.5 bg-gray-800 text-pink-400 rounded text-sm font-mono">
          {codeMatch[1]}
        </code>
      );
      remaining = remaining.slice(codeMatch.index + codeMatch[0].length);
      continue;
    }

    // Bold
    const boldMatch = remaining.match(/\*\*([^*]+)\*\*/);
    if (boldMatch && boldMatch.index !== undefined) {
      if (boldMatch.index > 0) {
        parts.push(processTextPart(remaining.slice(0, boldMatch.index), key++));
      }
      parts.push(
        <strong key={key++} className="font-semibold text-white">
          {boldMatch[1]}
        </strong>
      );
      remaining = remaining.slice(boldMatch.index + boldMatch[0].length);
      continue;
    }

    // Italic
    const italicMatch = remaining.match(/\*([^*]+)\*/);
    if (italicMatch && italicMatch.index !== undefined) {
      if (italicMatch.index > 0) {
        parts.push(processTextPart(remaining.slice(0, italicMatch.index), key++));
      }
      parts.push(
        <em key={key++} className="italic text-gray-400">
          {italicMatch[1]}
        </em>
      );
      remaining = remaining.slice(italicMatch.index + italicMatch[0].length);
      continue;
    }

    // Link
    const linkMatch = remaining.match(/\[([^\]]+)\]\(([^)]+)\)/);
    if (linkMatch && linkMatch.index !== undefined) {
      if (linkMatch.index > 0) {
        parts.push(processTextPart(remaining.slice(0, linkMatch.index), key++));
      }
      parts.push(
        <a
          key={key++}
          href={linkMatch[2]}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-400 hover:text-blue-300 underline"
        >
          {linkMatch[1]}
        </a>
      );
      remaining = remaining.slice(linkMatch.index + linkMatch[0].length);
      continue;
    }

    // No more matches, add remaining text
    parts.push(processTextPart(remaining, key++));
    break;
  }

  return parts.length === 1 ? parts[0] : <>{parts}</>;
}

/**
 * Process text part for CVE highlighting
 */
function processTextPart(text: string, key: number): React.ReactNode {
  // Highlight CVE IDs
  const cvePattern = /(CVE-\d{4}-\d+)/g;
  const parts = text.split(cvePattern);
  
  if (parts.length === 1) {
    return <span key={key}>{text}</span>;
  }

  return (
    <span key={key}>
      {parts.map((part, i) => {
        if (part.match(cvePattern)) {
          return (
            <span key={i} className="px-1 py-0.5 bg-red-500/20 text-red-400 rounded text-sm font-mono">
              {part}
            </span>
          );
        }
        return part;
      })}
    </span>
  );
}

export default MarkdownRenderer;
