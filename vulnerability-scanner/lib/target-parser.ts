// Smart target parser - handles any format users enter
import { parseFileWithAI, getAIScanRecommendations } from './ai-file-parser';

export interface ParsedTarget {
  original: string;
  clean: string;        // Domain without protocol (for network tools)
  withProtocol: string; // URL with protocol (for web tools)
  type: 'domain' | 'ip' | 'cidr' | 'url' | 'container';
  protocol: 'http' | 'https' | null;
  domain: string;
  port: number | null;
  path: string;
}

export function parseTarget(input: string): ParsedTarget {
  const original = input.trim();
  let clean = original;
  let protocol: 'http' | 'https' | null = null;
  let domain = '';
  let port: number | null = null;
  let path = '';
  let type: ParsedTarget['type'] = 'domain';

  // Remove trailing slashes
  clean = clean.replace(/\/+$/, '');

  // Check if it's a container image (contains : or /)
  if (clean.includes(':') && !clean.startsWith('http') && !clean.match(/^\d+\.\d+\.\d+\.\d+:/)) {
    type = 'container';
    return {
      original,
      clean,
      withProtocol: clean,
      type,
      protocol: null,
      domain: clean,
      port: null,
      path: ''
    };
  }

  // Extract protocol if present
  if (clean.startsWith('https://')) {
    protocol = 'https';
    clean = clean.substring(8);
  } else if (clean.startsWith('http://')) {
    protocol = 'http';
    clean = clean.substring(7);
  }

  // Extract path
  const pathIndex = clean.indexOf('/');
  if (pathIndex > 0) {
    path = clean.substring(pathIndex);
    clean = clean.substring(0, pathIndex);
  }

  // Extract port
  const portMatch = clean.match(/:(\d+)$/);
  if (portMatch) {
    port = parseInt(portMatch[1]);
    clean = clean.replace(/:(\d+)$/, '');
  }

  domain = clean;

  // Determine type
  if (/^\d+\.\d+\.\d+\.\d+$/.test(domain)) {
    type = 'ip';
  } else if (/^\d+\.\d+\.\d+\.\d+\/\d+$/.test(original)) {
    type = 'cidr';
  } else if (protocol || path) {
    type = 'url';
  } else {
    type = 'domain';
  }

  // Build withProtocol version
  let withProtocol = '';
  if (type === 'url' || type === 'domain') {
    // Default to https if no protocol specified
    const finalProtocol = protocol || 'https';
    withProtocol = `${finalProtocol}://${domain}`;
    if (port) withProtocol += `:${port}`;
    if (path) withProtocol += path;
  } else {
    withProtocol = domain;
  }

  return {
    original,
    clean: domain,
    withProtocol,
    type,
    protocol,
    domain,
    port,
    path
  };
}

export function getTargetForTool(parsed: ParsedTarget, tool: string): string {
  const toolLower = tool.toLowerCase();

  // Web tools need full URL with protocol
  const webTools = ['nuclei', 'wapiti', 'nikto', 'jaeles'];
  if (webTools.includes(toolLower)) {
    return parsed.withProtocol;
  }

  // Container tools need the image name
  if (toolLower === 'trivy') {
    return parsed.type === 'container' ? parsed.original : parsed.clean;
  }

  // Network tools need clean domain/IP
  return parsed.clean;
}

export function validateTarget(input: string): { valid: boolean; error?: string; suggestion?: string } {
  if (!input || input.trim() === '') {
    return { valid: false, error: 'Target cannot be empty' };
  }

  const parsed = parseTarget(input);

  // Validate domain format
  if (parsed.type === 'domain') {
    if (!parsed.domain.includes('.')) {
      return {
        valid: false,
        error: 'Invalid domain format',
        suggestion: 'Example: example.com or www.example.com'
      };
    }
  }

  // Validate IP format
  if (parsed.type === 'ip') {
    const parts = parsed.domain.split('.');
    if (parts.length !== 4 || parts.some(p => parseInt(p) > 255)) {
      return {
        valid: false,
        error: 'Invalid IP address',
        suggestion: 'Example: 192.168.1.1'
      };
    }
  }

  // Validate CIDR format
  if (parsed.type === 'cidr') {
    const [ip, mask] = parsed.original.split('/');
    const maskNum = parseInt(mask);
    if (maskNum < 0 || maskNum > 32) {
      return {
        valid: false,
        error: 'Invalid CIDR notation',
        suggestion: 'Example: 192.168.1.0/24'
      };
    }
  }

  return { valid: true };
}

// Helper to show user what will be scanned
export function getTargetDescription(input: string): string {
  const parsed = parseTarget(input);

  switch (parsed.type) {
    case 'domain':
      return `Domain: ${parsed.clean}`;
    case 'ip':
      return `IP Address: ${parsed.clean}`;
    case 'cidr':
      return `IP Range: ${parsed.original}`;
    case 'url':
      return `Website: ${parsed.withProtocol}`;
    case 'container':
      return `Container: ${parsed.original}`;
    default:
      return `Target: ${parsed.original}`;
  }
}


/**
 * Parse bulk targets from file content with AI assistance
 */
export async function parseBulkTargetsWithAI(
  content: string,
  filename: string
): Promise<{
  targets: ParsedTarget[];
  corrections: string[];
  warnings: string[];
  aiRecommendation: string;
}> {
  // Use AI to parse and correct malformed data
  const parsed = await parseFileWithAI(content, filename);
  
  // Convert to ParsedTarget format
  const targets = parsed.targets.map(t => parseTarget(t));
  
  // Get AI recommendations for the scan
  const aiRecommendation = await getAIScanRecommendations(parsed.targets);
  
  return {
    targets,
    corrections: parsed.corrections,
    warnings: parsed.warnings,
    aiRecommendation
  };
}

/**
 * Export AI parsing functions for use in API routes
 */
export { parseFileWithAI, getAIScanRecommendations };
