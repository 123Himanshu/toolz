/**
 * PostgreSQL Database Client
 * Handles normalized vulnerability data, users, sessions, and relational queries
 */

// @ts-ignore - pg types
import { Pool, PoolClient } from 'pg';

// Connection pool
let pool: Pool | null = null;

export function getPool(): Pool {
  if (!pool) {
    const connectionString = process.env.DATABASE_URL;
    
    if (!connectionString) {
      throw new Error('DATABASE_URL environment variable is not set');
    }

    pool = new Pool({
      connectionString,
      ssl: { rejectUnauthorized: false },
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 10000,
    });

    pool.on('error', (err: Error) => {
      console.error('Unexpected PostgreSQL pool error:', err);
    });
  }
  return pool;
}

export async function query<T = any>(text: string, params?: any[]): Promise<T[]> {
  const pool = getPool();
  const start = Date.now();
  
  try {
    const result = await pool.query(text, params);
    const duration = Date.now() - start;
    
    if (duration > 1000) {
      console.warn(`Slow query (${duration}ms):`, text.substring(0, 100));
    }
    
    return result.rows as T[];
  } catch (error) {
    console.error('PostgreSQL query error:', error);
    throw error;
  }
}

export async function queryOne<T = any>(text: string, params?: any[]): Promise<T | null> {
  const rows = await query<T>(text, params);
  return rows[0] || null;
}

export async function transaction<T>(
  callback: (client: PoolClient) => Promise<T>
): Promise<T> {
  const pool = getPool();
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    const result = await callback(client);
    await client.query('COMMIT');
    return result;
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}

// Initialize database schema
export async function initializeDatabase(): Promise<void> {
  console.log('Initializing PostgreSQL database schema...');
  
  // Create tables one by one to handle dependencies
  
  // Users table
  await query(`
    CREATE TABLE IF NOT EXISTS users (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      email VARCHAR(255) UNIQUE NOT NULL,
      password_hash VARCHAR(255) NOT NULL,
      name VARCHAR(255),
      role VARCHAR(50) DEFAULT 'analyst',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      last_login TIMESTAMP,
      is_active BOOLEAN DEFAULT true
    )
  `);

  // Sessions table
  await query(`
    CREATE TABLE IF NOT EXISTS sessions (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID,
      token VARCHAR(500) NOT NULL,
      expires_at TIMESTAMP NOT NULL,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      ip_address VARCHAR(45),
      user_agent TEXT
    )
  `);

  // Scans table
  await query(`
    CREATE TABLE IF NOT EXISTS scans (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID,
      target VARCHAR(500) NOT NULL,
      scan_type VARCHAR(50) DEFAULT 'active',
      status VARCHAR(50) DEFAULT 'pending',
      tools TEXT[],
      started_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      completed_at TIMESTAMP,
      duration_seconds INTEGER,
      raw_output_ref VARCHAR(255),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Assets table
  await query(`
    CREATE TABLE IF NOT EXISTS assets (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      ip_address VARCHAR(45) UNIQUE,
      hostname VARCHAR(255),
      mac_address VARCHAR(17),
      os VARCHAR(255),
      os_version VARCHAR(100),
      network_segment VARCHAR(100),
      is_external BOOLEAN DEFAULT false,
      first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      risk_score DECIMAL(5,2) DEFAULT 0,
      zdes_score DECIMAL(5,2) DEFAULT 0,
      tags TEXT[],
      metadata JSONB DEFAULT '{}'::jsonb
    )
  `);

  // Services table
  await query(`
    CREATE TABLE IF NOT EXISTS services (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      asset_id UUID,
      port INTEGER NOT NULL,
      protocol VARCHAR(10) DEFAULT 'tcp',
      service_name VARCHAR(100),
      service_version VARCHAR(100),
      product VARCHAR(255),
      banner TEXT,
      state VARCHAR(20) DEFAULT 'open',
      first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      last_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      risk_score DECIMAL(5,2) DEFAULT 0
    )
  `);

  // Vulnerabilities table
  await query(`
    CREATE TABLE IF NOT EXISTS vulnerabilities (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      scan_id UUID,
      asset_id UUID,
      canonical_id UUID,
      scanner VARCHAR(50) NOT NULL,
      scanner_category VARCHAR(50),
      scanner_id VARCHAR(255),
      host VARCHAR(255) NOT NULL,
      port INTEGER,
      protocol VARCHAR(10),
      service VARCHAR(100),
      url TEXT,
      title VARCHAR(500) NOT NULL,
      description TEXT,
      severity_score DECIMAL(3,1),
      severity_label VARCHAR(20),
      cve TEXT[],
      cwe TEXT[],
      evidence TEXT,
      request TEXT,
      response TEXT,
      matched_at TEXT,
      remediation TEXT,
      refs TEXT[],
      confidence INTEGER DEFAULT 50,
      verified BOOLEAN DEFAULT false,
      false_positive BOOLEAN DEFAULT false,
      fingerprint VARCHAR(64),
      duplicate_of UUID,
      duplicate_count INTEGER DEFAULT 1,
      discovered_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      raw_data_ref VARCHAR(255)
    )
  `);

  // CVE enrichment cache
  await query(`
    CREATE TABLE IF NOT EXISTS cve_enrichment (
      cve_id VARCHAR(20) PRIMARY KEY,
      nvd_score DECIMAL(3,1),
      nvd_vector TEXT,
      nvd_description TEXT,
      epss_score DECIMAL(5,4),
      epss_percentile DECIMAL(5,4),
      exploit_available BOOLEAN DEFAULT false,
      exploit_db_id VARCHAR(50),
      metasploit_module TEXT,
      in_the_wild BOOLEAN DEFAULT false,
      ransomware_associated BOOLEAN DEFAULT false,
      apt_associated BOOLEAN DEFAULT false,
      kev_due_date DATE,
      published_date DATE,
      last_modified DATE,
      refs TEXT[],
      fetched_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Attack paths
  await query(`
    CREATE TABLE IF NOT EXISTS attack_paths (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      scan_id UUID,
      name VARCHAR(255),
      description TEXT,
      entry_point VARCHAR(255),
      target VARCHAR(255),
      path_type VARCHAR(50),
      nodes JSONB,
      edges JSONB,
      critical_path TEXT[],
      overall_risk DECIMAL(5,2),
      exploitability DECIMAL(5,2),
      impact DECIMAL(5,2),
      mitigations TEXT[],
      prioritized_fixes TEXT[],
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Remediation tracking
  await query(`
    CREATE TABLE IF NOT EXISTS remediation_records (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      vulnerability_id UUID,
      status VARCHAR(50) DEFAULT 'open',
      assignee VARCHAR(255),
      notes TEXT,
      fixed_at TIMESTAMP,
      fixed_by VARCHAR(255),
      verified_at TIMESTAMP,
      verified_by VARCHAR(255),
      accepted_reason TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Audit log
  await query(`
    CREATE TABLE IF NOT EXISTS audit_log (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      user_id UUID,
      action VARCHAR(100) NOT NULL,
      entity_type VARCHAR(50),
      entity_id UUID,
      old_value JSONB,
      new_value JSONB,
      ip_address VARCHAR(45),
      user_agent TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
  `);

  // Create indexes (ignore errors if they exist)
  const indexes = [
    'CREATE INDEX IF NOT EXISTS idx_vulnerabilities_scan_id ON vulnerabilities(scan_id)',
    'CREATE INDEX IF NOT EXISTS idx_vulnerabilities_severity ON vulnerabilities(severity_label)',
    'CREATE INDEX IF NOT EXISTS idx_vulnerabilities_fingerprint ON vulnerabilities(fingerprint)',
    'CREATE INDEX IF NOT EXISTS idx_vulnerabilities_host ON vulnerabilities(host)',
    'CREATE INDEX IF NOT EXISTS idx_scans_status ON scans(status)',
  ];

  for (const idx of indexes) {
    try {
      await query(idx);
    } catch (e) {
      // Index may already exist
    }
  }

  console.log('PostgreSQL database schema initialized successfully');
}

// Health check
export async function healthCheck(): Promise<boolean> {
  try {
    await query('SELECT 1');
    return true;
  } catch {
    return false;
  }
}

export default { getPool, query, queryOne, transaction, initializeDatabase, healthCheck };
