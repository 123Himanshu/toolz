/**
 * Elasticsearch/OpenSearch Client
 * Handles full-text search, faceted queries, and analytics
 */

import { Client } from '@elastic/elasticsearch';

let client: Client | null = null;

const INDEX_PREFIX = 'vuln_scanner_';

export const INDICES = {
  VULNERABILITIES: `${INDEX_PREFIX}vulnerabilities`,
  ASSETS: `${INDEX_PREFIX}assets`,
  SERVICES: `${INDEX_PREFIX}services`,
  SCANS: `${INDEX_PREFIX}scans`,
  ATTACK_PATHS: `${INDEX_PREFIX}attack_paths`,
} as const;

export function getClient(): Client {
  if (!client) {
    const url = process.env.ELASTICSEARCH_URL || 'http://localhost:9200';
    
    client = new Client({
      node: url,
      maxRetries: 3,
      requestTimeout: 30000,
      sniffOnStart: false,
    });
  }
  return client;
}

// ============================================================================
// INDEX MANAGEMENT
// ============================================================================

export async function initializeIndices(): Promise<void> {
  console.log('Initializing Elasticsearch indices...');
  const es = getClient();

  // Vulnerabilities index
  await createIndexIfNotExists(INDICES.VULNERABILITIES, {
    mappings: {
      properties: {
        id: { type: 'keyword' },
        scanId: { type: 'keyword' },
        assetId: { type: 'keyword' },
        canonicalId: { type: 'keyword' },
        scanner: { type: 'keyword' },
        scannerCategory: { type: 'keyword' },
        host: { type: 'keyword' },
        port: { type: 'integer' },
        protocol: { type: 'keyword' },
        service: { type: 'keyword' },
        url: { type: 'text', fields: { keyword: { type: 'keyword' } } },
        title: { type: 'text', analyzer: 'standard', fields: { keyword: { type: 'keyword' } } },
        description: { type: 'text', analyzer: 'standard' },
        severityScore: { type: 'float' },
        severityLabel: { type: 'keyword' },
        cve: { type: 'keyword' },
        cwe: { type: 'keyword' },
        evidence: { type: 'text' },
        remediation: { type: 'text' },
        references: { type: 'keyword' },
        confidence: { type: 'integer' },
        verified: { type: 'boolean' },
        falsePositive: { type: 'boolean' },
        fingerprint: { type: 'keyword' },
        duplicateOf: { type: 'keyword' },
        duplicateCount: { type: 'integer' },
        discoveredAt: { type: 'date' },
        updatedAt: { type: 'date' },
        // Enrichment fields
        epssScore: { type: 'float' },
        exploitAvailable: { type: 'boolean' },
        inTheWild: { type: 'boolean' },
        ransomwareAssociated: { type: 'boolean' },
        // Risk scoring
        riskScore: { type: 'float' },
        riskLabel: { type: 'keyword' },
      }
    },
    settings: {
      number_of_shards: 1,
      number_of_replicas: 0,
      analysis: {
        analyzer: {
          standard: {
            type: 'standard',
            stopwords: '_english_'
          }
        }
      }
    }
  });

  // Assets index
  await createIndexIfNotExists(INDICES.ASSETS, {
    mappings: {
      properties: {
        id: { type: 'keyword' },
        ipAddress: { type: 'ip' },
        hostname: { type: 'keyword' },
        mac: { type: 'keyword' },
        os: { type: 'text', fields: { keyword: { type: 'keyword' } } },
        osVersion: { type: 'keyword' },
        networkSegment: { type: 'keyword' },
        isExternal: { type: 'boolean' },
        openPorts: { type: 'integer' },
        services: { type: 'keyword' },
        vulnerabilityCount: {
          properties: {
            critical: { type: 'integer' },
            high: { type: 'integer' },
            medium: { type: 'integer' },
            low: { type: 'integer' },
            info: { type: 'integer' },
          }
        },
        riskScore: { type: 'float' },
        zdesScore: { type: 'float' },
        tags: { type: 'keyword' },
        firstSeen: { type: 'date' },
        lastSeen: { type: 'date' },
      }
    },
    settings: {
      number_of_shards: 1,
      number_of_replicas: 0,
    }
  });

  // Services index
  await createIndexIfNotExists(INDICES.SERVICES, {
    mappings: {
      properties: {
        id: { type: 'keyword' },
        assetId: { type: 'keyword' },
        host: { type: 'keyword' },
        port: { type: 'integer' },
        protocol: { type: 'keyword' },
        service: { type: 'keyword' },
        version: { type: 'keyword' },
        product: { type: 'text', fields: { keyword: { type: 'keyword' } } },
        banner: { type: 'text' },
        state: { type: 'keyword' },
        vulnerabilityCount: { type: 'integer' },
        riskScore: { type: 'float' },
        firstSeen: { type: 'date' },
        lastSeen: { type: 'date' },
      }
    },
    settings: {
      number_of_shards: 1,
      number_of_replicas: 0,
    }
  });

  // Scans index
  await createIndexIfNotExists(INDICES.SCANS, {
    mappings: {
      properties: {
        id: { type: 'keyword' },
        userId: { type: 'keyword' },
        target: { type: 'text', fields: { keyword: { type: 'keyword' } } },
        scanType: { type: 'keyword' },
        status: { type: 'keyword' },
        tools: { type: 'keyword' },
        startedAt: { type: 'date' },
        completedAt: { type: 'date' },
        duration: { type: 'integer' },
        hostsDiscovered: { type: 'integer' },
        servicesDiscovered: { type: 'integer' },
        vulnerabilitiesFound: { type: 'integer' },
        severityBreakdown: {
          properties: {
            critical: { type: 'integer' },
            high: { type: 'integer' },
            medium: { type: 'integer' },
            low: { type: 'integer' },
            info: { type: 'integer' },
          }
        },
        overallRiskScore: { type: 'float' },
      }
    },
    settings: {
      number_of_shards: 1,
      number_of_replicas: 0,
    }
  });

  console.log('Elasticsearch indices initialized');
}

async function createIndexIfNotExists(
  indexName: string, 
  settings: any
): Promise<void> {
  const es = getClient();
  
  try {
    const exists = await es.indices.exists({ index: indexName });
    
    if (!exists) {
      await es.indices.create({
        index: indexName,
        body: settings,
      });
      console.log(`Created index: ${indexName}`);
    }
  } catch (error: any) {
    if (error.meta?.body?.error?.type !== 'resource_already_exists_exception') {
      console.error(`Error creating index ${indexName}:`, error);
    }
  }
}

// ============================================================================
// DOCUMENT OPERATIONS
// ============================================================================

export async function indexDocument(
  index: string, 
  id: string, 
  document: any
): Promise<void> {
  const es = getClient();
  
  await es.index({
    index,
    id,
    document,
    refresh: true,
  });
}

export async function bulkIndex(
  index: string, 
  documents: Array<{ id: string; doc: any }>
): Promise<void> {
  const es = getClient();
  
  if (documents.length === 0) return;
  
  const operations = documents.flatMap(({ id, doc }) => [
    { index: { _index: index, _id: id } },
    doc,
  ]);
  
  const result = await es.bulk({ operations, refresh: true });
  
  if (result.errors) {
    const errors = result.items
      .filter((item: any) => item.index?.error)
      .map((item: any) => item.index?.error);
    console.error('Bulk index errors:', errors.slice(0, 5));
  }
}

export async function getDocument<T>(index: string, id: string): Promise<T | null> {
  const es = getClient();
  
  try {
    const result = await es.get({ index, id });
    return result._source as T;
  } catch (error: any) {
    if (error.meta?.statusCode === 404) {
      return null;
    }
    throw error;
  }
}

export async function deleteDocument(index: string, id: string): Promise<void> {
  const es = getClient();
  
  try {
    await es.delete({ index, id, refresh: true });
  } catch (error: any) {
    if (error.meta?.statusCode !== 404) {
      throw error;
    }
  }
}

// ============================================================================
// SEARCH OPERATIONS
// ============================================================================

export interface SearchOptions {
  query?: string;
  filters?: Record<string, any>;
  sort?: Array<{ field: string; order: 'asc' | 'desc' }>;
  page?: number;
  limit?: number;
  aggregations?: Record<string, any>;
}

export interface SearchResult<T> {
  hits: T[];
  total: number;
  aggregations?: Record<string, any>;
  took: number;
}

export async function search<T>(
  index: string, 
  options: SearchOptions
): Promise<SearchResult<T>> {
  const es = getClient();
  
  const { query, filters, sort, page = 1, limit = 20, aggregations } = options;
  
  // Build query
  const must: any[] = [];
  const filter: any[] = [];
  
  if (query) {
    must.push({
      multi_match: {
        query,
        fields: ['title^3', 'description^2', 'host', 'cve', 'service'],
        type: 'best_fields',
        fuzziness: 'AUTO',
      }
    });
  }
  
  if (filters) {
    for (const [field, value] of Object.entries(filters)) {
      if (value === undefined || value === null) continue;
      
      if (Array.isArray(value)) {
        filter.push({ terms: { [field]: value } });
      } else if (typeof value === 'object' && (value.gte || value.lte)) {
        filter.push({ range: { [field]: value } });
      } else {
        filter.push({ term: { [field]: value } });
      }
    }
  }
  
  const body: any = {
    query: {
      bool: {
        must: must.length > 0 ? must : [{ match_all: {} }],
        filter,
      }
    },
    from: (page - 1) * limit,
    size: limit,
  };
  
  // Add sorting
  if (sort && sort.length > 0) {
    body.sort = sort.map(s => ({ [s.field]: { order: s.order } }));
  }
  
  // Add aggregations
  if (aggregations) {
    body.aggs = aggregations;
  }
  
  const result = await es.search({ index, body });
  
  return {
    hits: result.hits.hits.map((hit: any) => ({
      ...hit._source,
      _id: hit._id,
      _score: hit._score,
    })) as T[],
    total: typeof result.hits.total === 'number' 
      ? result.hits.total 
      : result.hits.total?.value || 0,
    aggregations: result.aggregations as Record<string, any>,
    took: result.took,
  };
}

// ============================================================================
// VULNERABILITY-SPECIFIC SEARCHES
// ============================================================================

export async function searchVulnerabilities(options: {
  query?: string;
  scanId?: string;
  host?: string;
  severity?: string | string[];
  scanner?: string | string[];
  cve?: string;
  exploitAvailable?: boolean;
  page?: number;
  limit?: number;
}): Promise<SearchResult<any>> {
  const filters: Record<string, any> = {};
  
  if (options.scanId) filters.scanId = options.scanId;
  if (options.host) filters.host = options.host;
  if (options.severity) filters.severityLabel = options.severity;
  if (options.scanner) filters.scanner = options.scanner;
  if (options.cve) filters.cve = options.cve;
  if (options.exploitAvailable !== undefined) {
    filters.exploitAvailable = options.exploitAvailable;
  }
  
  return search(INDICES.VULNERABILITIES, {
    query: options.query,
    filters,
    sort: [{ field: 'severityScore', order: 'desc' }],
    page: options.page,
    limit: options.limit,
    aggregations: {
      severity_breakdown: {
        terms: { field: 'severityLabel' }
      },
      scanner_breakdown: {
        terms: { field: 'scanner' }
      },
      top_cves: {
        terms: { field: 'cve', size: 10 }
      },
      exploit_available: {
        terms: { field: 'exploitAvailable' }
      }
    }
  });
}

export async function searchAssets(options: {
  query?: string;
  ipAddress?: string;
  isExternal?: boolean;
  minRiskScore?: number;
  page?: number;
  limit?: number;
}): Promise<SearchResult<any>> {
  const filters: Record<string, any> = {};
  
  if (options.ipAddress) filters.ipAddress = options.ipAddress;
  if (options.isExternal !== undefined) filters.isExternal = options.isExternal;
  if (options.minRiskScore !== undefined) {
    filters.riskScore = { gte: options.minRiskScore };
  }
  
  return search(INDICES.ASSETS, {
    query: options.query,
    filters,
    sort: [{ field: 'riskScore', order: 'desc' }],
    page: options.page,
    limit: options.limit,
    aggregations: {
      os_breakdown: {
        terms: { field: 'os.keyword' }
      },
      external_vs_internal: {
        terms: { field: 'isExternal' }
      },
      risk_distribution: {
        histogram: { field: 'riskScore', interval: 10 }
      }
    }
  });
}

// ============================================================================
// ANALYTICS & AGGREGATIONS
// ============================================================================

export async function getVulnerabilityStats(scanId?: string): Promise<any> {
  const es = getClient();
  
  const filter = scanId ? [{ term: { scanId } }] : [];
  
  const result = await es.search({
    index: INDICES.VULNERABILITIES,
    body: {
      size: 0,
      query: {
        bool: { filter }
      },
      aggs: {
        total_count: { value_count: { field: 'id' } },
        severity_breakdown: { terms: { field: 'severityLabel' } },
        scanner_breakdown: { terms: { field: 'scanner' } },
        top_hosts: { terms: { field: 'host', size: 10 } },
        top_cves: { terms: { field: 'cve', size: 10 } },
        exploit_available_count: {
          filter: { term: { exploitAvailable: true } }
        },
        in_the_wild_count: {
          filter: { term: { inTheWild: true } }
        },
        avg_risk_score: { avg: { field: 'riskScore' } },
        max_risk_score: { max: { field: 'riskScore' } },
        discoveries_over_time: {
          date_histogram: {
            field: 'discoveredAt',
            calendar_interval: 'day'
          }
        }
      }
    }
  });
  
  return result.aggregations;
}

// ============================================================================
// HEALTH & CLEANUP
// ============================================================================

export async function healthCheck(): Promise<boolean> {
  try {
    const es = getClient();
    const health = await es.cluster.health();
    return health.status !== 'red';
  } catch {
    return false;
  }
}

export async function deleteIndex(indexName: string): Promise<void> {
  const es = getClient();
  
  try {
    await es.indices.delete({ index: indexName });
    console.log(`Deleted index: ${indexName}`);
  } catch (error: any) {
    if (error.meta?.statusCode !== 404) {
      throw error;
    }
  }
}

export default {
  getClient,
  initializeIndices,
  indexDocument,
  bulkIndex,
  getDocument,
  deleteDocument,
  search,
  searchVulnerabilities,
  searchAssets,
  getVulnerabilityStats,
  healthCheck,
  deleteIndex,
  INDICES,
};
