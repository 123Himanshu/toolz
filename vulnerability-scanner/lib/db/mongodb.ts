/**
 * MongoDB Database Client
 * Handles raw scan outputs, logs, and unstructured data
 */

// @ts-ignore - mongodb types
import { MongoClient, Db, Collection, ObjectId } from 'mongodb';

let client: MongoClient | null = null;
let db: Db | null = null;

const DB_NAME = 'vulnerability_scanner';

export async function getClient(): Promise<MongoClient> {
  if (!client) {
    const uri = process.env.MONGODB_URI;
    
    if (!uri) {
      throw new Error('MONGODB_URI environment variable is not set');
    }

    client = new MongoClient(uri, {
      maxPoolSize: 10,
      minPoolSize: 2,
      maxIdleTimeMS: 30000,
      connectTimeoutMS: 10000,
      serverSelectionTimeoutMS: 10000,
    });

    await client.connect();
    console.log('Connected to MongoDB');
  }
  return client;
}

export async function getDb(): Promise<Db> {
  if (!db) {
    const mongoClient = await getClient();
    db = mongoClient.db(DB_NAME);
  }
  return db;
}

export async function getCollection<T extends Record<string, any> = Record<string, any>>(name: string): Promise<Collection<T>> {
  const database = await getDb();
  return database.collection<T>(name);
}

// Collection names
export const COLLECTIONS = {
  RAW_OUTPUTS: 'raw_outputs',
  SCAN_LOGS: 'scan_logs',
  TOOL_OUTPUTS: 'tool_outputs',
  ENRICHMENT_CACHE: 'enrichment_cache',
  ATTACK_GRAPHS: 'attack_graphs',
  ZERO_DAY_INDICATORS: 'zero_day_indicators',
  AUDIT_EVENTS: 'audit_events',
} as const;

// ============================================================================
// RAW OUTPUT OPERATIONS
// ============================================================================

export interface RawOutput {
  _id?: ObjectId;
  scanId: string;
  tool: string;
  target: string;
  output: any;
  outputType: 'json' | 'xml' | 'text' | 'binary';
  size: number;
  checksum: string;
  createdAt: Date;
  processedAt?: Date;
  parserVersion?: string;
}

export async function storeRawOutput(data: Omit<RawOutput, '_id' | 'createdAt'>): Promise<string> {
  const collection = await getCollection<RawOutput>(COLLECTIONS.RAW_OUTPUTS);
  
  const doc: RawOutput = {
    ...data,
    createdAt: new Date(),
  };
  
  const result = await collection.insertOne(doc as any);
  return result.insertedId.toString();
}

export async function getRawOutput(scanId: string, tool: string): Promise<RawOutput | null> {
  const collection = await getCollection<RawOutput>(COLLECTIONS.RAW_OUTPUTS);
  return collection.findOne({ scanId, tool });
}

export async function getRawOutputsByScan(scanId: string): Promise<RawOutput[]> {
  const collection = await getCollection<RawOutput>(COLLECTIONS.RAW_OUTPUTS);
  return collection.find({ scanId }).toArray();
}

// ============================================================================
// SCAN LOG OPERATIONS
// ============================================================================

export interface ScanLog {
  _id?: ObjectId;
  scanId: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  tool?: string;
  metadata?: Record<string, any>;
  timestamp: Date;
}

export async function logScanEvent(data: Omit<ScanLog, '_id' | 'timestamp'>): Promise<void> {
  const collection = await getCollection<ScanLog>(COLLECTIONS.SCAN_LOGS);
  
  await collection.insertOne({
    ...data,
    timestamp: new Date(),
  } as any);
}

export async function getScanLogs(scanId: string, level?: string): Promise<ScanLog[]> {
  const collection = await getCollection<ScanLog>(COLLECTIONS.SCAN_LOGS);
  
  const filter: any = { scanId };
  if (level) filter.level = level;
  
  return collection.find(filter).sort({ timestamp: 1 }).toArray();
}

// ============================================================================
// TOOL OUTPUT OPERATIONS (for individual tool results)
// ============================================================================

export interface ToolOutput {
  _id?: ObjectId;
  scanId: string;
  tool: string;
  target: string;
  success: boolean;
  startedAt: Date;
  completedAt: Date;
  duration: number;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  parsedResult?: any;
  error?: string;
}

export async function storeToolOutput(data: Omit<ToolOutput, '_id'>): Promise<string> {
  const collection = await getCollection<ToolOutput>(COLLECTIONS.TOOL_OUTPUTS);
  const result = await collection.insertOne(data as any);
  return result.insertedId.toString();
}

export async function getToolOutputs(scanId: string): Promise<ToolOutput[]> {
  const collection = await getCollection<ToolOutput>(COLLECTIONS.TOOL_OUTPUTS);
  return collection.find({ scanId }).toArray();
}

// ============================================================================
// ENRICHMENT CACHE
// ============================================================================

export interface EnrichmentCache {
  _id?: ObjectId;
  cveId: string;
  source: string;
  data: any;
  fetchedAt: Date;
  expiresAt: Date;
}

export async function cacheEnrichment(
  cveId: string, 
  source: string, 
  data: any, 
  ttlHours: number = 24
): Promise<void> {
  const collection = await getCollection<EnrichmentCache>(COLLECTIONS.ENRICHMENT_CACHE);
  
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + ttlHours);
  
  await collection.updateOne(
    { cveId, source },
    {
      $set: {
        data,
        fetchedAt: new Date(),
        expiresAt,
      }
    },
    { upsert: true }
  );
}

export async function getCachedEnrichment(cveId: string, source: string): Promise<any | null> {
  const collection = await getCollection<EnrichmentCache>(COLLECTIONS.ENRICHMENT_CACHE);
  
  const cached = await collection.findOne({
    cveId,
    source,
    expiresAt: { $gt: new Date() }
  });
  
  return cached?.data || null;
}

// ============================================================================
// ATTACK GRAPH STORAGE
// ============================================================================

export interface AttackGraphDoc {
  _id?: ObjectId;
  scanId: string;
  nodes: any[];
  edges: any[];
  metadata: {
    nodeCount: number;
    edgeCount: number;
    entryPoints: string[];
    criticalAssets: string[];
  };
  createdAt: Date;
}

export async function storeAttackGraph(data: Omit<AttackGraphDoc, '_id' | 'createdAt'>): Promise<string> {
  const collection = await getCollection<AttackGraphDoc>(COLLECTIONS.ATTACK_GRAPHS);
  
  const result = await collection.insertOne({
    ...data,
    createdAt: new Date(),
  } as any);
  
  return result.insertedId.toString();
}

export async function getAttackGraph(scanId: string): Promise<AttackGraphDoc | null> {
  const collection = await getCollection<AttackGraphDoc>(COLLECTIONS.ATTACK_GRAPHS);
  return collection.findOne({ scanId });
}

// ============================================================================
// ZERO-DAY INDICATORS
// ============================================================================

export interface ZeroDayIndicatorDoc {
  _id?: ObjectId;
  scanId: string;
  assetId: string;
  indicatorType: 'exposure' | 'anomaly' | 'behavior';
  description: string;
  confidence: number;
  severity: string;
  details: Record<string, any>;
  createdAt: Date;
}

export async function storeZeroDayIndicator(
  data: Omit<ZeroDayIndicatorDoc, '_id' | 'createdAt'>
): Promise<string> {
  const collection = await getCollection<ZeroDayIndicatorDoc>(COLLECTIONS.ZERO_DAY_INDICATORS);
  
  const result = await collection.insertOne({
    ...data,
    createdAt: new Date(),
  } as any);
  
  return result.insertedId.toString();
}

export async function getZeroDayIndicators(scanId: string): Promise<ZeroDayIndicatorDoc[]> {
  const collection = await getCollection<ZeroDayIndicatorDoc>(COLLECTIONS.ZERO_DAY_INDICATORS);
  return collection.find({ scanId }).toArray();
}

// ============================================================================
// AUDIT EVENTS
// ============================================================================

export interface AuditEvent {
  _id?: ObjectId;
  userId?: string;
  action: string;
  entityType: string;
  entityId?: string;
  details: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  timestamp: Date;
}

export async function logAuditEvent(data: Omit<AuditEvent, '_id' | 'timestamp'>): Promise<void> {
  const collection = await getCollection<AuditEvent>(COLLECTIONS.AUDIT_EVENTS);
  
  await collection.insertOne({
    ...data,
    timestamp: new Date(),
  } as any);
}

// ============================================================================
// INITIALIZATION & HEALTH
// ============================================================================

export async function initializeMongoDB(): Promise<void> {
  console.log('Initializing MongoDB collections and indexes...');
  
  const database = await getDb();
  
  // Create collections if they don't exist
  const collections = await database.listCollections().toArray();
  const existingNames = collections.map((c: { name: string }) => c.name);
  
  for (const collName of Object.values(COLLECTIONS)) {
    if (!existingNames.includes(collName)) {
      await database.createCollection(collName);
      console.log(`Created collection: ${collName}`);
    }
  }
  
  // Create indexes
  const rawOutputs = await getCollection(COLLECTIONS.RAW_OUTPUTS);
  await rawOutputs.createIndex({ scanId: 1, tool: 1 }, { unique: true });
  await rawOutputs.createIndex({ createdAt: 1 });
  
  const scanLogs = await getCollection(COLLECTIONS.SCAN_LOGS);
  await scanLogs.createIndex({ scanId: 1, timestamp: 1 });
  await scanLogs.createIndex({ level: 1 });
  
  const toolOutputs = await getCollection(COLLECTIONS.TOOL_OUTPUTS);
  await toolOutputs.createIndex({ scanId: 1, tool: 1 });
  
  const enrichmentCache = await getCollection(COLLECTIONS.ENRICHMENT_CACHE);
  await enrichmentCache.createIndex({ cveId: 1, source: 1 }, { unique: true });
  await enrichmentCache.createIndex({ expiresAt: 1 }, { expireAfterSeconds: 0 });
  
  const attackGraphs = await getCollection(COLLECTIONS.ATTACK_GRAPHS);
  await attackGraphs.createIndex({ scanId: 1 });
  
  const zeroDayIndicators = await getCollection(COLLECTIONS.ZERO_DAY_INDICATORS);
  await zeroDayIndicators.createIndex({ scanId: 1 });
  await zeroDayIndicators.createIndex({ assetId: 1 });
  
  const auditEvents = await getCollection(COLLECTIONS.AUDIT_EVENTS);
  await auditEvents.createIndex({ userId: 1, timestamp: -1 });
  await auditEvents.createIndex({ entityType: 1, entityId: 1 });
  
  console.log('MongoDB initialization complete');
}

export async function healthCheck(): Promise<boolean> {
  try {
    const database = await getDb();
    await database.command({ ping: 1 });
    return true;
  } catch {
    return false;
  }
}

export async function closeConnection(): Promise<void> {
  if (client) {
    await client.close();
    client = null;
    db = null;
    console.log('MongoDB connection closed');
  }
}

export default {
  getClient,
  getDb,
  getCollection,
  storeRawOutput,
  getRawOutput,
  getRawOutputsByScan,
  logScanEvent,
  getScanLogs,
  storeToolOutput,
  getToolOutputs,
  cacheEnrichment,
  getCachedEnrichment,
  storeAttackGraph,
  getAttackGraph,
  storeZeroDayIndicator,
  getZeroDayIndicators,
  logAuditEvent,
  initializeMongoDB,
  healthCheck,
  closeConnection,
};
