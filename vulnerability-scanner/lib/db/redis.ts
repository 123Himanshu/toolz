/**
 * Redis Client
 * Handles job queues, caching, rate limiting, and session management
 */

import { createClient, RedisClientType } from 'redis';

let client: RedisClientType | null = null;

export async function getRedisClient(): Promise<RedisClientType> {
  if (!client) {
    const url = process.env.REDIS_URL || 'redis://localhost:6379';
    
    client = createClient({
      url,
      socket: {
        connectTimeout: 10000,
        reconnectStrategy: (retries) => {
          if (retries > 10) {
            console.error('Redis: Max reconnection attempts reached');
            return new Error('Max reconnection attempts reached');
          }
          return Math.min(retries * 100, 3000);
        }
      }
    });

    client.on('error', (err) => {
      console.error('Redis Client Error:', err);
    });

    client.on('connect', () => {
      console.log('Redis connected');
    });

    client.on('reconnecting', () => {
      console.log('Redis reconnecting...');
    });

    await client.connect();
  }
  return client;
}

// ============================================================================
// CACHING
// ============================================================================

export async function cacheSet(
  key: string, 
  value: any, 
  ttlSeconds: number = 3600
): Promise<void> {
  const redis = await getRedisClient();
  const serialized = JSON.stringify(value);
  await redis.setEx(key, ttlSeconds, serialized);
}

export async function cacheGet<T = any>(key: string): Promise<T | null> {
  const redis = await getRedisClient();
  const value = await redis.get(key);
  
  if (!value) return null;
  
  try {
    return JSON.parse(value) as T;
  } catch {
    return value as unknown as T;
  }
}

export async function cacheDelete(key: string): Promise<void> {
  const redis = await getRedisClient();
  await redis.del(key);
}

export async function cacheDeletePattern(pattern: string): Promise<void> {
  const redis = await getRedisClient();
  const keys = await redis.keys(pattern);
  
  if (keys.length > 0) {
    await redis.del(keys);
  }
}

// ============================================================================
// JOB QUEUE (Simple implementation)
// ============================================================================

const QUEUE_PREFIX = 'queue:';

export interface Job<T = any> {
  id: string;
  type: string;
  data: T;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  priority: number;
  attempts: number;
  maxAttempts: number;
  createdAt: string;
  startedAt?: string;
  completedAt?: string;
  error?: string;
  result?: any;
}

export async function enqueueJob<T>(
  queueName: string,
  type: string,
  data: T,
  options: { priority?: number; maxAttempts?: number } = {}
): Promise<string> {
  const redis = await getRedisClient();
  
  const jobId = `job:${Date.now()}:${Math.random().toString(36).substr(2, 9)}`;
  
  const job: Job<T> = {
    id: jobId,
    type,
    data,
    status: 'pending',
    priority: options.priority || 0,
    attempts: 0,
    maxAttempts: options.maxAttempts || 3,
    createdAt: new Date().toISOString(),
  };
  
  // Store job data
  await redis.hSet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId, JSON.stringify(job));
  
  // Add to queue (sorted set by priority and time)
  const score = (10 - job.priority) * 1e13 + Date.now();
  await redis.zAdd(`${QUEUE_PREFIX}${queueName}:pending`, { score, value: jobId });
  
  return jobId;
}

export async function dequeueJob<T>(queueName: string): Promise<Job<T> | null> {
  const redis = await getRedisClient();
  
  // Get highest priority job
  const jobIds = await redis.zRange(`${QUEUE_PREFIX}${queueName}:pending`, 0, 0);
  
  if (jobIds.length === 0) return null;
  
  const jobId = jobIds[0];
  
  // Remove from pending
  await redis.zRem(`${QUEUE_PREFIX}${queueName}:pending`, jobId);
  
  // Get job data
  const jobData = await redis.hGet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId);
  
  if (!jobData) return null;
  
  const job = JSON.parse(jobData) as Job<T>;
  
  // Update status
  job.status = 'processing';
  job.startedAt = new Date().toISOString();
  job.attempts++;
  
  await redis.hSet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId, JSON.stringify(job));
  
  // Add to processing set
  await redis.sAdd(`${QUEUE_PREFIX}${queueName}:processing`, jobId);
  
  return job;
}

export async function completeJob(
  queueName: string, 
  jobId: string, 
  result?: any
): Promise<void> {
  const redis = await getRedisClient();
  
  const jobData = await redis.hGet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId);
  if (!jobData) return;
  
  const job = JSON.parse(jobData) as Job;
  job.status = 'completed';
  job.completedAt = new Date().toISOString();
  job.result = result;
  
  await redis.hSet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId, JSON.stringify(job));
  await redis.sRem(`${QUEUE_PREFIX}${queueName}:processing`, jobId);
  
  // Move to completed (with TTL)
  await redis.zAdd(`${QUEUE_PREFIX}${queueName}:completed`, { 
    score: Date.now(), 
    value: jobId 
  });
}

export async function failJob(
  queueName: string, 
  jobId: string, 
  error: string
): Promise<void> {
  const redis = await getRedisClient();
  
  const jobData = await redis.hGet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId);
  if (!jobData) return;
  
  const job = JSON.parse(jobData) as Job;
  job.error = error;
  
  await redis.sRem(`${QUEUE_PREFIX}${queueName}:processing`, jobId);
  
  // Retry if attempts remaining
  if (job.attempts < job.maxAttempts) {
    job.status = 'pending';
    await redis.hSet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId, JSON.stringify(job));
    
    // Re-add to pending with delay
    const delay = Math.pow(2, job.attempts) * 1000; // Exponential backoff
    const score = Date.now() + delay;
    await redis.zAdd(`${QUEUE_PREFIX}${queueName}:pending`, { score, value: jobId });
  } else {
    job.status = 'failed';
    job.completedAt = new Date().toISOString();
    await redis.hSet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId, JSON.stringify(job));
    await redis.zAdd(`${QUEUE_PREFIX}${queueName}:failed`, { 
      score: Date.now(), 
      value: jobId 
    });
  }
}

export async function getJob<T>(queueName: string, jobId: string): Promise<Job<T> | null> {
  const redis = await getRedisClient();
  const jobData = await redis.hGet(`${QUEUE_PREFIX}${queueName}:jobs`, jobId);
  
  if (!jobData) return null;
  return JSON.parse(jobData) as Job<T>;
}

export async function getQueueStats(queueName: string): Promise<{
  pending: number;
  processing: number;
  completed: number;
  failed: number;
}> {
  const redis = await getRedisClient();
  
  const [pending, processing, completed, failed] = await Promise.all([
    redis.zCard(`${QUEUE_PREFIX}${queueName}:pending`),
    redis.sCard(`${QUEUE_PREFIX}${queueName}:processing`),
    redis.zCard(`${QUEUE_PREFIX}${queueName}:completed`),
    redis.zCard(`${QUEUE_PREFIX}${queueName}:failed`),
  ]);
  
  return { pending, processing, completed, failed };
}

// ============================================================================
// RATE LIMITING
// ============================================================================

export async function checkRateLimit(
  key: string,
  limit: number,
  windowSeconds: number
): Promise<{ allowed: boolean; remaining: number; resetAt: number }> {
  const redis = await getRedisClient();
  const now = Date.now();
  const windowKey = `ratelimit:${key}:${Math.floor(now / (windowSeconds * 1000))}`;
  
  const count = await redis.incr(windowKey);
  
  if (count === 1) {
    await redis.expire(windowKey, windowSeconds);
  }
  
  const resetAt = (Math.floor(now / (windowSeconds * 1000)) + 1) * windowSeconds * 1000;
  
  return {
    allowed: count <= limit,
    remaining: Math.max(0, limit - count),
    resetAt,
  };
}

// ============================================================================
// SESSION MANAGEMENT
// ============================================================================

const SESSION_PREFIX = 'session:';
const SESSION_TTL = 24 * 60 * 60; // 24 hours

export interface SessionData {
  userId: string;
  email: string;
  role: string;
  createdAt: string;
  lastActivity: string;
  ipAddress?: string;
  userAgent?: string;
}

export async function createSession(
  sessionId: string, 
  data: SessionData
): Promise<void> {
  const redis = await getRedisClient();
  await redis.setEx(
    `${SESSION_PREFIX}${sessionId}`,
    SESSION_TTL,
    JSON.stringify(data)
  );
  
  // Track user sessions
  await redis.sAdd(`user:${data.userId}:sessions`, sessionId);
}

export async function getSession(sessionId: string): Promise<SessionData | null> {
  const redis = await getRedisClient();
  const data = await redis.get(`${SESSION_PREFIX}${sessionId}`);
  
  if (!data) return null;
  
  const session = JSON.parse(data) as SessionData;
  
  // Update last activity
  session.lastActivity = new Date().toISOString();
  await redis.setEx(
    `${SESSION_PREFIX}${sessionId}`,
    SESSION_TTL,
    JSON.stringify(session)
  );
  
  return session;
}

export async function deleteSession(sessionId: string): Promise<void> {
  const redis = await getRedisClient();
  
  // Get session to find user
  const data = await redis.get(`${SESSION_PREFIX}${sessionId}`);
  if (data) {
    const session = JSON.parse(data) as SessionData;
    await redis.sRem(`user:${session.userId}:sessions`, sessionId);
  }
  
  await redis.del(`${SESSION_PREFIX}${sessionId}`);
}

export async function deleteUserSessions(userId: string): Promise<void> {
  const redis = await getRedisClient();
  
  const sessionIds = await redis.sMembers(`user:${userId}:sessions`);
  
  for (const sessionId of sessionIds) {
    await redis.del(`${SESSION_PREFIX}${sessionId}`);
  }
  
  await redis.del(`user:${userId}:sessions`);
}

// ============================================================================
// PUBSUB (for real-time updates)
// ============================================================================

export async function publish(channel: string, message: any): Promise<void> {
  const redis = await getRedisClient();
  await redis.publish(channel, JSON.stringify(message));
}

export async function subscribe(
  channel: string, 
  callback: (message: any) => void
): Promise<void> {
  const subscriber = (await getRedisClient()).duplicate();
  await subscriber.connect();
  
  await subscriber.subscribe(channel, (message) => {
    try {
      callback(JSON.parse(message));
    } catch {
      callback(message);
    }
  });
}

// ============================================================================
// HEALTH & CLEANUP
// ============================================================================

export async function healthCheck(): Promise<boolean> {
  try {
    const redis = await getRedisClient();
    await redis.ping();
    return true;
  } catch {
    return false;
  }
}

export async function closeConnection(): Promise<void> {
  if (client) {
    await client.quit();
    client = null;
    console.log('Redis connection closed');
  }
}

export default {
  getRedisClient,
  cacheSet,
  cacheGet,
  cacheDelete,
  cacheDeletePattern,
  enqueueJob,
  dequeueJob,
  completeJob,
  failJob,
  getJob,
  getQueueStats,
  checkRateLimit,
  createSession,
  getSession,
  deleteSession,
  deleteUserSessions,
  publish,
  subscribe,
  healthCheck,
  closeConnection,
};
