/**
 * Exclusion List Management
 * Manage IPs, domains, and patterns to exclude from scans
 */

import fs from 'fs';
import path from 'path';

export interface ExclusionEntry {
  id: string;
  type: 'ip' | 'cidr' | 'domain' | 'regex';
  value: string;
  reason: string;
  createdAt: string;
  createdBy?: string;
  expiresAt?: string;
  enabled: boolean;
}

export interface ExclusionList {
  id: string;
  name: string;
  description: string;
  entries: ExclusionEntry[];
  isDefault: boolean;
  createdAt: string;
}

const STORAGE_FILE = path.join(process.cwd(), '.scan-data', 'exclusions.json');

// In-memory storage
let exclusionLists: Map<string, ExclusionList> = new Map();

/**
 * Load exclusions from disk
 */
export function loadExclusions(): void {
  try {
    if (fs.existsSync(STORAGE_FILE)) {
      const data = JSON.parse(fs.readFileSync(STORAGE_FILE, 'utf-8'));
      exclusionLists = new Map(data.map((list: ExclusionList) => [list.id, list]));
      console.log(`Loaded ${exclusionLists.size} exclusion lists`);
    } else {
      // Create default list
      createDefaultList();
    }
  } catch (error) {
    console.error('Failed to load exclusions:', error);
    createDefaultList();
  }
}

/**
 * Save exclusions to disk
 */
function saveExclusions(): void {
  try {
    const dir = path.dirname(STORAGE_FILE);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(STORAGE_FILE, JSON.stringify(Array.from(exclusionLists.values()), null, 2));
  } catch (error) {
    console.error('Failed to save exclusions:', error);
  }
}

/**
 * Create default exclusion list
 */
function createDefaultList(): void {
  const defaultList: ExclusionList = {
    id: 'default',
    name: 'Default Exclusions',
    description: 'Default list of excluded targets',
    entries: [
      {
        id: 'localhost-ipv4',
        type: 'ip',
        value: '127.0.0.1',
        reason: 'Localhost',
        createdAt: new Date().toISOString(),
        enabled: true
      },
      {
        id: 'localhost-ipv6',
        type: 'ip',
        value: '::1',
        reason: 'Localhost IPv6',
        createdAt: new Date().toISOString(),
        enabled: true
      },
      {
        id: 'private-10',
        type: 'cidr',
        value: '10.0.0.0/8',
        reason: 'Private network (optional)',
        createdAt: new Date().toISOString(),
        enabled: false
      },
      {
        id: 'private-172',
        type: 'cidr',
        value: '172.16.0.0/12',
        reason: 'Private network (optional)',
        createdAt: new Date().toISOString(),
        enabled: false
      },
      {
        id: 'private-192',
        type: 'cidr',
        value: '192.168.0.0/16',
        reason: 'Private network (optional)',
        createdAt: new Date().toISOString(),
        enabled: false
      }
    ],
    isDefault: true,
    createdAt: new Date().toISOString()
  };
  
  exclusionLists.set('default', defaultList);
  saveExclusions();
}

/**
 * Get all exclusion lists
 */
export function getAllExclusionLists(): ExclusionList[] {
  return Array.from(exclusionLists.values());
}

/**
 * Get exclusion list by ID
 */
export function getExclusionList(id: string): ExclusionList | null {
  return exclusionLists.get(id) || null;
}

/**
 * Create new exclusion list
 */
export function createExclusionList(
  name: string,
  description: string,
  entries: Omit<ExclusionEntry, 'id' | 'createdAt'>[] = []
): ExclusionList {
  const id = `list-${Date.now()}`;
  const list: ExclusionList = {
    id,
    name,
    description,
    entries: entries.map((e, i) => ({
      ...e,
      id: `${id}-entry-${i}`,
      createdAt: new Date().toISOString()
    })),
    isDefault: false,
    createdAt: new Date().toISOString()
  };
  
  exclusionLists.set(id, list);
  saveExclusions();
  return list;
}

/**
 * Add entry to exclusion list
 */
export function addExclusionEntry(
  listId: string,
  entry: Omit<ExclusionEntry, 'id' | 'createdAt'>
): ExclusionEntry | null {
  const list = exclusionLists.get(listId);
  if (!list) return null;
  
  const newEntry: ExclusionEntry = {
    ...entry,
    id: `${listId}-entry-${Date.now()}`,
    createdAt: new Date().toISOString()
  };
  
  list.entries.push(newEntry);
  saveExclusions();
  return newEntry;
}

/**
 * Remove entry from exclusion list
 */
export function removeExclusionEntry(listId: string, entryId: string): boolean {
  const list = exclusionLists.get(listId);
  if (!list) return false;
  
  const index = list.entries.findIndex(e => e.id === entryId);
  if (index === -1) return false;
  
  list.entries.splice(index, 1);
  saveExclusions();
  return true;
}

/**
 * Toggle entry enabled status
 */
export function toggleExclusionEntry(listId: string, entryId: string): boolean {
  const list = exclusionLists.get(listId);
  if (!list) return false;
  
  const entry = list.entries.find(e => e.id === entryId);
  if (!entry) return false;
  
  entry.enabled = !entry.enabled;
  saveExclusions();
  return true;
}

/**
 * Delete exclusion list
 */
export function deleteExclusionList(id: string): boolean {
  if (id === 'default') return false; // Can't delete default
  const deleted = exclusionLists.delete(id);
  if (deleted) saveExclusions();
  return deleted;
}

/**
 * Check if a target should be excluded
 */
export function shouldExclude(target: string, listIds?: string[]): { excluded: boolean; reason?: string } {
  const listsToCheck = listIds 
    ? listIds.map(id => exclusionLists.get(id)).filter(Boolean) as ExclusionList[]
    : Array.from(exclusionLists.values());
  
  for (const list of listsToCheck) {
    for (const entry of list.entries) {
      if (!entry.enabled) continue;
      
      // Check expiration
      if (entry.expiresAt && new Date(entry.expiresAt) < new Date()) continue;
      
      if (matchesExclusion(target, entry)) {
        return { excluded: true, reason: entry.reason };
      }
    }
  }
  
  return { excluded: false };
}

/**
 * Check if target matches exclusion entry
 */
function matchesExclusion(target: string, entry: ExclusionEntry): boolean {
  const cleanTarget = target.toLowerCase().replace(/^https?:\/\//, '').split('/')[0];
  
  switch (entry.type) {
    case 'ip':
      return cleanTarget === entry.value.toLowerCase();
      
    case 'domain':
      return cleanTarget === entry.value.toLowerCase() || 
             cleanTarget.endsWith('.' + entry.value.toLowerCase());
      
    case 'cidr':
      return isIpInCidr(cleanTarget, entry.value);
      
    case 'regex':
      try {
        return new RegExp(entry.value, 'i').test(cleanTarget);
      } catch {
        return false;
      }
      
    default:
      return false;
  }
}

/**
 * Check if IP is in CIDR range
 */
function isIpInCidr(ip: string, cidr: string): boolean {
  try {
    const [range, bits] = cidr.split('/');
    const mask = parseInt(bits, 10);
    
    const ipNum = ipToNumber(ip);
    const rangeNum = ipToNumber(range);
    
    if (ipNum === null || rangeNum === null) return false;
    
    const maskNum = ~((1 << (32 - mask)) - 1);
    return (ipNum & maskNum) === (rangeNum & maskNum);
  } catch {
    return false;
  }
}

/**
 * Convert IP to number
 */
function ipToNumber(ip: string): number | null {
  const parts = ip.split('.');
  if (parts.length !== 4) return null;
  
  let num = 0;
  for (const part of parts) {
    const n = parseInt(part, 10);
    if (isNaN(n) || n < 0 || n > 255) return null;
    num = (num << 8) + n;
  }
  return num >>> 0;
}

/**
 * Filter targets based on exclusions
 */
export function filterTargets(targets: string[], listIds?: string[]): {
  allowed: string[];
  excluded: { target: string; reason: string }[];
} {
  const allowed: string[] = [];
  const excluded: { target: string; reason: string }[] = [];
  
  for (const target of targets) {
    const result = shouldExclude(target, listIds);
    if (result.excluded) {
      excluded.push({ target, reason: result.reason || 'Excluded' });
    } else {
      allowed.push(target);
    }
  }
  
  return { allowed, excluded };
}

// Load on module init
loadExclusions();

export default {
  getAllExclusionLists,
  getExclusionList,
  createExclusionList,
  addExclusionEntry,
  removeExclusionEntry,
  toggleExclusionEntry,
  deleteExclusionList,
  shouldExclude,
  filterTargets,
  loadExclusions
};
