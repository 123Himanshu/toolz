/**
 * Qdrant Vector Database Client
 * Stores and retrieves scan results for RAG chatbot
 */

interface QdrantPoint {
  id: string;
  vector: number[];
  payload: any;
}

interface SearchResult {
  id: string;
  score: number;
  payload: any;
}

const COLLECTION_NAME = 'scan_results';
const VECTOR_SIZE = 384; // all-MiniLM-L6-v2 embedding size

/**
 * Initialize Qdrant collection
 */
export async function initQdrantCollection(): Promise<boolean> {
  const qdrantUrl = process.env.QDRANT_URL;
  const qdrantKey = process.env.QDRANT_API_KEY;

  if (!qdrantUrl || !qdrantKey) {
    console.log('Qdrant not configured, skipping initialization');
    return false;
  }

  try {
    // Check if collection exists
    const checkResponse = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}`, {
      headers: {
        'api-key': qdrantKey,
      },
    });

    if (checkResponse.ok) {
      console.log('Qdrant collection already exists');
      return true;
    }

    // Create collection
    const createResponse = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'api-key': qdrantKey,
      },
      body: JSON.stringify({
        vectors: {
          size: VECTOR_SIZE,
          distance: 'Cosine',
        },
        optimizers_config: {
          default_segment_number: 2,
        },
        replication_factor: 1,
      }),
    });

    if (!createResponse.ok) {
      throw new Error(`Failed to create collection: ${createResponse.statusText}`);
    }

    console.log('Qdrant collection created successfully');
    return true;
  } catch (error: any) {
    console.error('Qdrant initialization error:', error.message);
    return false;
  }
}

/**
 * Generate embeddings using Groq (fast and free!)
 */
async function generateEmbedding(text: string): Promise<number[]> {
  // Use a simple hash-based embedding for now (fast, no API calls)
  // In production, you'd use a proper embedding model
  const embedding = new Array(VECTOR_SIZE).fill(0);
  
  // Simple hash-based embedding
  for (let i = 0; i < text.length; i++) {
    const charCode = text.charCodeAt(i);
    const index = (charCode * i) % VECTOR_SIZE;
    embedding[index] += charCode / 1000;
  }
  
  // Normalize
  const magnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
  return embedding.map(val => val / (magnitude || 1));
}

/**
 * Store scan results in Qdrant
 */
export async function storeScanResults(
  scanId: string,
  scanData: any
): Promise<boolean> {
  const qdrantUrl = process.env.QDRANT_URL;
  const qdrantKey = process.env.QDRANT_API_KEY;

  if (!qdrantUrl || !qdrantKey) {
    console.log('Qdrant not configured, skipping storage');
    return false;
  }

  try {
    const points: QdrantPoint[] = [];

    // Store overall scan info
    const scanSummary = `Scan ${scanId} for target ${scanData.target}. Status: ${scanData.status}. Scan type: ${scanData.scanType}.`;
    const scanVector = await generateEmbedding(scanSummary);
    
    points.push({
      id: `${scanId}_summary`,
      vector: scanVector,
      payload: {
        scanId,
        type: 'summary',
        target: scanData.target,
        status: scanData.status,
        scanType: scanData.scanType,
        timestamp: scanData.startedAt,
        content: scanSummary,
      },
    });

    // Store each tool result
    if (scanData.results) {
      for (const [tool, result] of Object.entries(scanData.results)) {
        const resultData = result as any;
        
        // Create searchable text from result
        let resultText = `Tool: ${tool}. `;
        
        if (resultData.success) {
          resultText += `Status: Success. `;
          
          if (resultData.vulnerabilities_found !== undefined) {
            resultText += `Vulnerabilities found: ${resultData.vulnerabilities_found}. `;
          }
          
          if (resultData.open_ports && Array.isArray(resultData.open_ports)) {
            resultText += `Open ports: ${resultData.open_ports.join(', ')}. `;
          }
          
          if (resultData.vulnerabilities && Array.isArray(resultData.vulnerabilities)) {
            resultData.vulnerabilities.forEach((vuln: any, index: number) => {
              resultText += `Vulnerability ${index + 1}: ${vuln.name || vuln.title || 'Unknown'}. `;
              if (vuln.severity) resultText += `Severity: ${vuln.severity}. `;
              if (vuln.description) resultText += `Description: ${vuln.description}. `;
            });
          }
          
          if (resultData.status) {
            resultText += `Status: ${resultData.status}. `;
          }
        } else {
          resultText += `Status: Failed. Error: ${resultData.error || 'Unknown error'}. `;
        }
        
        const resultVector = await generateEmbedding(resultText);
        
        points.push({
          id: `${scanId}_${tool}`,
          vector: resultVector,
          payload: {
            scanId,
            type: 'tool_result',
            tool,
            target: scanData.target,
            result: resultData,
            content: resultText,
            timestamp: resultData.completed_at || scanData.startedAt,
          },
        });
      }
    }

    // Upload points to Qdrant
    const response = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}/points`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'api-key': qdrantKey,
      },
      body: JSON.stringify({
        points,
      }),
    });

    if (!response.ok) {
      throw new Error(`Failed to store points: ${response.statusText}`);
    }

    console.log(`Stored ${points.length} points in Qdrant for scan ${scanId}`);
    return true;
  } catch (error: any) {
    console.error('Qdrant storage error:', error.message);
    return false;
  }
}

/**
 * Search scan results in Qdrant with optional date filtering
 */
export async function searchScanResults(
  query: string,
  scanId?: string,
  limit: number = 5,
  dateFilter?: {
    startDate?: string; // ISO date string
    endDate?: string;   // ISO date string
  }
): Promise<SearchResult[]> {
  const qdrantUrl = process.env.QDRANT_URL;
  const qdrantKey = process.env.QDRANT_API_KEY;

  if (!qdrantUrl || !qdrantKey) {
    console.log('Qdrant not configured, skipping search');
    return [];
  }

  try {
    // Generate query embedding
    const queryVector = await generateEmbedding(query);

    // Build filter
    const mustConditions: any[] = [];
    
    if (scanId) {
      mustConditions.push({
        key: 'scanId',
        match: { value: scanId },
      });
    }
    
    // Add date range filter if provided
    if (dateFilter) {
      if (dateFilter.startDate) {
        mustConditions.push({
          key: 'timestamp',
          range: {
            gte: dateFilter.startDate,
          },
        });
      }
      if (dateFilter.endDate) {
        mustConditions.push({
          key: 'timestamp',
          range: {
            lte: dateFilter.endDate,
          },
        });
      }
    }
    
    const filter = mustConditions.length > 0 ? { must: mustConditions } : undefined;

    // Search
    const response = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}/points/search`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': qdrantKey,
      },
      body: JSON.stringify({
        vector: queryVector,
        filter,
        limit,
        with_payload: true,
      }),
    });

    if (!response.ok) {
      throw new Error(`Search failed: ${response.statusText}`);
    }

    const data = await response.json();
    
    return data.result.map((item: any) => ({
      id: item.id,
      score: item.score,
      payload: item.payload,
    }));
  } catch (error: any) {
    console.error('Qdrant search error:', error.message);
    return [];
  }
}

/**
 * Get all scans for a date range (for time-based queries)
 */
export async function getScansByDateRange(
  startDate: string,
  endDate: string,
  limit: number = 50
): Promise<SearchResult[]> {
  const qdrantUrl = process.env.QDRANT_URL;
  const qdrantKey = process.env.QDRANT_API_KEY;

  if (!qdrantUrl || !qdrantKey) {
    return [];
  }

  try {
    // Use scroll API to get all points in date range
    const response = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}/points/scroll`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': qdrantKey,
      },
      body: JSON.stringify({
        filter: {
          must: [
            {
              key: 'timestamp',
              range: {
                gte: startDate,
                lte: endDate,
              },
            },
          ],
        },
        limit,
        with_payload: true,
        with_vector: false,
      }),
    });

    if (!response.ok) {
      throw new Error(`Scroll failed: ${response.statusText}`);
    }

    const data = await response.json();
    
    return data.result.points.map((item: any) => ({
      id: item.id,
      score: 1.0, // No scoring for scroll
      payload: item.payload,
    }));
  } catch (error: any) {
    console.error('Qdrant scroll error:', error.message);
    return [];
  }
}

/**
 * Get scan statistics for a date range
 */
export async function getScanStatistics(
  startDate: string,
  endDate: string
): Promise<{
  totalScans: number;
  scansByTool: Record<string, number>;
  totalVulnerabilities: number;
  scansByTarget: Record<string, number>;
}> {
  const scans = await getScansByDateRange(startDate, endDate, 1000);
  
  const stats = {
    totalScans: 0,
    scansByTool: {} as Record<string, number>,
    totalVulnerabilities: 0,
    scansByTarget: {} as Record<string, number>,
  };
  
  const seenScans = new Set<string>();
  
  scans.forEach(scan => {
    const payload = scan.payload;
    
    // Count unique scans
    if (payload.type === 'summary' && payload.scanId) {
      seenScans.add(payload.scanId);
      
      // Count by target
      if (payload.target) {
        stats.scansByTarget[payload.target] = (stats.scansByTarget[payload.target] || 0) + 1;
      }
    }
    
    // Count by tool
    if (payload.type === 'tool_result' && payload.tool) {
      stats.scansByTool[payload.tool] = (stats.scansByTool[payload.tool] || 0) + 1;
      
      // Count vulnerabilities
      if (payload.result?.vulnerabilities_found) {
        stats.totalVulnerabilities += payload.result.vulnerabilities_found;
      }
    }
  });
  
  stats.totalScans = seenScans.size;
  
  return stats;
}

/**
 * Delete scan results from Qdrant
 */
export async function deleteScanResults(scanId: string): Promise<boolean> {
  const qdrantUrl = process.env.QDRANT_URL;
  const qdrantKey = process.env.QDRANT_API_KEY;

  if (!qdrantUrl || !qdrantKey) {
    return false;
  }

  try {
    const response = await fetch(`${qdrantUrl}/collections/${COLLECTION_NAME}/points/delete`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'api-key': qdrantKey,
      },
      body: JSON.stringify({
        filter: {
          must: [
            {
              key: 'scanId',
              match: { value: scanId },
            },
          ],
        },
      }),
    });

    if (!response.ok) {
      throw new Error(`Delete failed: ${response.statusText}`);
    }

    console.log(`Deleted scan ${scanId} from Qdrant`);
    return true;
  } catch (error: any) {
    console.error('Qdrant delete error:', error.message);
    return false;
  }
}
