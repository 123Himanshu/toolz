/**
 * Scan Scheduler
 * Cron-based scan scheduling and management
 */

import { v4 as uuidv4 } from 'uuid';

export interface ScheduledScan {
  id: string;
  name: string;
  target: string;
  scanType: 'passive' | 'active' | 'both';
  tools: {
    network: string[];
    web: string[];
    system: string[];
  };
  config: {
    intensity: string;
    rate: number;
    depth: number;
    timeout: number;
  };
  schedule: {
    type: 'once' | 'daily' | 'weekly' | 'monthly' | 'custom';
    time: string; // HH:MM format
    dayOfWeek?: number; // 0-6 for weekly
    dayOfMonth?: number; // 1-31 for monthly
    cronExpression?: string; // For custom
    timezone: string;
  };
  exclusions: string[]; // IPs/domains to exclude
  enabled: boolean;
  lastRun?: string;
  nextRun?: string;
  runCount: number;
  createdAt: string;
  createdBy?: string;
}

export interface SchedulerStorage {
  schedules: Map<string, ScheduledScan>;
}

// In-memory storage (would use Redis/DB in production)
const storage: SchedulerStorage = {
  schedules: new Map()
};

/**
 * Create a new scheduled scan
 */
export function createScheduledScan(
  data: Omit<ScheduledScan, 'id' | 'createdAt' | 'runCount' | 'nextRun'>
): ScheduledScan {
  const schedule: ScheduledScan = {
    ...data,
    id: uuidv4(),
    createdAt: new Date().toISOString(),
    runCount: 0,
    nextRun: calculateNextRun(data.schedule)
  };
  
  storage.schedules.set(schedule.id, schedule);
  saveSchedulesToDisk();
  
  return schedule;
}

/**
 * Update a scheduled scan
 */
export function updateScheduledScan(
  id: string,
  updates: Partial<ScheduledScan>
): ScheduledScan | null {
  const existing = storage.schedules.get(id);
  if (!existing) return null;
  
  const updated = { ...existing, ...updates };
  
  // Recalculate next run if schedule changed
  if (updates.schedule) {
    updated.nextRun = calculateNextRun(updated.schedule);
  }
  
  storage.schedules.set(id, updated);
  saveSchedulesToDisk();
  
  return updated;
}

/**
 * Delete a scheduled scan
 */
export function deleteScheduledScan(id: string): boolean {
  const deleted = storage.schedules.delete(id);
  if (deleted) saveSchedulesToDisk();
  return deleted;
}

/**
 * Get all scheduled scans
 */
export function getAllScheduledScans(): ScheduledScan[] {
  return Array.from(storage.schedules.values());
}

/**
 * Get scheduled scan by ID
 */
export function getScheduledScan(id: string): ScheduledScan | null {
  return storage.schedules.get(id) || null;
}

/**
 * Get scans due to run
 */
export function getDueScans(): ScheduledScan[] {
  const now = new Date();
  return Array.from(storage.schedules.values()).filter(scan => {
    if (!scan.enabled || !scan.nextRun) return false;
    return new Date(scan.nextRun) <= now;
  });
}

/**
 * Mark scan as executed and calculate next run
 */
export function markScanExecuted(id: string, scanId: string): void {
  const schedule = storage.schedules.get(id);
  if (!schedule) return;
  
  schedule.lastRun = new Date().toISOString();
  schedule.runCount++;
  
  // Calculate next run (skip for 'once' type)
  if (schedule.schedule.type !== 'once') {
    schedule.nextRun = calculateNextRun(schedule.schedule, new Date());
  } else {
    schedule.enabled = false;
    schedule.nextRun = undefined;
  }
  
  storage.schedules.set(id, schedule);
  saveSchedulesToDisk();
}

/**
 * Calculate next run time based on schedule
 */
function calculateNextRun(
  schedule: ScheduledScan['schedule'],
  fromDate: Date = new Date()
): string {
  const [hours, minutes] = schedule.time.split(':').map(Number);
  const next = new Date(fromDate);
  
  // Set time
  next.setHours(hours, minutes, 0, 0);
  
  // If time already passed today, start from tomorrow
  if (next <= fromDate) {
    next.setDate(next.getDate() + 1);
  }
  
  switch (schedule.type) {
    case 'once':
      // Already set
      break;
      
    case 'daily':
      // Already set (next occurrence at specified time)
      break;
      
    case 'weekly':
      const targetDay = schedule.dayOfWeek ?? 1; // Default Monday
      while (next.getDay() !== targetDay) {
        next.setDate(next.getDate() + 1);
      }
      break;
      
    case 'monthly':
      const targetDate = schedule.dayOfMonth ?? 1;
      next.setDate(targetDate);
      if (next <= fromDate) {
        next.setMonth(next.getMonth() + 1);
      }
      break;
      
    case 'custom':
      // Parse cron expression (simplified)
      // For now, default to daily
      break;
  }
  
  return next.toISOString();
}

/**
 * Save schedules to disk
 */
function saveSchedulesToDisk(): void {
  try {
    const fs = require('fs');
    const path = require('path');
    const dir = path.join(process.cwd(), '.scan-data');
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    const data = Array.from(storage.schedules.values());
    fs.writeFileSync(
      path.join(dir, 'schedules.json'),
      JSON.stringify(data, null, 2)
    );
  } catch (error) {
    console.error('Failed to save schedules:', error);
  }
}

/**
 * Load schedules from disk
 */
export function loadSchedulesFromDisk(): void {
  try {
    const fs = require('fs');
    const path = require('path');
    const filePath = path.join(process.cwd(), '.scan-data', 'schedules.json');
    
    if (fs.existsSync(filePath)) {
      const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
      storage.schedules.clear();
      for (const schedule of data) {
        storage.schedules.set(schedule.id, schedule);
      }
      console.log(`Loaded ${data.length} scheduled scans`);
    }
  } catch (error) {
    console.error('Failed to load schedules:', error);
  }
}

// Load on module init
loadSchedulesFromDisk();

export default {
  createScheduledScan,
  updateScheduledScan,
  deleteScheduledScan,
  getAllScheduledScans,
  getScheduledScan,
  getDueScans,
  markScanExecuted,
  loadSchedulesFromDisk
};
