/**
 * Authentication System
 * Handles user registration, login, JWT tokens, and session management
 */

import { query, queryOne } from '../db/postgres';
import { createSession, getSession, deleteSession, deleteUserSessions } from '../db/redis';
import { logAuditEvent } from '../db/mongodb';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';

const JWT_SECRET = process.env.JWT_SECRET || 'vulnerability-scanner-jwt-secret-key-2024';
const JWT_EXPIRES_IN = '24h';
const SALT_ROUNDS = 10;

// ============================================================================
// TYPES
// ============================================================================

export interface User {
  id: string;
  email: string;
  name: string | null;
  role: 'admin' | 'analyst' | 'viewer';
  createdAt: Date;
  updatedAt: Date;
  lastLogin: Date | null;
  isActive: boolean;
}

export interface AuthResult {
  success: boolean;
  user?: User;
  token?: string;
  sessionId?: string;
  error?: string;
}

export interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  sessionId: string;
  iat: number;
  exp: number;
}

// ============================================================================
// PASSWORD HASHING
// ============================================================================

function hashPassword(password: string): string {
  const salt = crypto.randomBytes(16).toString('hex');
  const hash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
  return `${salt}:${hash}`;
}

function verifyPassword(password: string, storedHash: string): boolean {
  const [salt, hash] = storedHash.split(':');
  const verifyHash = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');
  return hash === verifyHash;
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

export async function createUser(
  email: string,
  password: string,
  name?: string,
  role: 'admin' | 'analyst' | 'viewer' = 'analyst'
): Promise<AuthResult> {
  try {
    // Check if user exists
    const existing = await queryOne<User>(
      'SELECT id FROM users WHERE email = $1',
      [email.toLowerCase()]
    );

    if (existing) {
      return { success: false, error: 'User with this email already exists' };
    }

    // Validate password
    if (password.length < 8) {
      return { success: false, error: 'Password must be at least 8 characters' };
    }

    // Hash password
    const passwordHash = hashPassword(password);

    // Create user
    const result = await queryOne<User>(
      `INSERT INTO users (email, password_hash, name, role)
       VALUES ($1, $2, $3, $4)
       RETURNING id, email, name, role, created_at as "createdAt", 
                 updated_at as "updatedAt", last_login as "lastLogin", is_active as "isActive"`,
      [email.toLowerCase(), passwordHash, name || null, role]
    );

    if (!result) {
      return { success: false, error: 'Failed to create user' };
    }

    // Log audit event
    await logAuditEvent({
      action: 'USER_CREATED',
      entityType: 'user',
      entityId: result.id,
      details: { email: result.email, role: result.role },
    });

    return { success: true, user: result };
  } catch (error) {
    console.error('Create user error:', error);
    return { success: false, error: 'Failed to create user' };
  }
}

export async function getUserById(userId: string): Promise<User | null> {
  return queryOne<User>(
    `SELECT id, email, name, role, created_at as "createdAt", 
            updated_at as "updatedAt", last_login as "lastLogin", is_active as "isActive"
     FROM users WHERE id = $1 AND is_active = true`,
    [userId]
  );
}

export async function getUserByEmail(email: string): Promise<User | null> {
  return queryOne<User>(
    `SELECT id, email, name, role, created_at as "createdAt", 
            updated_at as "updatedAt", last_login as "lastLogin", is_active as "isActive"
     FROM users WHERE email = $1 AND is_active = true`,
    [email.toLowerCase()]
  );
}

// ============================================================================
// AUTHENTICATION
// ============================================================================

export async function login(
  email: string,
  password: string,
  ipAddress?: string,
  userAgent?: string
): Promise<AuthResult> {
  try {
    // Get user with password hash
    const user = await queryOne<User & { password_hash: string }>(
      `SELECT id, email, name, role, password_hash, created_at as "createdAt", 
              updated_at as "updatedAt", last_login as "lastLogin", is_active as "isActive"
       FROM users WHERE email = $1`,
      [email.toLowerCase()]
    );

    if (!user) {
      return { success: false, error: 'Invalid email or password' };
    }

    if (!user.isActive) {
      return { success: false, error: 'Account is disabled' };
    }

    // Verify password
    if (!verifyPassword(password, user.password_hash)) {
      // Log failed attempt
      await logAuditEvent({
        action: 'LOGIN_FAILED',
        entityType: 'user',
        entityId: user.id,
        details: { reason: 'invalid_password' },
        ipAddress,
        userAgent,
      });
      return { success: false, error: 'Invalid email or password' };
    }

    // Generate session ID
    const sessionId = crypto.randomUUID();

    // Create JWT token
    const token = jwt.sign(
      {
        userId: user.id,
        email: user.email,
        role: user.role,
        sessionId,
      },
      JWT_SECRET,
      { expiresIn: JWT_EXPIRES_IN }
    );

    // Create session in Redis
    await createSession(sessionId, {
      userId: user.id,
      email: user.email,
      role: user.role,
      createdAt: new Date().toISOString(),
      lastActivity: new Date().toISOString(),
      ipAddress,
      userAgent,
    });

    // Update last login
    await query(
      'UPDATE users SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
      [user.id]
    );

    // Log successful login
    await logAuditEvent({
      userId: user.id,
      action: 'LOGIN_SUCCESS',
      entityType: 'user',
      entityId: user.id,
      details: { sessionId },
      ipAddress,
      userAgent,
    });

    // Remove password hash from response
    const { password_hash, ...userWithoutPassword } = user;

    return {
      success: true,
      user: userWithoutPassword as User,
      token,
      sessionId,
    };
  } catch (error) {
    console.error('Login error:', error);
    return { success: false, error: 'Login failed' };
  }
}

export async function logout(
  sessionId: string,
  userId?: string
): Promise<{ success: boolean }> {
  try {
    await deleteSession(sessionId);

    if (userId) {
      await logAuditEvent({
        userId,
        action: 'LOGOUT',
        entityType: 'session',
        entityId: sessionId,
        details: {},
      });
    }

    return { success: true };
  } catch (error) {
    console.error('Logout error:', error);
    return { success: false };
  }
}

export async function logoutAllSessions(userId: string): Promise<{ success: boolean }> {
  try {
    await deleteUserSessions(userId);

    await logAuditEvent({
      userId,
      action: 'LOGOUT_ALL_SESSIONS',
      entityType: 'user',
      entityId: userId,
      details: {},
    });

    return { success: true };
  } catch (error) {
    console.error('Logout all sessions error:', error);
    return { success: false };
  }
}

// ============================================================================
// TOKEN VERIFICATION
// ============================================================================

export async function verifyToken(token: string): Promise<{
  valid: boolean;
  payload?: TokenPayload;
  user?: User;
  error?: string;
}> {
  try {
    // Verify JWT
    const payload = jwt.verify(token, JWT_SECRET) as TokenPayload;

    // Check session in Redis
    const session = await getSession(payload.sessionId);

    if (!session) {
      return { valid: false, error: 'Session expired or invalid' };
    }

    // Get user
    const user = await getUserById(payload.userId);

    if (!user) {
      return { valid: false, error: 'User not found' };
    }

    if (!user.isActive) {
      return { valid: false, error: 'Account is disabled' };
    }

    return { valid: true, payload, user };
  } catch (error: any) {
    if (error.name === 'TokenExpiredError') {
      return { valid: false, error: 'Token expired' };
    }
    if (error.name === 'JsonWebTokenError') {
      return { valid: false, error: 'Invalid token' };
    }
    return { valid: false, error: 'Token verification failed' };
  }
}

// ============================================================================
// PASSWORD MANAGEMENT
// ============================================================================

export async function changePassword(
  userId: string,
  currentPassword: string,
  newPassword: string
): Promise<{ success: boolean; error?: string }> {
  try {
    // Get user with password hash
    const user = await queryOne<{ password_hash: string }>(
      'SELECT password_hash FROM users WHERE id = $1',
      [userId]
    );

    if (!user) {
      return { success: false, error: 'User not found' };
    }

    // Verify current password
    if (!verifyPassword(currentPassword, user.password_hash)) {
      return { success: false, error: 'Current password is incorrect' };
    }

    // Validate new password
    if (newPassword.length < 8) {
      return { success: false, error: 'New password must be at least 8 characters' };
    }

    // Hash new password
    const newPasswordHash = hashPassword(newPassword);

    // Update password
    await query(
      'UPDATE users SET password_hash = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2',
      [newPasswordHash, userId]
    );

    // Invalidate all sessions
    await deleteUserSessions(userId);

    // Log audit event
    await logAuditEvent({
      userId,
      action: 'PASSWORD_CHANGED',
      entityType: 'user',
      entityId: userId,
      details: {},
    });

    return { success: true };
  } catch (error) {
    console.error('Change password error:', error);
    return { success: false, error: 'Failed to change password' };
  }
}

export async function resetPassword(
  email: string
): Promise<{ success: boolean; resetToken?: string; error?: string }> {
  try {
    const user = await getUserByEmail(email);

    if (!user) {
      // Don't reveal if user exists
      return { success: true };
    }

    // Generate reset token
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenHash = crypto.createHash('sha256').update(resetToken).digest('hex');
    const expiresAt = new Date(Date.now() + 3600000); // 1 hour

    // Store reset token (in production, store in DB)
    // For now, we'll return it directly (in production, send via email)

    await logAuditEvent({
      userId: user.id,
      action: 'PASSWORD_RESET_REQUESTED',
      entityType: 'user',
      entityId: user.id,
      details: {},
    });

    return { success: true, resetToken };
  } catch (error) {
    console.error('Reset password error:', error);
    return { success: false, error: 'Failed to initiate password reset' };
  }
}

// ============================================================================
// ROLE-BASED ACCESS CONTROL
// ============================================================================

export const PERMISSIONS = {
  admin: ['*'],
  analyst: [
    'scan:create', 'scan:read', 'scan:update',
    'vulnerability:read', 'vulnerability:update',
    'asset:read',
    'report:create', 'report:read',
    'chat:use',
  ],
  viewer: [
    'scan:read',
    'vulnerability:read',
    'asset:read',
    'report:read',
    'chat:use',
  ],
} as const;

export function hasPermission(role: string, permission: string): boolean {
  const rolePermissions = PERMISSIONS[role as keyof typeof PERMISSIONS];
  
  if (!rolePermissions) return false;
  if (rolePermissions.includes('*')) return true;
  
  return rolePermissions.includes(permission as any);
}

export function requirePermission(role: string, permission: string): void {
  if (!hasPermission(role, permission)) {
    throw new Error(`Permission denied: ${permission}`);
  }
}

// ============================================================================
// MIDDLEWARE HELPERS
// ============================================================================

export function extractTokenFromHeader(authHeader?: string): string | null {
  if (!authHeader) return null;
  
  if (authHeader.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }
  
  return null;
}

export default {
  createUser,
  getUserById,
  getUserByEmail,
  login,
  logout,
  logoutAllSessions,
  verifyToken,
  changePassword,
  resetPassword,
  hasPermission,
  requirePermission,
  extractTokenFromHeader,
};
