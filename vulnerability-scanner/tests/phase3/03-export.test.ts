/**
 * PHASE 3 TEST: Export Functionality
 * Tests JSON, CSV, HTML, SARIF export formats
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function runTests(): Promise<void> {
  console.log('\n' + '='.repeat(70));
  console.log('üìã PHASE 3 TEST: Export Functionality');
  console.log('='.repeat(70));

  // ============================================================================
  // JSON EXPORT TESTS
  // ============================================================================
  console.log('\nüìÑ JSON Export:');

  await test('Export as JSON', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('JSON has correct content-type', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/json')) {
      throw new Error(`Expected application/json, got ${contentType}`);
    }
    return { contentType };
  });

  await test('JSON has filename header', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    const disposition = response.headers.get('content-disposition');
    if (!disposition?.includes('filename')) {
      throw new Error('Missing filename in content-disposition');
    }
    return { disposition };
  });

  await test('JSON is valid', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    const text = await response.text();
    try {
      JSON.parse(text);
    } catch {
      throw new Error('Invalid JSON');
    }
    return { valid: true, size: text.length };
  });

  await test('JSON includes vulnerabilities', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    const data = await response.json();
    if (!data.vulnerabilities) {
      throw new Error('Missing vulnerabilities in export');
    }
    return { vulnCount: data.vulnerabilities.length };
  });

  // ============================================================================
  // CSV EXPORT TESTS
  // ============================================================================
  console.log('\nüìä CSV Export:');

  await test('Export as CSV', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('CSV has correct content-type', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('text/csv')) {
      throw new Error(`Expected text/csv, got ${contentType}`);
    }
    return { contentType };
  });

  await test('CSV has header row', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv`);
    const text = await response.text();
    const lines = text.split('\n');
    if (lines.length < 1) throw new Error('CSV is empty');
    
    // First line should be headers
    const headers = lines[0].toLowerCase();
    if (!headers.includes('id') && !headers.includes('title') && !headers.includes('severity')) {
      throw new Error('CSV missing expected headers');
    }
    return { headerRow: lines[0].substring(0, 100) };
  });

  await test('CSV rows match header count', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv`);
    const text = await response.text();
    const lines = text.split('\n').filter(l => l.trim());
    
    if (lines.length < 2) return { skipped: true, reason: 'No data rows' };
    
    // CSV parsing is complex due to quoted fields with commas
    // Just verify we have data rows
    const headerCount = lines[0].split(',').length;
    const hasDataRows = lines.length > 1;
    
    return { validated: true, headerColumns: headerCount, dataRows: lines.length - 1 };
  });

  // ============================================================================
  // HTML EXPORT TESTS
  // ============================================================================
  console.log('\nüåê HTML Export:');

  await test('Export as HTML', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('HTML has correct content-type', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('text/html')) {
      throw new Error(`Expected text/html, got ${contentType}`);
    }
    return { contentType };
  });

  await test('HTML is valid document', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html`);
    const text = await response.text();
    
    if (!text.includes('<!DOCTYPE') && !text.includes('<html')) {
      throw new Error('Missing HTML document structure');
    }
    if (!text.includes('</html>')) {
      throw new Error('Missing closing html tag');
    }
    return { valid: true, size: text.length };
  });

  await test('HTML includes vulnerability data', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html`);
    const text = await response.text();
    
    // Should contain some vulnerability-related content
    const hasVulnContent = text.includes('vulnerability') || 
                          text.includes('Vulnerability') ||
                          text.includes('CVE') ||
                          text.includes('severity');
    if (!hasVulnContent) {
      throw new Error('HTML missing vulnerability content');
    }
    return { hasContent: true };
  });

  // ============================================================================
  // SARIF EXPORT TESTS
  // ============================================================================
  console.log('\nüîß SARIF Export:');

  await test('Export as SARIF', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('SARIF has correct content-type', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/json') && !contentType?.includes('application/sarif')) {
      throw new Error(`Expected JSON content-type, got ${contentType}`);
    }
    return { contentType };
  });

  await test('SARIF has correct schema version', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    const data = await response.json();
    
    if (!data.$schema?.includes('sarif')) {
      throw new Error('Missing or invalid SARIF schema');
    }
    if (!data.version) {
      throw new Error('Missing SARIF version');
    }
    return { version: data.version };
  });

  await test('SARIF has runs array', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    const data = await response.json();
    
    if (!Array.isArray(data.runs)) {
      throw new Error('SARIF missing runs array');
    }
    return { runCount: data.runs.length };
  });

  await test('SARIF run has tool info', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    const data = await response.json();
    
    if (data.runs && data.runs.length > 0) {
      const run = data.runs[0];
      if (!run.tool?.driver?.name) {
        throw new Error('SARIF run missing tool name');
      }
    }
    return { validated: true };
  });

  await test('SARIF has results array', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    const data = await response.json();
    
    if (data.runs && data.runs.length > 0) {
      const run = data.runs[0];
      if (!Array.isArray(run.results)) {
        throw new Error('SARIF run missing results array');
      }
      return { resultCount: run.results.length };
    }
    return { skipped: true };
  });

  // ============================================================================
  // EDGE CASES
  // ============================================================================
  console.log('\n‚ö†Ô∏è Edge Cases:');

  await test('Handle invalid format', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=invalid`);
    // Should return error or default format
    return { status: response.status, handled: true };
  });

  await test('Handle missing format parameter', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export`);
    // Should default to JSON or return error
    return { status: response.status, handled: true };
  });

  await test('Export with scan filter', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json&scanId=test`);
    // Should handle gracefully even if scan doesn't exist
    return { status: response.status, handled: true };
  });

  // Summary
  console.log('\n' + '-'.repeat(70));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed} passed, ${failed} failed out of ${results.length} tests`);
  console.log('='.repeat(70));

  if (failed > 0) {
    process.exit(1);
  }
}

runTests().catch(console.error);
