/**
 * Master Test Runner
 * Runs all Phase 1, 2, and 3 tests in sequence
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

interface TestSuite {
  name: string;
  file: string;
  phase: number;
}

const testSuites: TestSuite[] = [
  // Phase 1
  { name: 'Docker Tools', file: 'tests/phase1/01-docker-tools.test.ts', phase: 1 },
  { name: 'Scan API', file: 'tests/phase1/03-scan-api.test.ts', phase: 1 },
  
  // Phase 2
  { name: 'Parsers', file: 'tests/phase2/01-parsers.test.ts', phase: 2 },
  { name: 'Normalization', file: 'tests/phase2/02-normalization.test.ts', phase: 2 },
  { name: 'Enrichment', file: 'tests/phase2/03-enrichment.test.ts', phase: 2 },
  
  // Phase 3
  { name: 'RAG Chatbot', file: 'tests/phase3/01-rag-chatbot.test.ts', phase: 3 },
  { name: 'Exports', file: 'tests/phase3/02-exports.test.ts', phase: 3 },
  { name: 'Compliance', file: 'tests/phase3/03-compliance.test.ts', phase: 3 },
];

interface SuiteResult {
  suite: TestSuite;
  passed: boolean;
  duration: number;
  output: string;
  error?: string;
}

const results: SuiteResult[] = [];

async function runSuite(suite: TestSuite): Promise<SuiteResult> {
  const start = Date.now();
  try {
    const { stdout, stderr } = await execAsync(`npx tsx ${suite.file}`, {
      timeout: 300000, // 5 minutes
      cwd: process.cwd()
    });
    
    const output = stdout + stderr;
    const passed = !output.includes('‚ùå') || output.includes('‚úÖ All');
    
    return {
      suite,
      passed,
      duration: Date.now() - start,
      output
    };
  } catch (error: any) {
    return {
      suite,
      passed: false,
      duration: Date.now() - start,
      output: error.stdout || '',
      error: error.message
    };
  }
}

async function main() {
  console.log('\n' + '‚ïê'.repeat(70));
  console.log('üß™ VULNERABILITY SCANNER - COMPLETE TEST SUITE');
  console.log('‚ïê'.repeat(70));
  console.log(`Started: ${new Date().toISOString()}\n`);

  // Group by phase
  const phases = [1, 2, 3];
  
  for (const phase of phases) {
    const phaseSuites = testSuites.filter(s => s.phase === phase);
    
    console.log(`\n${'‚îÄ'.repeat(70)}`);
    console.log(`üì¶ PHASE ${phase}`);
    console.log('‚îÄ'.repeat(70));
    
    for (const suite of phaseSuites) {
      process.stdout.write(`\n‚ñ∂ Running ${suite.name}...`);
      const result = await runSuite(suite);
      results.push(result);
      
      if (result.passed) {
        console.log(` ‚úÖ PASSED (${(result.duration / 1000).toFixed(1)}s)`);
      } else {
        console.log(` ‚ùå FAILED (${(result.duration / 1000).toFixed(1)}s)`);
        if (result.error) {
          console.log(`   Error: ${result.error}`);
        }
      }
    }
  }

  // Summary
  console.log('\n' + '‚ïê'.repeat(70));
  console.log('üìä FINAL SUMMARY');
  console.log('‚ïê'.repeat(70));

  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  const totalTime = results.reduce((sum, r) => sum + r.duration, 0);

  console.log(`\nTotal Suites: ${results.length}`);
  console.log(`‚úÖ Passed: ${passed}`);
  console.log(`‚ùå Failed: ${failed}`);
  console.log(`‚è±Ô∏è  Total Time: ${(totalTime / 1000).toFixed(1)}s`);

  // By Phase
  console.log('\nBy Phase:');
  for (const phase of phases) {
    const phaseResults = results.filter(r => r.suite.phase === phase);
    const phasePassed = phaseResults.filter(r => r.passed).length;
    const status = phasePassed === phaseResults.length ? '‚úÖ' : '‚ö†Ô∏è';
    console.log(`  Phase ${phase}: ${status} ${phasePassed}/${phaseResults.length} passed`);
  }

  if (failed > 0) {
    console.log('\n‚ùå Failed Suites:');
    results.filter(r => !r.passed).forEach(r => {
      console.log(`  - ${r.suite.name} (Phase ${r.suite.phase})`);
    });
  }

  console.log('\n' + '‚ïê'.repeat(70));
  
  if (failed === 0) {
    console.log('üéâ ALL TESTS PASSED!');
  } else {
    console.log(`‚ö†Ô∏è  ${failed} suite(s) failed`);
    process.exit(1);
  }
}

main().catch(console.error);
