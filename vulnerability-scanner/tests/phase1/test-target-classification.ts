/**
 * Phase 1 Test: Target Classification
 * Tests target parsing, classification, and validation
 */

const BASE_URL = 'http://localhost:3000';

interface TestCase {
  name: string;
  input: any;
  expected: any;
  validate: (result: any) => boolean;
}

const results: { name: string; passed: boolean; error?: string }[] = [];

async function runTest(name: string, fn: () => Promise<void>): Promise<void> {
  try {
    await fn();
    results.push({ name, passed: true });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  return response.json();
}

// ============================================================================
// TEST CASES
// ============================================================================

const targetTestCases: TestCase[] = [
  // Valid IP addresses
  {
    name: 'Single IPv4 address',
    input: { targets: ['192.168.1.1'] },
    expected: { type: 'ip' },
    validate: (r) => r.success && r.targets[0].type === 'ip'
  },
  {
    name: 'Multiple IPv4 addresses',
    input: { targets: ['192.168.1.1', '10.0.0.1', '172.16.0.1'] },
    expected: { count: 3 },
    validate: (r) => r.success && r.targets.length === 3
  },
  {
    name: 'IPv4 with port',
    input: { targets: ['192.168.1.1:8080'] },
    expected: { type: 'ip' },
    validate: (r) => r.success && r.targets[0].clean.includes('192.168.1.1')
  },
  
  // CIDR ranges
  {
    name: 'CIDR /24 range',
    input: { targets: ['192.168.1.0/24'] },
    expected: { type: 'cidr' },
    validate: (r) => r.success && r.targets[0].original.includes('/24')
  },
  {
    name: 'CIDR /16 range',
    input: { targets: ['10.0.0.0/16'] },
    expected: { type: 'cidr' },
    validate: (r) => r.success && r.targets[0].original.includes('/16')
  },
  
  // Domain names
  {
    name: 'Simple domain',
    input: { targets: ['example.com'] },
    expected: { type: 'domain' },
    validate: (r) => r.success && r.targets[0].type === 'domain'
  },
  {
    name: 'Subdomain',
    input: { targets: ['api.example.com'] },
    expected: { type: 'domain' },
    validate: (r) => r.success && r.targets[0].type === 'domain'
  },
  {
    name: 'Domain with www',
    input: { targets: ['www.example.com'] },
    expected: { type: 'domain' },
    validate: (r) => r.success && r.targets[0].type === 'domain'
  },
  
  // URLs
  {
    name: 'HTTP URL',
    input: { targets: ['http://example.com'] },
    expected: { type: 'url' },
    validate: (r) => r.success && (r.targets[0].type === 'url' || r.targets[0].type === 'domain')
  },
  {
    name: 'HTTPS URL',
    input: { targets: ['https://example.com'] },
    expected: { type: 'url' },
    validate: (r) => r.success && (r.targets[0].type === 'url' || r.targets[0].type === 'domain')
  },
  {
    name: 'URL with path',
    input: { targets: ['https://example.com/api/v1'] },
    expected: { type: 'url' },
    validate: (r) => r.success
  },
  {
    name: 'URL with port',
    input: { targets: ['https://example.com:8443'] },
    expected: { type: 'url' },
    validate: (r) => r.success
  },
  
  // Mixed targets
  {
    name: 'Mixed IP and domain',
    input: { targets: ['192.168.1.1', 'example.com'] },
    expected: { count: 2 },
    validate: (r) => r.success && r.targets.length === 2
  },
  {
    name: 'Mixed all types',
    input: { targets: ['192.168.1.1', 'example.com', '10.0.0.0/24', 'https://api.test.com'] },
    expected: { count: 4 },
    validate: (r) => r.success && r.targets.length === 4
  },
  
  // Edge cases
  {
    name: 'Empty targets array',
    input: { targets: [] },
    expected: { count: 0 },
    validate: (r) => r.success && r.targets.length === 0
  },
  {
    name: 'Localhost',
    input: { targets: ['localhost'] },
    expected: { type: 'domain' },
    validate: (r) => r.success
  },
  {
    name: 'Loopback IP',
    input: { targets: ['127.0.0.1'] },
    expected: { type: 'ip' },
    validate: (r) => r.success && r.targets[0].type === 'ip'
  },
  
  // Tool recommendations
  {
    name: 'IP gets network tools recommended',
    input: { targets: ['192.168.1.1'] },
    expected: { tools: ['nmap'] },
    validate: (r) => r.success && r.targets[0].recommendedTools?.includes('nmap')
  },
  {
    name: 'Domain gets recon tools recommended',
    input: { targets: ['example.com'] },
    expected: { tools: ['subfinder'] },
    validate: (r) => r.success && r.targets[0].recommendedTools?.includes('subfinder')
  },
];

// ============================================================================
// ERROR HANDLING TESTS
// ============================================================================

async function testErrorHandling(): Promise<void> {
  console.log('\nüî¥ ERROR HANDLING:');
  
  // Missing targets field
  await runTest('Missing targets field returns error', async () => {
    const result = await fetchJSON(`${BASE_URL}/api/classify-targets`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    if (result.success) throw new Error('Should have failed');
  });
  
  // Invalid JSON
  await runTest('Invalid JSON returns error', async () => {
    const response = await fetch(`${BASE_URL}/api/classify-targets`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: 'not json'
    });
    if (response.ok) throw new Error('Should have failed');
  });
  
  // Non-array targets
  await runTest('Non-array targets returns error', async () => {
    const result = await fetchJSON(`${BASE_URL}/api/classify-targets`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ targets: 'not-an-array' })
    });
    if (result.success) throw new Error('Should have failed');
  });
}

// ============================================================================
// MAIN TEST RUNNER
// ============================================================================

async function runAllTests(): Promise<void> {
  console.log('\n' + '='.repeat(60));
  console.log('üìã PHASE 1 TEST: TARGET CLASSIFICATION');
  console.log('='.repeat(60));
  
  console.log('\nüéØ TARGET CLASSIFICATION TESTS:');
  
  for (const testCase of targetTestCases) {
    await runTest(testCase.name, async () => {
      const result = await fetchJSON(`${BASE_URL}/api/classify-targets`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(testCase.input)
      });
      
      if (!testCase.validate(result)) {
        throw new Error(`Validation failed. Got: ${JSON.stringify(result).substring(0, 100)}`);
      }
    });
  }
  
  await testErrorHandling();
  
  // Summary
  console.log('\n' + '='.repeat(60));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`\nüìä RESULTS: ${passed}/${results.length} passed (${Math.round(passed/results.length*100)}%)`);
  
  if (failed > 0) {
    console.log('\n‚ùå FAILED:');
    results.filter(r => !r.passed).forEach(r => console.log(`  - ${r.name}: ${r.error}`));
  }
  console.log('='.repeat(60));
}

runAllTests().catch(console.error);
