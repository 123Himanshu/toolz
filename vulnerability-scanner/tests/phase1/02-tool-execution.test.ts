/**
 * Phase 1 Test: Tool Execution
 * Tests that each tool can execute and return valid results
 */

import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);
const TEST_TARGET = 'scanme.nmap.org';
const TEST_IP = '45.33.32.156';

interface TestResult {
  tool: string;
  passed: boolean;
  duration: number;
  hasValidOutput: boolean;
  outputSample?: string;
  error?: string;
}

const results: TestResult[] = [];

async function testNmap(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from nmap_wrapper import NmapWrapper; import json; s = NmapWrapper(docker_mode=False); r = s.quick_scan('${TEST_TARGET}'); print(json.dumps(r))"`,
      { timeout: 120000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result.success && result.data?.hosts;
    return {
      tool: 'nmap',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'nmap', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function testNuclei(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from nuclei_scanner import NucleiScanner; import json; s = NucleiScanner(use_docker=False); r = s.quick_scan('https://${TEST_TARGET}'); print(json.dumps(r, default=str))"`,
      { timeout: 180000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result.success !== undefined;
    return {
      tool: 'nuclei',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'nuclei', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function testNaabu(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from naabu_wrapper import NaabuWrapper; import json; s = NaabuWrapper(); r = s.scan_domain('${TEST_TARGET}'); print(json.dumps(r, default=str))"`,
      { timeout: 120000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result.success !== undefined || result.ports !== undefined;
    return {
      tool: 'naabu',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'naabu', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function testSubfinder(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from subfinder_wrapper import SubfinderWrapper; import json; s = SubfinderWrapper(); r = s.scan('nmap.org'); print(json.dumps(r, default=str))"`,
      { timeout: 120000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result.success !== undefined || result.subdomains !== undefined;
    return {
      tool: 'subfinder',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'subfinder', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function testHttpx(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from httpx_wrapper import HttpxWrapper; import json; s = HttpxWrapper(); r = s.scan('${TEST_TARGET}'); print(json.dumps(r, default=str))"`,
      { timeout: 120000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result.success !== undefined || result.results !== undefined;
    return {
      tool: 'httpx',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'httpx', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function testTrivy(): Promise<TestResult> {
  const start = Date.now();
  try {
    const { stdout } = await execAsync(
      `docker run --rm security-scanner python3 -c "from trivy_wrapper import TrivyScanner; import json; s = TrivyScanner(); r = s.scan_remote('${TEST_TARGET}'); print(json.dumps(r, default=str))"`,
      { timeout: 120000 }
    );
    const result = JSON.parse(stdout);
    const hasValidOutput = result !== undefined;
    return {
      tool: 'trivy',
      passed: hasValidOutput,
      duration: Date.now() - start,
      hasValidOutput,
      outputSample: JSON.stringify(result).substring(0, 200)
    };
  } catch (error: any) {
    return { tool: 'trivy', passed: false, duration: Date.now() - start, hasValidOutput: false, error: error.message };
  }
}

async function runTests() {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ”§ PHASE 1 TEST: Tool Execution');
  console.log('='.repeat(60));
  console.log(`Target: ${TEST_TARGET}\n`);

  // Run tests sequentially to avoid overwhelming the system
  console.log('Testing nmap...');
  results.push(await testNmap());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} nmap (${results[results.length-1].duration}ms)`);

  console.log('Testing nuclei...');
  results.push(await testNuclei());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} nuclei (${results[results.length-1].duration}ms)`);

  console.log('Testing naabu...');
  results.push(await testNaabu());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} naabu (${results[results.length-1].duration}ms)`);

  console.log('Testing subfinder...');
  results.push(await testSubfinder());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} subfinder (${results[results.length-1].duration}ms)`);

  console.log('Testing httpx...');
  results.push(await testHttpx());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} httpx (${results[results.length-1].duration}ms)`);

  console.log('Testing trivy...');
  results.push(await testTrivy());
  console.log(`  ${results[results.length-1].passed ? 'âœ…' : 'âŒ'} trivy (${results[results.length-1].duration}ms)`);

  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ“Š RESULTS SUMMARY');
  console.log('='.repeat(60));

  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  const totalTime = results.reduce((sum, r) => sum + r.duration, 0);

  console.log(`\nTotal: ${results.length} | Passed: ${passed} | Failed: ${failed}`);
  console.log(`Total Time: ${(totalTime / 1000).toFixed(1)}s`);

  if (failed > 0) {
    console.log('\nâŒ Failed Tools:');
    results.filter(r => !r.passed).forEach(r => {
      console.log(`  - ${r.tool}: ${r.error || 'Invalid output'}`);
    });
  }

  console.log('\nðŸ“ Output Samples:');
  results.forEach(r => {
    console.log(`\n${r.tool}:`);
    console.log(`  ${r.outputSample || r.error}`);
  });

  if (failed === 0) {
    console.log('\nâœ… All tools executed successfully!');
  } else {
    process.exit(1);
  }
}

runTests().catch(console.error);
