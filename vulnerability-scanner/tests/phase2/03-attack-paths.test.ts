/**
 * PHASE 2 TEST: Attack Path Generation
 * Tests attack graph building, path finding, and risk scoring
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  return response.json();
}

async function runTests(): Promise<void> {
  console.log('\n' + '='.repeat(70));
  console.log('üìã PHASE 2 TEST: Attack Path Generation');
  console.log('='.repeat(70));

  // ============================================================================
  // ATTACK PATH API TESTS
  // ============================================================================
  console.log('\nüõ§Ô∏è Attack Path API:');

  await test('Get attack paths', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { pathCount: data.attackPaths?.length || 0 };
  });

  await test('Attack path has required structure', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      // Core required fields (nodes/edges may be in graph object or directly)
      const requiredFields = ['id', 'name', 'overallRisk'];
      const missingFields = requiredFields.filter(f => path[f] === undefined);
      
      if (missingFields.length > 0) {
        throw new Error(`Missing fields: ${missingFields.join(', ')}`);
      }
      
      // Check for graph structure (nodes/edges can be in graph object)
      const hasGraph = path.graph || (path.nodes && path.edges);
      if (!hasGraph && !path.steps) {
        throw new Error('Missing graph structure or steps');
      }
    }
    return { validated: true };
  });

  await test('Attack path nodes have correct types', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      const validTypes = ['host', 'service', 'vulnerability', 'credential', 'data'];
      
      for (const node of path.nodes || []) {
        if (!validTypes.includes(node.type)) {
          throw new Error(`Invalid node type: ${node.type}`);
        }
      }
    }
    return { validated: true };
  });

  await test('Attack path edges have correct types', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      const validTypes = ['exploits', 'leads_to', 'requires', 'enables'];
      
      for (const edge of path.edges || []) {
        if (!validTypes.includes(edge.type)) {
          throw new Error(`Invalid edge type: ${edge.type}`);
        }
      }
    }
    return { validated: true };
  });

  // ============================================================================
  // RISK SCORING TESTS
  // ============================================================================
  console.log('\nüìä Risk Scoring:');

  await test('Attack path has risk score', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      if (typeof path.overallRisk !== 'number') {
        throw new Error('overallRisk should be a number');
      }
      if (path.overallRisk < 0 || path.overallRisk > 100) {
        throw new Error(`Risk score ${path.overallRisk} out of range [0,100]`);
      }
    }
    return { validated: true };
  });

  await test('Paths are sorted by risk (highest first)', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    const paths = data.attackPaths || [];
    for (let i = 1; i < paths.length; i++) {
      if (paths[i].overallRisk > paths[i - 1].overallRisk) {
        throw new Error('Paths not sorted by risk descending');
      }
    }
    return { sorted: true, pathCount: paths.length };
  });

  // ============================================================================
  // AI ATTACK PATH PREDICTION
  // ============================================================================
  console.log('\nü§ñ AI Attack Path Prediction:');

  await test('AI can predict attack paths', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis?action=attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { 
      pathCount: data.attackPaths?.paths?.length || 0,
      hasRecommendations: !!data.attackPaths?.recommendations
    };
  });

  await test('AI attack paths have required fields', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis?action=attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths?.paths && data.attackPaths.paths.length > 0) {
      const path = data.attackPaths.paths[0];
      if (!path.name) throw new Error('AI path missing name');
      if (!path.steps || !Array.isArray(path.steps)) throw new Error('AI path missing steps array');
      if (typeof path.risk !== 'number') throw new Error('AI path missing risk score');
    }
    return { validated: true };
  });

  // ============================================================================
  // MITIGATIONS TESTS
  // ============================================================================
  console.log('\nüõ°Ô∏è Mitigations:');

  await test('Attack paths include mitigations', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      if (!path.mitigations || !Array.isArray(path.mitigations)) {
        throw new Error('Path missing mitigations array');
      }
    }
    return { validated: true };
  });

  await test('Attack paths include prioritized fixes', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.attackPaths && data.attackPaths.length > 0) {
      const path = data.attackPaths[0];
      if (!path.prioritizedFixes || !Array.isArray(path.prioritizedFixes)) {
        throw new Error('Path missing prioritizedFixes array');
      }
    }
    return { validated: true };
  });

  // ============================================================================
  // EDGE CASES
  // ============================================================================
  console.log('\n‚ö†Ô∏è Edge Cases:');

  await test('Handle empty vulnerability set', async () => {
    // This tests the internal logic - API should handle gracefully
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths?scanId=non-existent-scan`);
    // Should return empty array, not error
    return { handled: true, paths: data.attackPaths?.length || 0 };
  });

  await test('Handle single host scenario', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    // Should still generate paths even with single host
    return { handled: true };
  });

  // Summary
  console.log('\n' + '-'.repeat(70));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed} passed, ${failed} failed out of ${results.length} tests`);
  console.log('='.repeat(70));

  if (failed > 0) {
    process.exit(1);
  }
}

runTests().catch(console.error);
