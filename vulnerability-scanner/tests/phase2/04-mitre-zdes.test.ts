/**
 * PHASE 2 TEST: MITRE ATT&CK & Zero-Day Exposure Score
 * Tests ATT&CK mapping and ZDES calculations
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  return response.json();
}

async function runTests(): Promise<void> {
  console.log('\n' + '='.repeat(70));
  console.log('üìã PHASE 2 TEST: MITRE ATT&CK & Zero-Day Exposure Score');
  console.log('='.repeat(70));

  // ============================================================================
  // MITRE ATT&CK MAPPING TESTS
  // ============================================================================
  console.log('\nüéØ MITRE ATT&CK Mapping:');

  await test('Get ATT&CK mapping summary', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { 
      techniques: data.summary?.techniquesFound,
      tactics: data.summary?.tacticsFound,
      coverage: data.summary?.coverage
    };
  });

  await test('ATT&CK techniques have correct format', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    for (const tech of data.techniques || []) {
      if (!tech.technique?.id?.match(/^T\d{4}(\.\d{3})?$/)) {
        throw new Error(`Invalid technique ID format: ${tech.technique?.id}`);
      }
      if (!tech.technique?.name) throw new Error('Technique missing name');
      if (!tech.technique?.tactic) throw new Error('Technique missing tactic');
    }
    return { validated: true };
  });

  await test('ATT&CK tactics are valid', async () => {
    const validTactics = [
      'Initial Access', 'Execution', 'Persistence', 'Privilege Escalation',
      'Defense Evasion', 'Credential Access', 'Discovery', 'Lateral Movement',
      'Collection', 'Command and Control', 'Exfiltration', 'Impact'
    ];
    
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    for (const tactic of data.tactics || []) {
      if (!validTactics.includes(tactic.tactic)) {
        throw new Error(`Invalid tactic: ${tactic.tactic}`);
      }
    }
    return { validated: true };
  });

  await test('Vulnerabilities are mapped to techniques', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    let mappedCount = 0;
    for (const vuln of data.vulnerabilities || []) {
      if (vuln.mitreTechniques && vuln.mitreTechniques.length > 0) {
        mappedCount++;
      }
    }
    return { mappedVulns: mappedCount, total: data.vulnerabilities?.length };
  });

  // ============================================================================
  // ZERO-DAY EXPOSURE SCORE TESTS
  // ============================================================================
  console.log('\nüîí Zero-Day Exposure Score (ZDES):');

  await test('Get ZDES summary', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return {
      totalHosts: data.summary?.totalHosts,
      avgScore: data.summary?.averageScore
    };
  });

  await test('ZDES score is in valid range [0-100]', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    for (const host of data.hosts || []) {
      if (host.score < 0 || host.score > 100) {
        throw new Error(`ZDES score ${host.score} out of range for ${host.host}`);
      }
    }
    return { validated: true };
  });

  await test('ZDES label matches score', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    for (const host of data.hosts || []) {
      const expectedLabel = 
        host.score >= 75 ? 'critical' :
        host.score >= 50 ? 'high' :
        host.score >= 25 ? 'medium' : 'low';
      
      if (host.label !== expectedLabel) {
        throw new Error(`Score ${host.score} should be ${expectedLabel}, got ${host.label}`);
      }
    }
    return { validated: true };
  });

  await test('ZDES includes breakdown', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.hosts && data.hosts.length > 0) {
      const host = data.hosts[0];
      const breakdownFields = [
        'unknownServices', 'eolSoftware', 'unknownVersions',
        'weakConfigs', 'abnormalPorts', 'patchStatus', 'externalExposure'
      ];
      
      for (const field of breakdownFields) {
        if (host.breakdown?.[field] === undefined) {
          throw new Error(`Missing breakdown field: ${field}`);
        }
      }
    }
    return { validated: true };
  });

  await test('ZDES includes indicators', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    if (data.hosts && data.hosts.length > 0) {
      const host = data.hosts[0];
      if (!Array.isArray(host.indicators)) {
        throw new Error('indicators should be an array');
      }
      
      for (const indicator of host.indicators || []) {
        if (!indicator.type) throw new Error('Indicator missing type');
        if (!indicator.description) throw new Error('Indicator missing description');
        if (!indicator.severity) throw new Error('Indicator missing severity');
      }
    }
    return { validated: true };
  });

  await test('Get ZDES for specific host', async () => {
    const allData = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!allData.success || !allData.hosts || allData.hosts.length === 0) {
      return { skipped: true };
    }
    
    const hostIp = allData.hosts[0].host;
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes?host=${encodeURIComponent(hostIp)}`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    return { host: data.host, score: data.zdes?.score };
  });

  // ============================================================================
  // ZDES RISK FACTORS TESTS
  // ============================================================================
  console.log('\nüìä ZDES Risk Factors:');

  await test('EOL software detection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    // Check if any host has EOL indicators
    let hasEolIndicator = false;
    for (const host of data.hosts || []) {
      if (host.breakdown?.eolSoftware > 0) {
        hasEolIndicator = true;
        break;
      }
    }
    return { eolDetected: hasEolIndicator };
  });

  await test('Unknown services detection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    let hasUnknownServices = false;
    for (const host of data.hosts || []) {
      if (host.breakdown?.unknownServices > 0) {
        hasUnknownServices = true;
        break;
      }
    }
    return { unknownServicesDetected: hasUnknownServices };
  });

  await test('Abnormal ports detection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    if (!data.success) throw new Error(data.error || 'Failed');
    
    let hasAbnormalPorts = false;
    for (const host of data.hosts || []) {
      if (host.breakdown?.abnormalPorts > 0) {
        hasAbnormalPorts = true;
        break;
      }
    }
    return { abnormalPortsDetected: hasAbnormalPorts };
  });

  // ============================================================================
  // EDGE CASES
  // ============================================================================
  console.log('\n‚ö†Ô∏è Edge Cases:');

  await test('Handle host with no vulnerabilities', async () => {
    // ZDES should still calculate based on services
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    return { handled: true };
  });

  await test('Handle non-existent host', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes?host=999.999.999.999`);
    // Should return error or empty
    return { handled: true, found: !!data.zdes };
  });

  // Summary
  console.log('\n' + '-'.repeat(70));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed} passed, ${failed} failed out of ${results.length} tests`);
  console.log('='.repeat(70));

  if (failed > 0) {
    process.exit(1);
  }
}

runTests().catch(console.error);
