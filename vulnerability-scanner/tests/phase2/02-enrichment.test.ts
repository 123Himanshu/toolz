/**
 * PHASE 2 TEST: Threat Intelligence Enrichment
 * Tests CVE enrichment, EPSS, CISA KEV, ExploitDB, and AI fallback
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  return response.json();
}

async function runTests(): Promise<void> {
  console.log('\n' + '='.repeat(70));
  console.log('üìã PHASE 2 TEST: Threat Intelligence Enrichment');
  console.log('='.repeat(70));

  // ============================================================================
  // NVD API TESTS
  // ============================================================================
  console.log('\nüîí NVD (National Vulnerability Database):');

  await test('Fetch known CVE (Log4Shell)', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    if (!data.success) throw new Error(data.error || 'Failed');
    if (!data.cve) throw new Error('No CVE data returned');
    return { cve: data.cve, hasEnrichment: !!data.enrichment };
  });

  await test('Fetch CVE with CVSS score', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    if (!data.success) throw new Error(data.error || 'Failed');
    // Log4Shell should have high CVSS
    const score = data.enrichment?.nvd?.cvssScore || data.enrichment?.nvdScore;
    if (score && score < 9) {
      console.log(`    (Note: CVSS score ${score} - expected ~10 for Log4Shell)`);
    }
    return { cvssScore: score };
  });

  await test('Handle non-existent CVE gracefully', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-9999-99999`);
    // Should not crash, may return empty or error
    return { handled: true, hasData: !!data.enrichment };
  });

  await test('Handle malformed CVE ID', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=INVALID-CVE`);
    // Should handle gracefully
    return { handled: true };
  });

  // ============================================================================
  // EPSS TESTS
  // ============================================================================
  console.log('\nüìä EPSS (Exploit Prediction Scoring System):');

  await test('Fetch EPSS score for known CVE', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    if (!data.success) throw new Error(data.error || 'Failed');
    const epss = data.enrichment?.epss || data.enrichment?.epssScore;
    // Log4Shell should have high EPSS
    return { epssScore: epss };
  });

  await test('EPSS score is between 0 and 1', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    const epss = data.enrichment?.epss?.score || data.enrichment?.epssScore;
    if (epss !== undefined && (epss < 0 || epss > 1)) {
      throw new Error(`EPSS score ${epss} out of range [0,1]`);
    }
    return { valid: true, score: epss };
  });

  // ============================================================================
  // CISA KEV TESTS
  // ============================================================================
  console.log('\nüö® CISA KEV (Known Exploited Vulnerabilities):');

  await test('Check if CVE is in KEV catalog', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    if (!data.success) throw new Error(data.error || 'Failed');
    // Log4Shell should be in KEV
    const inKev = data.enrichment?.cisaKev?.inKev || data.enrichment?.inTheWild;
    return { inKev };
  });

  await test('KEV includes ransomware association', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    const ransomware = data.enrichment?.cisaKev?.ransomwareUse || data.enrichment?.ransomwareAssociated;
    return { ransomwareAssociated: ransomware };
  });

  // ============================================================================
  // EXPLOIT AVAILABILITY TESTS
  // ============================================================================
  console.log('\nüí• Exploit Availability:');

  await test('Check ExploitDB for known exploit', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    const hasExploit = data.enrichment?.exploitDb?.hasExploit || data.enrichment?.exploitAvailable;
    return { exploitAvailable: hasExploit };
  });

  await test('Check for Metasploit module', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    const metasploit = data.enrichment?.metasploitModule;
    return { hasMetasploit: !!metasploit };
  });

  // ============================================================================
  // EDGE CASES - NO CVE DATA
  // ============================================================================
  console.log('\n‚ö†Ô∏è Edge Cases - Missing CVE:');

  await test('Handle vulnerability without CVE', async () => {
    // Get a vulnerability that might not have CVE
    const vulns = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=10`);
    const noCveVuln = vulns.data?.find((v: any) => !v.cve || v.cve.length === 0);
    
    if (noCveVuln) {
      // Should still have basic data
      if (!noCveVuln.title) throw new Error('Vuln without CVE should still have title');
      if (!noCveVuln.severity) throw new Error('Vuln without CVE should still have severity');
      return { vulnId: noCveVuln.id, hasBasicData: true };
    }
    return { skipped: true, reason: 'All vulns have CVEs' };
  });

  // ============================================================================
  // AI FALLBACK TESTS
  // ============================================================================
  console.log('\nü§ñ AI Fallback (when APIs fail):');

  await test('AI analysis available', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { actions: data.availableActions?.length };
  });

  await test('AI can generate threat intel', async () => {
    const vulns = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=1`);
    if (!vulns.data || vulns.data.length === 0) return { skipped: true };

    const vulnId = vulns.data[0].id;
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis?action=threat-intel&vulnId=${vulnId}`);
    return { hasResponse: !!data.threatIntel };
  });

  await test('AI can classify unknown vulnerability', async () => {
    const vulns = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=1`);
    if (!vulns.data || vulns.data.length === 0) return { skipped: true };

    const vulnId = vulns.data[0].id;
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis?action=classify&vulnId=${vulnId}`);
    return { hasClassification: !!data.classification };
  });

  // ============================================================================
  // BATCH ENRICHMENT TESTS
  // ============================================================================
  console.log('\nüì¶ Batch Operations:');

  await test('Batch enrich vulnerabilities', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ action: 'enrich-all' })
    });
    return { enriched: data.enrichedCount };
  });

  // Summary
  console.log('\n' + '-'.repeat(70));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed} passed, ${failed} failed out of ${results.length} tests`);
  console.log('='.repeat(70));

  if (failed > 0) {
    process.exit(1);
  }
}

runTests().catch(console.error);
