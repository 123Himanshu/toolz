/**
 * Phase 2 Test: Parsers
 * Tests that each tool's output is correctly parsed
 */

const BASE_URL = 'http://localhost:3000';

// Sample raw outputs from each tool (simulating Phase 1 results)
const SAMPLE_OUTPUTS = {
  nmap: {
    success: true,
    data: {
      hosts: {
        '192.168.1.100': {
          ip: '192.168.1.100',
          hostname: 'test-server',
          state: 'up',
          ports: [
            { port: '22', protocol: 'tcp', state: 'open', service: 'ssh', version: 'OpenSSH 7.6p1' },
            { port: '80', protocol: 'tcp', state: 'open', service: 'http', version: 'Apache/2.4.29' },
            { port: '443', protocol: 'tcp', state: 'open', service: 'https', version: '' },
          ]
        }
      }
    }
  },
  nuclei: {
    success: true,
    target: 'https://192.168.1.100',
    vulnerabilities_found: 2,
    vulnerabilities: [
      {
        'template-id': 'CVE-2021-41773',
        info: {
          name: 'Apache HTTP Server Path Traversal',
          severity: 'critical',
          description: 'A flaw was found in Apache HTTP Server',
          reference: ['https://nvd.nist.gov/vuln/detail/CVE-2021-41773']
        },
        'matched-at': 'https://192.168.1.100/cgi-bin/.%2e/.%2e/etc/passwd'
      },
      {
        'template-id': 'ssl-certificate-expired',
        info: {
          name: 'Expired SSL Certificate',
          severity: 'medium'
        },
        'matched-at': 'https://192.168.1.100:443'
      }
    ]
  },
  nikto: {
    success: true,
    target: 'http://192.168.1.100',
    vulnerabilities: [
      {
        id: '000126',
        OSVDB: '877',
        method: 'GET',
        uri: '/server-status',
        msg: 'Apache mod_status enabled'
      }
    ]
  },
  trivy: {
    success: true,
    Results: [
      {
        Target: 'ubuntu:18.04',
        Vulnerabilities: [
          {
            VulnerabilityID: 'CVE-2021-3449',
            PkgName: 'openssl',
            InstalledVersion: '1.1.1',
            Severity: 'HIGH',
            Title: 'OpenSSL NULL pointer dereference'
          }
        ]
      }
    ]
  }
};

interface TestResult {
  name: string;
  passed: boolean;
  details?: any;
  error?: string;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  âœ… ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  âŒ ${name}: ${error.message}`);
  }
}

async function runTests() {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ” PHASE 2 TEST: Parsers');
  console.log('='.repeat(60) + '\n');

  // Test Nmap Parser
  console.log('Testing Nmap Parser:');
  await test('Nmap - Extracts hosts', async () => {
    const hosts = Object.keys(SAMPLE_OUTPUTS.nmap.data.hosts);
    if (hosts.length === 0) throw new Error('No hosts extracted');
    return { hosts };
  });

  await test('Nmap - Extracts ports', async () => {
    const host = SAMPLE_OUTPUTS.nmap.data.hosts['192.168.1.100'];
    if (!host.ports || host.ports.length === 0) throw new Error('No ports extracted');
    return { portCount: host.ports.length };
  });

  await test('Nmap - Extracts services', async () => {
    const host = SAMPLE_OUTPUTS.nmap.data.hosts['192.168.1.100'];
    const services = host.ports.map(p => p.service).filter(Boolean);
    if (services.length === 0) throw new Error('No services extracted');
    return { services };
  });

  // Test Nuclei Parser
  console.log('\nTesting Nuclei Parser:');
  await test('Nuclei - Extracts vulnerabilities', async () => {
    const vulns = SAMPLE_OUTPUTS.nuclei.vulnerabilities;
    if (!vulns || vulns.length === 0) throw new Error('No vulnerabilities extracted');
    return { count: vulns.length };
  });

  await test('Nuclei - Extracts CVE IDs', async () => {
    const vulns = SAMPLE_OUTPUTS.nuclei.vulnerabilities;
    const cves = vulns.filter(v => v['template-id'].startsWith('CVE-'));
    return { cves: cves.map(v => v['template-id']) };
  });

  await test('Nuclei - Extracts severity', async () => {
    const vulns = SAMPLE_OUTPUTS.nuclei.vulnerabilities;
    const severities = vulns.map(v => v.info.severity);
    if (!severities.every(s => ['critical', 'high', 'medium', 'low', 'info'].includes(s))) {
      throw new Error('Invalid severity values');
    }
    return { severities };
  });

  // Test Nikto Parser
  console.log('\nTesting Nikto Parser:');
  await test('Nikto - Extracts findings', async () => {
    const vulns = SAMPLE_OUTPUTS.nikto.vulnerabilities;
    if (!vulns || vulns.length === 0) throw new Error('No findings extracted');
    return { count: vulns.length };
  });

  await test('Nikto - Extracts OSVDB IDs', async () => {
    const vulns = SAMPLE_OUTPUTS.nikto.vulnerabilities;
    const osvdbs = vulns.filter(v => v.OSVDB).map(v => v.OSVDB);
    return { osvdbs };
  });

  // Test Trivy Parser
  console.log('\nTesting Trivy Parser:');
  await test('Trivy - Extracts vulnerabilities', async () => {
    const results = SAMPLE_OUTPUTS.trivy.Results;
    const vulns = results.flatMap(r => r.Vulnerabilities || []);
    if (vulns.length === 0) throw new Error('No vulnerabilities extracted');
    return { count: vulns.length };
  });

  await test('Trivy - Extracts CVE IDs', async () => {
    const results = SAMPLE_OUTPUTS.trivy.Results;
    const vulns = results.flatMap(r => r.Vulnerabilities || []);
    const cves = vulns.map(v => v.VulnerabilityID);
    return { cves };
  });

  // Edge Cases
  console.log('\nTesting Edge Cases:');
  await test('Empty results handled', async () => {
    const emptyNmap = { success: true, data: { hosts: {} } };
    const hosts = Object.keys(emptyNmap.data.hosts);
    if (hosts.length !== 0) throw new Error('Should be empty');
    return { empty: true };
  });

  await test('Missing fields handled', async () => {
    const partialNuclei = { success: true, vulnerabilities: [{ 'template-id': 'test', info: {} }] };
    const vuln = partialNuclei.vulnerabilities[0];
    const severity = vuln.info.severity || 'unknown';
    return { severity };
  });

  await test('Null values handled', async () => {
    const nullData = { success: true, data: null };
    const hasData = nullData.data !== null;
    return { hasData };
  });

  // Summary
  console.log('\n' + '='.repeat(60));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed}/${results.length} passed`);

  if (failed > 0) {
    console.log('\nâŒ Failed:');
    results.filter(r => !r.passed).forEach(r => console.log(`  - ${r.name}: ${r.error}`));
    process.exit(1);
  } else {
    console.log('\nâœ… All parser tests passed!');
  }
}

runTests().catch(console.error);
