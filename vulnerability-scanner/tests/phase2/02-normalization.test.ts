/**
 * Phase 2 Test: Normalization
 * Tests that vulnerabilities are correctly normalized to unified schema
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  details?: any;
  error?: string;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string): Promise<any> {
  const response = await fetch(url);
  return response.json();
}

async function runTests() {
  console.log('\n' + '='.repeat(60));
  console.log('üìã PHASE 2 TEST: Normalization');
  console.log('='.repeat(60) + '\n');

  // Get normalized vulnerabilities
  const vulnsData = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities`);
  const vulns = vulnsData.data || [];

  console.log(`Found ${vulns.length} normalized vulnerabilities\n`);

  // Test Schema Compliance
  console.log('Testing Schema Compliance:');
  
  await test('All vulns have required fields', async () => {
    const requiredFields = ['id', 'scanId', 'scanner', 'host', 'title', 'severity', 'confidence'];
    const missing: string[] = [];
    
    for (const vuln of vulns) {
      for (const field of requiredFields) {
        if (vuln[field] === undefined) {
          missing.push(`${vuln.id || 'unknown'}: missing ${field}`);
        }
      }
    }
    
    if (missing.length > 0) throw new Error(`Missing fields: ${missing.slice(0, 5).join(', ')}`);
    return { checked: vulns.length };
  });

  await test('Severity is normalized', async () => {
    const validLabels = ['critical', 'high', 'medium', 'low', 'info'];
    const invalid = vulns.filter(v => !validLabels.includes(v.severity?.label));
    if (invalid.length > 0) throw new Error(`Invalid severity labels found`);
    return { valid: vulns.length - invalid.length };
  });

  await test('Severity score is 0-10', async () => {
    const invalid = vulns.filter(v => v.severity?.score < 0 || v.severity?.score > 10);
    if (invalid.length > 0) throw new Error(`Invalid severity scores found`);
    return { valid: vulns.length };
  });

  await test('Confidence is 0-100', async () => {
    const invalid = vulns.filter(v => v.confidence < 0 || v.confidence > 100);
    if (invalid.length > 0) throw new Error(`Invalid confidence values found`);
    return { valid: vulns.length };
  });

  await test('Timestamps are ISO format', async () => {
    const invalid = vulns.filter(v => {
      try {
        new Date(v.discoveredAt).toISOString();
        return false;
      } catch {
        return true;
      }
    });
    if (invalid.length > 0) throw new Error(`Invalid timestamps found`);
    return { valid: vulns.length };
  });

  // Test Fingerprinting
  console.log('\nTesting Fingerprinting:');
  
  await test('All vulns have fingerprint', async () => {
    const missing = vulns.filter(v => !v.fingerprint);
    if (missing.length > 0) throw new Error(`${missing.length} vulns missing fingerprint`);
    return { valid: vulns.length };
  });

  await test('Fingerprints are unique (no false dedup)', async () => {
    const fingerprints = vulns.map(v => v.fingerprint);
    const unique = new Set(fingerprints);
    // Some duplicates are expected, but not all should be same
    if (unique.size === 1 && vulns.length > 1) throw new Error('All fingerprints are identical');
    return { unique: unique.size, total: vulns.length };
  });

  // Test Scanner Categories
  console.log('\nTesting Scanner Categories:');
  
  await test('Scanner category is valid', async () => {
    const validCategories = ['network', 'web', 'system', 'recon'];
    const invalid = vulns.filter(v => !validCategories.includes(v.scannerCategory));
    if (invalid.length > 0) throw new Error(`Invalid scanner categories found`);
    return { valid: vulns.length };
  });

  // Test Host Normalization
  console.log('\nTesting Host Normalization:');
  
  const hostsData = await fetchJSON(`${BASE_URL}/api/phase2/hosts`);
  const hosts = hostsData.data || [];

  await test('Hosts have required fields', async () => {
    const requiredFields = ['id', 'ip', 'state', 'discoveredBy'];
    const missing: string[] = [];
    
    for (const host of hosts) {
      for (const field of requiredFields) {
        if (host[field] === undefined) {
          missing.push(`${host.ip || 'unknown'}: missing ${field}`);
        }
      }
    }
    
    if (missing.length > 0) throw new Error(`Missing fields: ${missing.slice(0, 3).join(', ')}`);
    return { checked: hosts.length };
  });

  await test('Hosts have vulnerability counts', async () => {
    const missing = hosts.filter(h => !h.vulnerabilityCount);
    if (missing.length > 0) throw new Error(`${missing.length} hosts missing vuln counts`);
    return { valid: hosts.length };
  });

  await test('Hosts have risk scores', async () => {
    const missing = hosts.filter(h => h.riskScore === undefined);
    if (missing.length > 0) throw new Error(`${missing.length} hosts missing risk score`);
    return { valid: hosts.length };
  });

  // Test Service Normalization
  console.log('\nTesting Service Normalization:');
  
  const servicesData = await fetchJSON(`${BASE_URL}/api/phase2/services`);
  const services = servicesData.data || [];

  await test('Services have required fields', async () => {
    const requiredFields = ['id', 'host', 'port', 'protocol', 'service'];
    const missing: string[] = [];
    
    for (const svc of services) {
      for (const field of requiredFields) {
        if (svc[field] === undefined) {
          missing.push(`${svc.host}:${svc.port}: missing ${field}`);
        }
      }
    }
    
    if (missing.length > 0) throw new Error(`Missing fields: ${missing.slice(0, 3).join(', ')}`);
    return { checked: services.length };
  });

  // Summary
  console.log('\n' + '='.repeat(60));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed}/${results.length} passed`);

  if (failed > 0) {
    console.log('\n‚ùå Failed:');
    results.filter(r => !r.passed).forEach(r => console.log(`  - ${r.name}: ${r.error}`));
    process.exit(1);
  } else {
    console.log('\n‚úÖ All normalization tests passed!');
  }
}

runTests().catch(console.error);
