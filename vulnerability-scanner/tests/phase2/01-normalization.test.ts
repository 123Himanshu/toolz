/**
 * PHASE 2 TEST: Vulnerability Normalization
 * Tests parsing, normalization, and schema validation
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  name: string;
  passed: boolean;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function test(name: string, fn: () => Promise<any>): Promise<void> {
  try {
    const details = await fn();
    results.push({ name, passed: true, details });
    console.log(`  ‚úÖ ${name}`);
  } catch (error: any) {
    results.push({ name, passed: false, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  return response.json();
}

async function runTests(): Promise<void> {
  console.log('\n' + '='.repeat(70));
  console.log('üìã PHASE 2 TEST: Vulnerability Normalization');
  console.log('='.repeat(70));

  // ============================================================================
  // VULNERABILITY QUERY TESTS
  // ============================================================================
  console.log('\nüîç Vulnerability Queries:');

  await test('Get all vulnerabilities', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { total: data.total };
  });

  await test('Get vulnerabilities with pagination', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?page=1&limit=5`);
    if (!data.success) throw new Error(data.error || 'Failed');
    if (data.limit !== 5) throw new Error(`Expected limit 5, got ${data.limit}`);
    return { page: data.page, limit: data.limit };
  });

  await test('Filter by severity - critical', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?severity=critical`);
    if (!data.success) throw new Error(data.error || 'Failed');
    // Verify all returned vulns are critical
    for (const vuln of data.data || []) {
      if (vuln.severity?.label !== 'critical') {
        throw new Error(`Found non-critical vuln: ${vuln.severity?.label}`);
      }
    }
    return { count: data.total };
  });

  await test('Filter by severity - high', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?severity=high`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { count: data.total };
  });

  await test('Filter by severity - medium', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?severity=medium`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { count: data.total };
  });

  await test('Filter by scanner', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?scanner=nuclei`);
    if (!data.success) throw new Error(data.error || 'Failed');
    for (const vuln of data.data || []) {
      if (vuln.scanner !== 'nuclei') {
        throw new Error(`Found wrong scanner: ${vuln.scanner}`);
      }
    }
    return { count: data.total };
  });

  await test('Filter by host', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?host=192.168.1.100`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { count: data.total };
  });

  // ============================================================================
  // SCHEMA VALIDATION TESTS
  // ============================================================================
  console.log('\nüìê Schema Validation:');

  await test('Vulnerability has required fields', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=1`);
    if (!data.success) throw new Error(data.error || 'Failed');
    if (data.data.length === 0) {
      console.log('    (No vulnerabilities to validate)');
      return { skipped: true };
    }

    const vuln = data.data[0];
    const requiredFields = ['id', 'scanner', 'host', 'title', 'severity', 'confidence', 'discoveredAt'];
    const missingFields = requiredFields.filter(f => vuln[f] === undefined);
    
    if (missingFields.length > 0) {
      throw new Error(`Missing fields: ${missingFields.join(', ')}`);
    }
    return { validated: true };
  });

  await test('Severity has correct structure', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=1`);
    if (!data.success || data.data.length === 0) return { skipped: true };

    const severity = data.data[0].severity;
    if (typeof severity.score !== 'number') throw new Error('severity.score should be number');
    if (!['critical', 'high', 'medium', 'low', 'info'].includes(severity.label)) {
      throw new Error(`Invalid severity label: ${severity.label}`);
    }
    return { validated: true };
  });

  await test('CVE array is properly formatted', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities`);
    if (!data.success) throw new Error(data.error || 'Failed');

    for (const vuln of data.data || []) {
      if (vuln.cve && !Array.isArray(vuln.cve)) {
        throw new Error(`CVE should be array, got ${typeof vuln.cve}`);
      }
      // Validate CVE format if present
      for (const cve of vuln.cve || []) {
        if (!cve.match(/^CVE-\d{4}-\d+$/)) {
          throw new Error(`Invalid CVE format: ${cve}`);
        }
      }
    }
    return { validated: true };
  });

  await test('Fingerprint is generated for deduplication', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?limit=5`);
    if (!data.success) throw new Error(data.error || 'Failed');

    for (const vuln of data.data || []) {
      if (!vuln.fingerprint) {
        throw new Error(`Vulnerability ${vuln.id} missing fingerprint`);
      }
    }
    return { validated: true };
  });

  // ============================================================================
  // HOST INVENTORY TESTS
  // ============================================================================
  console.log('\nüñ•Ô∏è Host Inventory:');

  await test('Get all hosts', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { total: data.total };
  });

  await test('Host has required fields', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts?limit=1`);
    if (!data.success) throw new Error(data.error || 'Failed');
    if (data.data.length === 0) return { skipped: true };

    const host = data.data[0];
    const requiredFields = ['id', 'ip', 'state', 'discoveredBy', 'riskScore'];
    const missingFields = requiredFields.filter(f => host[f] === undefined);
    
    if (missingFields.length > 0) {
      throw new Error(`Missing fields: ${missingFields.join(', ')}`);
    }
    return { validated: true };
  });

  await test('Host vulnerability count structure', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts?limit=1`);
    if (!data.success || data.data.length === 0) return { skipped: true };

    const vulnCount = data.data[0].vulnerabilityCount;
    if (!vulnCount) throw new Error('Missing vulnerabilityCount');
    
    const severities = ['critical', 'high', 'medium', 'low', 'info'];
    for (const sev of severities) {
      if (typeof vulnCount[sev] !== 'number') {
        throw new Error(`vulnerabilityCount.${sev} should be number`);
      }
    }
    return { validated: true };
  });

  // ============================================================================
  // SERVICE INVENTORY TESTS
  // ============================================================================
  console.log('\nüîå Service Inventory:');

  await test('Get all services', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/services`);
    if (!data.success) throw new Error(data.error || 'Failed');
    return { total: data.total };
  });

  await test('Service has required fields', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/services?limit=1`);
    if (!data.success) throw new Error(data.error || 'Failed');
    if (data.data.length === 0) return { skipped: true };

    const service = data.data[0];
    const requiredFields = ['id', 'host', 'port', 'protocol', 'service', 'state'];
    const missingFields = requiredFields.filter(f => service[f] === undefined);
    
    if (missingFields.length > 0) {
      throw new Error(`Missing fields: ${missingFields.join(', ')}`);
    }
    return { validated: true };
  });

  // Summary
  console.log('\n' + '-'.repeat(70));
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  console.log(`Results: ${passed} passed, ${failed} failed out of ${results.length} tests`);
  console.log('='.repeat(70));

  if (failed > 0) {
    process.exit(1);
  }
}

runTests().catch(console.error);
