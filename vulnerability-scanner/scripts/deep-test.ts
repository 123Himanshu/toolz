/**
 * Deep Comprehensive Test Suite
 * Tests every component in detail with edge cases
 */

const BASE_URL = 'http://localhost:3000';

interface TestResult {
  category: string;
  test: string;
  passed: boolean;
  duration: number;
  details?: any;
  error?: string;
}

const allResults: TestResult[] = [];

async function test(category: string, name: string, fn: () => Promise<any>): Promise<void> {
  const start = Date.now();
  try {
    const details = await fn();
    allResults.push({ category, test: name, passed: true, duration: Date.now() - start, details });
    console.log(`  ‚úÖ ${name} (${Date.now() - start}ms)`);
  } catch (error: any) {
    allResults.push({ category, test: name, passed: false, duration: Date.now() - start, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
  }
}

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, options);
  const data = await response.json();
  if (!response.ok && !data.success) {
    throw new Error(data.error || `HTTP ${response.status}`);
  }
  return data;
}

// ============================================================================
// 1. DATABASE CONNECTION TESTS
// ============================================================================
async function testDatabaseConnections(): Promise<void> {
  console.log('\nüì¶ 1. DATABASE CONNECTION TESTS');
  console.log('-'.repeat(40));

  await test('Database', 'Health check endpoint responds', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.health) throw new Error('No health data returned');
    return data.health;
  });

  await test('Database', 'PostgreSQL is connected', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.health.postgres) throw new Error('PostgreSQL not connected');
    return { postgres: true };
  });

  await test('Database', 'MongoDB is connected', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.health.mongodb) throw new Error('MongoDB not connected');
    return { mongodb: true };
  });

  await test('Database', 'Redis is connected', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.health.redis) throw new Error('Redis not connected');
    return { redis: true };
  });

  await test('Database', 'Database initialization works', async () => {
    const response = await fetch(`${BASE_URL}/api/db/init`, { method: 'POST' });
    const data = await response.json();
    if (!data.success && !data.message?.includes('initialized')) {
      throw new Error(data.error || 'Init failed');
    }
    return { initialized: true };
  });
}

// ============================================================================
// 2. AUTHENTICATION TESTS
// ============================================================================
async function testAuthentication(): Promise<void> {
  console.log('\nüîê 2. AUTHENTICATION TESTS');
  console.log('-'.repeat(40));

  const testEmail = `deep-test-${Date.now()}@example.com`;
  const testPassword = 'DeepTest123!';
  let authToken = '';

  await test('Auth', 'User registration with valid data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: testEmail, password: testPassword, name: 'Deep Test User' })
    });
    if (!data.success) throw new Error(data.error);
    return { userId: data.user?.id };
  });

  await test('Auth', 'Duplicate registration is rejected', async () => {
    const response = await fetch(`${BASE_URL}/api/auth/register`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: testEmail, password: testPassword, name: 'Duplicate' })
    });
    const data = await response.json();
    if (data.success) throw new Error('Should have rejected duplicate');
    return { rejected: true };
  });

  await test('Auth', 'Login with valid credentials', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: testEmail, password: testPassword })
    });
    if (!data.token) throw new Error('No token received');
    authToken = data.token;
    return { hasToken: true, role: data.user?.role };
  });

  await test('Auth', 'Login with wrong password fails', async () => {
    const response = await fetch(`${BASE_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: testEmail, password: 'WrongPassword123!' })
    });
    const data = await response.json();
    if (data.success) throw new Error('Should have rejected wrong password');
    return { rejected: true };
  });

  await test('Auth', 'Token validation via /me endpoint', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/auth/me`, {
      headers: { 'Authorization': `Bearer ${authToken}` }
    });
    if (!data.user) throw new Error('No user data returned');
    return { email: data.user.email };
  });

  await test('Auth', 'Invalid token is rejected', async () => {
    const response = await fetch(`${BASE_URL}/api/auth/me`, {
      headers: { 'Authorization': 'Bearer invalid-token-here' }
    });
    const data = await response.json();
    if (data.success) throw new Error('Should have rejected invalid token');
    return { rejected: true };
  });
}

// ============================================================================
// 3. PHASE 2 API TESTS
// ============================================================================
async function testPhase2APIs(): Promise<void> {
  console.log('\nüìä 3. PHASE 2 API TESTS');
  console.log('-'.repeat(40));

  // Statistics API
  await test('Phase2', 'Statistics API returns valid structure', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/statistics`);
    if (!data.statistics?.overview) throw new Error('Invalid structure');
    return data.statistics.overview;
  });

  await test('Phase2', 'Statistics has severity breakdown', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/statistics`);
    const sev = data.statistics?.severity;
    if (typeof sev?.critical !== 'number') throw new Error('Missing severity data');
    return sev;
  });

  // Vulnerabilities API
  await test('Phase2', 'Vulnerabilities API returns paginated data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities`);
    if (typeof data.total !== 'number') throw new Error('Missing total');
    if (typeof data.page !== 'number') throw new Error('Missing page');
    return { total: data.total, page: data.page, limit: data.limit };
  });

  await test('Phase2', 'Vulnerabilities filter by severity works', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?severity=critical`);
    return { filtered: true, count: data.total };
  });

  await test('Phase2', 'Vulnerabilities pagination works', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?page=1&limit=5`);
    if (data.limit !== 5) throw new Error('Limit not applied');
    return { page: data.page, limit: data.limit };
  });

  await test('Phase2', 'Vulnerabilities sort works', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?sortBy=severity&sortOrder=desc`);
    return { sorted: true };
  });

  // Hosts API
  await test('Phase2', 'Hosts API returns data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts`);
    if (typeof data.total !== 'number') throw new Error('Missing total');
    return { total: data.total, count: data.data?.length || 0 };
  });

  await test('Phase2', 'Hosts API pagination works', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts?page=1&limit=10`);
    return { page: data.page, limit: data.limit };
  });

  // Services API
  await test('Phase2', 'Services API returns data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/services`);
    return { total: data.total || 0 };
  });

  // Attack Paths API
  await test('Phase2', 'Attack Paths API returns data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (typeof data.total !== 'number') throw new Error('Missing total');
    return { total: data.total, paths: data.attackPaths?.length || 0 };
  });

  // Remediation API
  await test('Phase2', 'Remediation API returns stats', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/remediation`);
    if (!data.stats) throw new Error('Missing stats');
    return data.stats;
  });

  // Trending API
  await test('Phase2', 'Trending API returns data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/trending`);
    return { hasData: data.success };
  });

  // Threat Intel API
  await test('Phase2', 'Threat Intel API returns sources', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel`);
    if (!data.sources) throw new Error('Missing sources');
    return { sources: data.sources.length };
  });

  await test('Phase2', 'Threat Intel CVE lookup works', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    return { cve: data.cve, hasIntel: !!data.threatIntel };
  });
}

// ============================================================================
// 4. PROCESSING PIPELINE TESTS
// ============================================================================
async function testProcessingPipeline(): Promise<void> {
  console.log('\n‚öôÔ∏è 4. PROCESSING PIPELINE TESTS');
  console.log('-'.repeat(40));

  const testScanId = `pipeline-test-${Date.now()}`;

  await test('Pipeline', 'Process endpoint accepts scan data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/process`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        scanId: testScanId,
        target: '172.16.0.1',
        results: {
          nmap: {
            success: true,
            hosts: [{ ip: '172.16.0.1', hostname: 'pipeline-test', state: 'up', ports: [
              { port: 22, protocol: 'tcp', state: 'open', service: 'ssh' },
              { port: 80, protocol: 'tcp', state: 'open', service: 'http' }
            ]}]
          },
          nuclei: {
            success: true,
            vulnerabilities: [
              { template_id: 'ssh-weak-algo', name: 'SSH Weak Algorithms', severity: 'medium', host: '172.16.0.1', port: 22 },
              { template_id: 'http-missing-headers', name: 'Missing Security Headers', severity: 'low', host: '172.16.0.1', port: 80 }
            ]
          }
        },
        tools: ['nmap', 'nuclei']
      })
    });
    return { processed: data.success };
  });

  await test('Pipeline', 'Processed data is queryable', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?host=172.16.0.1`);
    return { found: data.total };
  });

  await test('Pipeline', 'Host was discovered', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts?ip=172.16.0.1`);
    return { found: data.total };
  });
}

// ============================================================================
// 5. EXPORT TESTS
// ============================================================================
async function testExports(): Promise<void> {
  console.log('\nüì§ 5. EXPORT TESTS');
  console.log('-'.repeat(40));

  await test('Export', 'JSON export works', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('application/json')) throw new Error('Wrong content type');
    return { contentType };
  });

  await test('Export', 'CSV export works', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('text/csv')) throw new Error('Wrong content type');
    return { contentType };
  });

  await test('Export', 'HTML export works', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('Export', 'SARIF export works', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { status: response.status };
  });

  await test('Export', 'Export with filters works', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json&severity=critical,high`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    return { filtered: true };
  });

  await test('Export', 'Export includes hosts when requested', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json&includeHosts=true`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    return { hasHosts: !!data.hosts };
  });
}

// ============================================================================
// 6. FRONTEND PAGE TESTS
// ============================================================================
async function testFrontendPages(): Promise<void> {
  console.log('\nüåê 6. FRONTEND PAGE TESTS');
  console.log('-'.repeat(40));

  const pages = [
    { path: '/', name: 'Dashboard' },
    { path: '/analytics', name: 'Analytics' },
    { path: '/login', name: 'Login' },
    { path: '/scan/new', name: 'New Scan' }
  ];

  for (const page of pages) {
    await test('Frontend', `${page.name} page loads (${page.path})`, async () => {
      const response = await fetch(`${BASE_URL}${page.path}`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const html = await response.text();
      if (!html.includes('<!DOCTYPE html>') && !html.includes('<html')) {
        throw new Error('Invalid HTML response');
      }
      return { status: response.status, size: html.length };
    });
  }
}

// ============================================================================
// 7. SCAN API TESTS
// ============================================================================
async function testScanAPI(): Promise<void> {
  console.log('\nüîç 7. SCAN API TESTS');
  console.log('-'.repeat(40));

  await test('Scan', 'List scans endpoint works', async () => {
    const response = await fetch(`${BASE_URL}/api/scan`);
    const data = await response.json();
    if (!Array.isArray(data)) throw new Error('Should return array');
    return { count: data.length };
  });

  await test('Scan', 'Get non-existent scan returns 404', async () => {
    const response = await fetch(`${BASE_URL}/api/scan?scanId=non-existent-id`);
    if (response.status !== 404) throw new Error(`Expected 404, got ${response.status}`);
    return { status: 404 };
  });
}

// ============================================================================
// 8. PERFORMANCE TESTS
// ============================================================================
async function testPerformance(): Promise<void> {
  console.log('\n‚ö° 8. PERFORMANCE TESTS');
  console.log('-'.repeat(40));

  const endpoints = [
    '/api/phase2/statistics',
    '/api/phase2/vulnerabilities',
    '/api/phase2/hosts',
    '/api/phase2/attack-paths'
  ];

  for (const endpoint of endpoints) {
    await test('Performance', `${endpoint} responds under 2s`, async () => {
      const start = Date.now();
      await fetch(`${BASE_URL}${endpoint}`);
      const duration = Date.now() - start;
      if (duration > 2000) throw new Error(`Too slow: ${duration}ms`);
      return { duration };
    });
  }
}

// ============================================================================
// 9. ERROR HANDLING TESTS
// ============================================================================
async function testErrorHandling(): Promise<void> {
  console.log('\nüö® 9. ERROR HANDLING TESTS');
  console.log('-'.repeat(40));

  await test('Errors', 'Invalid JSON body returns 400', async () => {
    const response = await fetch(`${BASE_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: 'not-valid-json'
    });
    if (response.status !== 400 && response.status !== 500) {
      throw new Error(`Expected 400/500, got ${response.status}`);
    }
    return { status: response.status };
  });

  await test('Errors', 'Missing required fields returns error', async () => {
    const response = await fetch(`${BASE_URL}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({})
    });
    const data = await response.json();
    if (data.success) throw new Error('Should have failed');
    return { rejected: true };
  });
}

// ============================================================================
// MAIN RUNNER
// ============================================================================
async function runAllTests(): Promise<void> {
  console.log('\n' + '='.repeat(50));
  console.log('üß™ DEEP COMPREHENSIVE TEST SUITE');
  console.log('='.repeat(50));

  await testDatabaseConnections();
  await testAuthentication();
  await testPhase2APIs();
  await testProcessingPipeline();
  await testExports();
  await testFrontendPages();
  await testScanAPI();
  await testPerformance();
  await testErrorHandling();

  // Summary
  console.log('\n' + '='.repeat(50));
  console.log('üìã FINAL SUMMARY');
  console.log('='.repeat(50));

  const passed = allResults.filter(r => r.passed).length;
  const failed = allResults.filter(r => !r.passed).length;
  const total = allResults.length;
  const totalTime = allResults.reduce((sum, r) => sum + r.duration, 0);

  // Group by category
  const categories = [...new Set(allResults.map(r => r.category))];
  
  console.log('\nBy Category:');
  for (const cat of categories) {
    const catResults = allResults.filter(r => r.category === cat);
    const catPassed = catResults.filter(r => r.passed).length;
    const catTotal = catResults.length;
    const status = catPassed === catTotal ? '‚úÖ' : '‚ö†Ô∏è';
    console.log(`  ${status} ${cat}: ${catPassed}/${catTotal} passed`);
  }

  console.log(`\nTotal: ${passed}/${total} tests passed (${failed} failed)`);
  console.log(`Time: ${totalTime}ms`);

  if (failed > 0) {
    console.log('\n‚ùå Failed Tests:');
    allResults.filter(r => !r.passed).forEach(r => {
      console.log(`  - [${r.category}] ${r.test}: ${r.error}`);
    });
  }

  console.log('\n' + '='.repeat(50));
  
  // Exit with error code if tests failed
  if (failed > 0) {
    process.exit(1);
  }
}

runAllTests().catch(err => {
  console.error('Test runner error:', err);
  process.exit(1);
});
