/**
 * COMPLETE TOOL TEST SUITE
 * Tests ALL scanning tools with correct inputs for each tool type
 */

const BASE_URL = 'http://localhost:3000';

interface ToolTest {
  tool: string;
  category: 'network' | 'web' | 'system' | 'recon';
  target: string;
  targetType: string;
  expectedFields: string[];
  timeout: number;
}

// Define all tools with their correct test targets
const TOOL_TESTS: ToolTest[] = [
  // Network Tools
  {
    tool: 'nmap',
    category: 'network',
    target: 'scanme.nmap.org',
    targetType: 'domain',
    expectedFields: ['hosts', 'ports'],
    timeout: 120000,
  },
  {
    tool: 'naabu',
    category: 'network',
    target: 'scanme.nmap.org',
    targetType: 'domain',
    expectedFields: ['ports'],
    timeout: 60000,
  },
  {
    tool: 'rustscan',
    category: 'network',
    target: 'scanme.nmap.org',
    targetType: 'domain',
    expectedFields: ['ports'],
    timeout: 60000,
  },
  {
    tool: 'masscan',
    category: 'network',
    target: '45.33.32.156', // scanme.nmap.org IP - masscan needs IP
    targetType: 'ip',
    expectedFields: ['ports'],
    timeout: 60000,
  },
  
  // Web Tools
  {
    tool: 'nuclei',
    category: 'web',
    target: 'https://scanme.nmap.org',
    targetType: 'url',
    expectedFields: ['vulnerabilities'],
    timeout: 180000,
  },
  {
    tool: 'httpx',
    category: 'web',
    target: 'scanme.nmap.org',
    targetType: 'domain',
    expectedFields: ['results', 'status'],
    timeout: 60000,
  },
  {
    tool: 'nikto',
    category: 'web',
    target: 'http://scanme.nmap.org',
    targetType: 'url',
    expectedFields: ['vulnerabilities'],
    timeout: 300000, // Nikto is slow
  },
  {
    tool: 'wapiti',
    category: 'web',
    target: 'http://scanme.nmap.org',
    targetType: 'url',
    expectedFields: ['vulnerabilities'],
    timeout: 300000,
  },
  
  // Recon Tools
  {
    tool: 'subfinder',
    category: 'recon',
    target: 'nmap.org',
    targetType: 'domain',
    expectedFields: ['subdomains'],
    timeout: 120000,
  },
  
  // System Tools
  {
    tool: 'trivy',
    category: 'system',
    target: 'alpine:latest',
    targetType: 'container',
    expectedFields: ['vulnerabilities'],
    timeout: 120000,
  },
];

interface TestResult {
  tool: string;
  category: string;
  target: string;
  passed: boolean;
  duration: number;
  error?: string;
  details?: any;
}

const results: TestResult[] = [];

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, {
    ...options,
    headers: { 'Content-Type': 'application/json', ...options?.headers },
  });
  const text = await response.text();
  if (!response.ok) throw new Error(`HTTP ${response.status}: ${text.substring(0, 200)}`);
  try { return JSON.parse(text); } catch { return { raw: text }; }
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function testTool(test: ToolTest): Promise<TestResult> {
  const startTime = Date.now();
  
  console.log(`\n  Testing ${test.tool.toUpperCase()}...`);
  console.log(`    Target: ${test.target} (${test.targetType})`);
  
  try {
    // Create scan
    const createResponse = await fetchJSON(`${BASE_URL}/api/scan`, {
      method: 'POST',
      body: JSON.stringify({
        target: test.target,
        scanType: 'active',
        tools: {
          network: test.category === 'network' ? [test.tool] : [],
          web: test.category === 'web' ? [test.tool] : [],
          system: test.category === 'system' ? [test.tool] : [],
          recon: test.category === 'recon' ? [test.tool] : [],
        },
      }),
    });
    
    if (!createResponse.success || !createResponse.scanId) {
      throw new Error('Failed to create scan');
    }
    
    const scanId = createResponse.scanId;
    console.log(`    Scan ID: ${scanId}`);
    
    // Wait for completion
    const maxWait = test.timeout;
    const startWait = Date.now();
    
    while (Date.now() - startWait < maxWait) {
      const scans = await fetchJSON(`${BASE_URL}/api/scan`);
      const scan = scans.find((s: any) => s.id === scanId);
      
      if (!scan) throw new Error('Scan not found');
      
      const toolStatus = scan.progress?.[test.tool];
      process.stdout.write(`\r    Status: ${toolStatus || 'pending'}`.padEnd(50));
      
      if (scan.status === 'completed' || scan.status === 'failed') {
        console.log('');
        
        const toolResult = scan.results?.[test.tool];
        
        if (!toolResult) {
          throw new Error(`No results for ${test.tool}`);
        }
        
        if (toolResult.error) {
          throw new Error(toolResult.error);
        }
        
        if (!toolResult.success) {
          throw new Error(`${test.tool} did not succeed`);
        }
        
        const duration = Date.now() - startTime;
        
        return {
          tool: test.tool,
          category: test.category,
          target: test.target,
          passed: true,
          duration,
          details: {
            hasData: !!toolResult.data,
            dataKeys: toolResult.data ? Object.keys(toolResult.data) : [],
          },
        };
      }
      
      await sleep(5000);
    }
    
    throw new Error('Scan timed out');
    
  } catch (error: any) {
    const duration = Date.now() - startTime;
    console.log('');
    
    return {
      tool: test.tool,
      category: test.category,
      target: test.target,
      passed: false,
      duration,
      error: error.message,
    };
  }
}

async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘           COMPLETE TOOL TEST SUITE                                   â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log(`â•‘  Started: ${new Date().toISOString().padEnd(57)}â•‘`);
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
  
  const startTime = Date.now();
  
  // Group tools by category
  const categories = ['network', 'web', 'recon', 'system'];
  
  for (const category of categories) {
    const categoryTests = TOOL_TESTS.filter(t => t.category === category);
    
    if (categoryTests.length === 0) continue;
    
    console.log('\n' + 'â•'.repeat(70));
    console.log(`ðŸ“¦ ${category.toUpperCase()} TOOLS`);
    console.log('â•'.repeat(70));
    
    for (const test of categoryTests) {
      const result = await testTool(test);
      results.push(result);
      
      if (result.passed) {
        console.log(`  âœ… ${test.tool.toUpperCase()} PASSED (${(result.duration / 1000).toFixed(1)}s)`);
      } else {
        console.log(`  âŒ ${test.tool.toUpperCase()} FAILED: ${result.error}`);
      }
    }
  }
  
  // Summary
  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  const passRate = ((passed / results.length) * 100).toFixed(1);
  
  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸ“Š FINAL SUMMARY');
  console.log('â•'.repeat(70));
  
  // By category
  for (const category of categories) {
    const categoryResults = results.filter(r => r.category === category);
    if (categoryResults.length === 0) continue;
    
    const categoryPassed = categoryResults.filter(r => r.passed).length;
    const status = categoryPassed === categoryResults.length ? 'âœ…' : categoryPassed > 0 ? 'âš ï¸' : 'âŒ';
    console.log(`${status} ${category.toUpperCase()}: ${categoryPassed}/${categoryResults.length} passed`);
    
    categoryResults.forEach(r => {
      const icon = r.passed ? '  âœ…' : '  âŒ';
      console.log(`${icon} ${r.tool}: ${r.passed ? 'PASS' : r.error}`);
    });
  }
  
  console.log('â”€'.repeat(70));
  console.log(`Total Tools: ${results.length}`);
  console.log(`âœ… Passed: ${passed}`);
  console.log(`âŒ Failed: ${failed}`);
  console.log(`â±ï¸  Total Time: ${totalTime}s`);
  console.log(`ðŸ“Š Pass Rate: ${passRate}%`);
  console.log('â•'.repeat(70));
  
  if (failed > 0) {
    console.log('\nFailed Tools:');
    results.filter(r => !r.passed).forEach(r => {
      console.log(`  - ${r.tool}: ${r.error}`);
    });
  }
  
  console.log('');
}

main().catch(console.error);
