/**
 * DEEP INTEGRATION TEST - SQA Level Testing
 * 
 * This test suite validates the COMPLETE pipeline:
 * - Phase 1: Scanning tools execution and result collection
 * - Phase 2: Normalization, enrichment, correlation, attack paths
 * - Phase 3: RAG chatbot, compliance, exports
 * 
 * CRITICAL: Phase 2 tests ONLY run if Phase 1 passes completely
 */

const BASE_URL = 'http://localhost:3000';
const TEST_TARGET = 'scanme.nmap.org';

// Test state
interface TestResult {
  name: string;
  passed: boolean;
  duration: number;
  error?: string;
  data?: any;
}

interface PhaseResult {
  phase: string;
  passed: boolean;
  tests: TestResult[];
  totalTime: number;
}

const results: PhaseResult[] = [];
let currentPhase: PhaseResult | null = null;
let scanId: string | null = null;
let phase1RawResults: Record<string, any> = {};

// Utility functions
async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });
  
  const text = await response.text();
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${text.substring(0, 500)}`);
  }
  
  try {
    return JSON.parse(text);
  } catch {
    return { raw: text };
  }
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function startPhase(name: string): void {
  currentPhase = {
    phase: name,
    passed: true,
    tests: [],
    totalTime: 0,
  };
  console.log(`\n${'‚ïê'.repeat(70)}`);
  console.log(`üì¶ ${name}`);
  console.log('‚ïê'.repeat(70));
}

function endPhase(): boolean {
  if (currentPhase) {
    currentPhase.totalTime = currentPhase.tests.reduce((sum, t) => sum + t.duration, 0);
    currentPhase.passed = currentPhase.tests.every(t => t.passed);
    results.push(currentPhase);
    
    const passed = currentPhase.tests.filter(t => t.passed).length;
    const failed = currentPhase.tests.filter(t => !t.passed).length;
    
    console.log(`\n${currentPhase.passed ? '‚úÖ' : '‚ùå'} ${currentPhase.phase}: ${passed}/${currentPhase.tests.length} passed`);
    
    if (failed > 0) {
      console.log('Failed tests:');
      currentPhase.tests.filter(t => !t.passed).forEach(t => {
        console.log(`  ‚ùå ${t.name}: ${t.error}`);
      });
    }
    
    const phasePassed = currentPhase.passed;
    currentPhase = null;
    return phasePassed;
  }
  return false;
}

async function test(name: string, fn: () => Promise<any>): Promise<boolean> {
  const start = Date.now();
  try {
    const data = await fn();
    const duration = Date.now() - start;
    currentPhase?.tests.push({ name, passed: true, duration, data });
    console.log(`  ‚úÖ ${name} (${duration}ms)`);
    return true;
  } catch (error: any) {
    const duration = Date.now() - start;
    currentPhase?.tests.push({ name, passed: false, duration, error: error.message });
    console.log(`  ‚ùå ${name}: ${error.message}`);
    return false;
  }
}

// ============================================================================
// PHASE 1: SCANNING TOOLS
// ============================================================================

async function runPhase1(): Promise<boolean> {
  startPhase('PHASE 1: SCANNING & TOOL EXECUTION');
  
  // 1.1 - Check Docker is running
  await test('1.1 Docker Available', async () => {
    const { execSync } = require('child_process');
    const output = execSync('docker ps --format "{{.Names}}"', { encoding: 'utf-8' });
    if (!output) throw new Error('Docker not running');
    return { containers: output.split('\n').filter(Boolean) };
  });
  
  // 1.2 - Check security-scanner image exists
  await test('1.2 Security Scanner Image', async () => {
    const { execSync } = require('child_process');
    const output = execSync('docker images security-scanner --format "{{.Repository}}:{{.Tag}}"', { encoding: 'utf-8' });
    if (!output.includes('security-scanner')) throw new Error('security-scanner image not found');
    return { image: output.trim() };
  });
  
  // 1.3 - Test target classification API
  await test('1.3 Target Classification API', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets`, {
      method: 'POST',
      body: JSON.stringify({ targets: [TEST_TARGET, '192.168.1.1', 'https://example.com'] }),
    });
    if (!data.classified) throw new Error('Classification failed');
    return data;
  });
  
  // 1.4 - Create a real scan
  await test('1.4 Create Active Scan', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/scan`, {
      method: 'POST',
      body: JSON.stringify({
        target: TEST_TARGET,
        scanType: 'active',
        tools: {
          network: ['nmap', 'naabu'],
          web: ['nuclei', 'httpx'],
          system: [],
        },
      }),
    });
    
    if (!data.success || !data.scanId) throw new Error('Scan creation failed');
    scanId = data.scanId;
    return { scanId };
  });
  
  // 1.5 - Wait for scan completion (with detailed progress)
  await test('1.5 Wait for Scan Completion', async () => {
    let attempts = 0;
    const maxAttempts = 120; // 10 minutes max
    
    while (attempts < maxAttempts) {
      const scans = await fetchJSON(`${BASE_URL}/api/scan`);
      const scan = scans.find((s: any) => s.id === scanId);
      
      if (!scan) throw new Error('Scan not found');
      
      // Log progress
      if (scan.progress) {
        const progress = Object.entries(scan.progress)
          .map(([tool, status]) => `${tool}:${status}`)
          .join(', ');
        process.stdout.write(`\r    Progress: ${progress}                    `);
      }
      
      if (scan.status === 'completed') {
        console.log(''); // New line after progress
        phase1RawResults = scan.results || {};
        return { 
          status: scan.status, 
          tools: Object.keys(scan.results || {}),
          duration: scan.summary?.total_tools 
        };
      }
      
      if (scan.status === 'failed') {
        throw new Error(`Scan failed: ${scan.error}`);
      }
      
      await sleep(5000);
      attempts++;
    }
    
    throw new Error('Scan timeout after 10 minutes');
  });
  
  // 1.6 - Verify raw results exist
  await test('1.6 Verify Raw Results', async () => {
    if (Object.keys(phase1RawResults).length === 0) {
      throw new Error('No raw results collected');
    }
    
    const toolsWithResults = Object.entries(phase1RawResults)
      .filter(([_, result]: [string, any]) => result && result.success !== false)
      .map(([tool]) => tool);
    
    if (toolsWithResults.length === 0) {
      throw new Error('All tools failed');
    }
    
    return { 
      toolsWithResults,
      totalTools: Object.keys(phase1RawResults).length 
    };
  });
  
  // 1.7 - Verify Nmap results structure
  await test('1.7 Nmap Results Structure', async () => {
    const nmapResult = phase1RawResults.nmap;
    if (!nmapResult) throw new Error('Nmap results missing');
    if (!nmapResult.success) throw new Error(`Nmap failed: ${nmapResult.error}`);
    if (!nmapResult.data?.hosts) throw new Error('Nmap hosts data missing');
    
    const hosts = Object.keys(nmapResult.data.hosts);
    if (hosts.length === 0) throw new Error('No hosts discovered by Nmap');
    
    // Verify host structure
    const firstHost = nmapResult.data.hosts[hosts[0]];
    if (!firstHost.ports) throw new Error('Nmap ports data missing');
    
    return { 
      hostsFound: hosts.length,
      portsFound: firstHost.ports.length,
      sampleHost: hosts[0]
    };
  });
  
  // 1.8 - Verify Nuclei results structure
  await test('1.8 Nuclei Results Structure', async () => {
    const nucleiResult = phase1RawResults.nuclei;
    if (!nucleiResult) throw new Error('Nuclei results missing');
    if (!nucleiResult.success) throw new Error(`Nuclei failed: ${nucleiResult.error}`);
    
    // Nuclei may find 0 vulnerabilities on scanme.nmap.org - that's OK
    return { 
      success: nucleiResult.success,
      vulnerabilitiesFound: nucleiResult.vulnerabilities_found || 0,
      target: nucleiResult.target
    };
  });
  
  // 1.9 - Verify results stored in Qdrant
  await test('1.9 Results Stored in Qdrant', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/qdrant/init`);
    // Just verify Qdrant is accessible
    return { qdrantAccessible: true };
  });
  
  return endPhase();
}

// ============================================================================
// PHASE 2: NORMALIZATION & PROCESSING
// ============================================================================

async function runPhase2(): Promise<boolean> {
  startPhase('PHASE 2: NORMALIZATION, ENRICHMENT & CORRELATION');
  
  // 2.1 - Verify Phase 2 was processed (happens automatically after scan)
  await test('2.1 Verify Phase 2 Processing', async () => {
    // Phase 2 is processed automatically when scan completes
    // Check if the scan has phase2 data
    const scans = await fetchJSON(`${BASE_URL}/api/scan`);
    const scan = scans.find((s: any) => s.id === scanId);
    
    if (!scan) throw new Error('Scan not found');
    
    // Check if phase2 processing happened
    if (scan.phase2) {
      return {
        processed: scan.phase2.processed,
        vulnerabilities: scan.phase2.vulnerabilities,
        hosts: scan.phase2.hosts
      };
    }
    
    // If not auto-processed, trigger manually
    const data = await fetchJSON(`${BASE_URL}/api/phase2/process`, {
      method: 'POST',
      body: JSON.stringify({ 
        scanId,
        target: scan.target,
        results: scan.results,
        tools: Object.keys(scan.results || {})
      }),
    });
    
    if (!data.success) throw new Error('Phase 2 processing failed');
    return data.summary;
  });

  
  // 2.2 - Verify vulnerabilities normalized
  await test('2.2 Vulnerabilities Normalized', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?scanId=${scanId}`);
    if (!data.success) throw new Error('Failed to get vulnerabilities');
    
    const vulns = data.data || [];
    
    // Verify schema compliance for each vulnerability
    const requiredFields = ['id', 'scanId', 'scanner', 'host', 'title', 'severity', 'fingerprint'];
    
    for (const vuln of vulns) {
      for (const field of requiredFields) {
        if (vuln[field] === undefined) {
          throw new Error(`Vulnerability missing required field: ${field}`);
        }
      }
      
      // Verify severity structure
      if (typeof vuln.severity !== 'object') {
        throw new Error('Severity must be an object with score and label');
      }
      if (typeof vuln.severity.score !== 'number' || vuln.severity.score < 0 || vuln.severity.score > 10) {
        throw new Error(`Invalid severity score: ${vuln.severity.score}`);
      }
      if (!['critical', 'high', 'medium', 'low', 'info'].includes(vuln.severity.label)) {
        throw new Error(`Invalid severity label: ${vuln.severity.label}`);
      }
      
      // Verify fingerprint is a hash
      if (typeof vuln.fingerprint !== 'string' || vuln.fingerprint.length < 16) {
        throw new Error('Invalid fingerprint format');
      }
    }
    
    return { 
      count: vulns.length,
      severityBreakdown: vulns.reduce((acc: any, v: any) => {
        acc[v.severity.label] = (acc[v.severity.label] || 0) + 1;
        return acc;
      }, {})
    };
  });
  
  // 2.3 - Verify hosts discovered
  await test('2.3 Hosts Discovered', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts?scanId=${scanId}`);
    if (!data.success) throw new Error('Failed to get hosts');
    
    const hosts = data.data || [];
    if (hosts.length === 0) throw new Error('No hosts discovered');
    
    // Verify host structure
    const requiredFields = ['id', 'ip', 'state', 'discoveredBy'];
    for (const host of hosts) {
      for (const field of requiredFields) {
        if (host[field] === undefined) {
          throw new Error(`Host missing required field: ${field}`);
        }
      }
      
      // Verify discoveredBy is an array
      if (!Array.isArray(host.discoveredBy)) {
        throw new Error('discoveredBy must be an array');
      }
      
      // Verify vulnerabilityCount structure
      if (host.vulnerabilityCount) {
        const severities = ['critical', 'high', 'medium', 'low', 'info'];
        for (const sev of severities) {
          if (typeof host.vulnerabilityCount[sev] !== 'number') {
            throw new Error(`vulnerabilityCount.${sev} must be a number`);
          }
        }
      }
    }
    
    return { 
      count: hosts.length,
      hosts: hosts.map((h: any) => h.ip)
    };
  });
  
  // 2.4 - Verify services discovered
  await test('2.4 Services Discovered', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/services?scanId=${scanId}`);
    if (!data.success) throw new Error('Failed to get services');
    
    const services = data.data || [];
    if (services.length === 0) throw new Error('No services discovered');
    
    // Verify service structure
    const requiredFields = ['id', 'host', 'port', 'protocol', 'service'];
    for (const svc of services) {
      for (const field of requiredFields) {
        if (svc[field] === undefined) {
          throw new Error(`Service missing required field: ${field}`);
        }
      }
      
      // Verify port is a number
      if (typeof svc.port !== 'number' || svc.port < 1 || svc.port > 65535) {
        throw new Error(`Invalid port: ${svc.port}`);
      }
    }
    
    return { 
      count: services.length,
      ports: services.map((s: any) => s.port)
    };
  });
  
  // 2.5 - Test NVD enrichment with known CVE
  await test('2.5 NVD Enrichment (CVE-2021-44228)', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2021-44228`);
    if (!data.success) throw new Error('Threat intel API failed');
    
    const intel = data.threatIntel;
    if (!intel) throw new Error('No threat intelligence data returned');
    
    // Verify NVD data
    if (intel.nvdScore === undefined) throw new Error('NVD score missing');
    if (intel.nvdScore !== 10) throw new Error(`Expected CVSS 10 for Log4Shell, got ${intel.nvdScore}`);
    
    // Verify EPSS data
    if (intel.epssScore === undefined) throw new Error('EPSS score missing');
    if (intel.epssScore < 0.9) throw new Error(`Expected high EPSS for Log4Shell, got ${intel.epssScore}`);
    
    // Verify KEV data
    if (!intel.kevDueDate) throw new Error('KEV due date missing - Log4Shell is in KEV');
    
    return {
      nvdScore: intel.nvdScore,
      epssScore: intel.epssScore,
      kevDueDate: intel.kevDueDate,
      exploitAvailable: intel.exploitAvailable
    };
  });
  
  // 2.6 - Test EPSS enrichment
  await test('2.6 EPSS Enrichment', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=CVE-2024-0001`);
    // This CVE may not exist, but API should handle gracefully
    if (!data.success) throw new Error('EPSS API failed');
    return { handled: true };
  });
  
  // 2.7 - Test handling of invalid CVE
  await test('2.7 Invalid CVE Handling', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel?cve=INVALID-CVE`);
    // Should not crash, should return empty or error gracefully
    return { handled: true, response: data };
  });
  
  // 2.8 - Test vulnerability without CVE (edge case)
  await test('2.8 Vulnerability Without CVE', async () => {
    // Query vulnerabilities and check if any without CVE are handled
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?scanId=${scanId}`);
    const vulnsWithoutCVE = (data.data || []).filter((v: any) => !v.cve || v.cve.length === 0);
    
    // These should still have valid fingerprints and severity
    for (const vuln of vulnsWithoutCVE) {
      if (!vuln.fingerprint) throw new Error('Vuln without CVE missing fingerprint');
      if (!vuln.severity) throw new Error('Vuln without CVE missing severity');
    }
    
    return { vulnsWithoutCVE: vulnsWithoutCVE.length };
  });
  
  // 2.9 - Test MITRE ATT&CK mapping
  await test('2.9 MITRE ATT&CK Mapping', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre?scanId=${scanId}`);
    if (!data.success) throw new Error('MITRE API failed');
    
    // Verify structure
    if (!data.summary) throw new Error('MITRE summary missing');
    
    return {
      techniquesFound: data.summary.techniquesFound || 0,
      tacticsFound: data.summary.tacticsFound || 0
    };
  });
  
  // 2.10 - Test Zero-Day Exposure Score (ZDES)
  await test('2.10 Zero-Day Exposure Score', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes?scanId=${scanId}`);
    if (!data.success) throw new Error('ZDES API failed');
    
    // Verify ZDES structure
    if (data.summary) {
      if (typeof data.summary.averageScore !== 'number') {
        throw new Error('ZDES average score must be a number');
      }
      if (data.summary.averageScore < 0 || data.summary.averageScore > 100) {
        throw new Error(`ZDES score out of range: ${data.summary.averageScore}`);
      }
    }
    
    return {
      totalHosts: data.summary?.totalHosts || 0,
      averageScore: data.summary?.averageScore
    };
  });
  
  // 2.11 - Test Attack Path Generation
  await test('2.11 Attack Path Generation', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths?scanId=${scanId}`);
    if (!data.success) throw new Error('Attack paths API failed');
    
    const paths = data.attackPaths || [];
    
    // Verify attack path structure
    for (const path of paths) {
      if (!path.id) throw new Error('Attack path missing id');
      if (!path.name) throw new Error('Attack path missing name');
      if (typeof path.overallRisk !== 'number') throw new Error('Attack path missing overallRisk');
      if (!path.mitigations || !Array.isArray(path.mitigations)) {
        throw new Error('Attack path missing mitigations array');
      }
    }
    
    return {
      pathCount: paths.length,
      highestRisk: paths.length > 0 ? Math.max(...paths.map((p: any) => p.overallRisk)) : 0
    };
  });
  
  // 2.12 - Test Correlation Engine
  await test('2.12 Correlation Engine', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/correlation?scanId=${scanId}`);
    if (!data.success) throw new Error('Correlation API failed');
    
    return {
      correlations: data.correlations?.length || 0,
      crossScannerVerified: data.stats?.crossScannerVerified || 0
    };
  });
  
  // 2.13 - Test Statistics API
  await test('2.13 Statistics API', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/statistics`);
    if (!data.success) throw new Error('Statistics API failed');
    
    const stats = data.statistics;
    if (!stats) throw new Error('Statistics data missing');
    
    // Verify structure
    if (typeof stats.totalVulnerabilities !== 'number') throw new Error('totalVulnerabilities missing');
    if (typeof stats.totalHosts !== 'number') throw new Error('totalHosts missing');
    if (!stats.severityBreakdown) throw new Error('severityBreakdown missing');
    
    return stats;
  });
  
  // 2.14 - Test AI Analysis
  await test('2.14 AI Analysis', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/ai-analysis`, {
      method: 'POST',
      body: JSON.stringify({ 
        scanId,
        analysisType: 'summary'
      }),
    });
    
    if (!data.success && !data.analysis) throw new Error('AI analysis failed');
    return { hasAnalysis: !!data.analysis };
  });
  
  // 2.15 - Test Remediation Plan Generation
  await test('2.15 Remediation Plan', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/remediation?scanId=${scanId}`);
    if (!data.success) throw new Error('Remediation API failed');
    
    return {
      hasPlan: !!data.plan,
      prioritizedFixes: data.plan?.prioritizedFixes?.length || 0
    };
  });
  
  return endPhase();
}


// ============================================================================
// PHASE 2B: DATABASE INTEGRATION VERIFICATION
// ============================================================================

async function runPhase2B(): Promise<boolean> {
  startPhase('PHASE 2B: DATABASE INTEGRATION');
  
  // 2B.1 - PostgreSQL Connection
  await test('2B.1 PostgreSQL Connection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.success) throw new Error('PostgreSQL init failed');
    if (!data.connections?.postgres) throw new Error('PostgreSQL not connected');
    return { postgres: data.connections.postgres };
  });
  
  // 2B.2 - MongoDB Connection
  await test('2B.2 MongoDB Connection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    if (!data.connections?.mongodb) throw new Error('MongoDB not connected');
    return { mongodb: data.connections.mongodb };
  });
  
  // 2B.3 - Redis Connection (may be localhost only)
  await test('2B.3 Redis Connection', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/db/init`);
    // Redis might not be available in all environments
    return { redis: data.connections?.redis || 'not configured' };
  });
  
  // 2B.4 - Qdrant Vector DB
  await test('2B.4 Qdrant Vector DB', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/qdrant/init`);
    if (!data.success && !data.exists) throw new Error('Qdrant init failed');
    return { qdrant: 'connected' };
  });
  
  // 2B.5 - Verify data persisted to PostgreSQL
  await test('2B.5 Data in PostgreSQL', async () => {
    // Query vulnerabilities - they should be in PostgreSQL
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities?scanId=${scanId}&limit=5`);
    if (!data.success) throw new Error('Failed to query PostgreSQL');
    return { recordsFound: data.data?.length || 0 };
  });
  
  // 2B.6 - Verify raw data in MongoDB
  await test('2B.6 Raw Data in MongoDB', async () => {
    // The scan API stores raw outputs in MongoDB
    const scans = await fetchJSON(`${BASE_URL}/api/scan?scanId=${scanId}`);
    if (!scans) throw new Error('Scan not found');
    return { hasResults: !!scans.results };
  });
  
  return endPhase();
}

// ============================================================================
// PHASE 3: RAG CHATBOT & REPORTING
// ============================================================================

async function runPhase3(): Promise<boolean> {
  startPhase('PHASE 3: RAG CHATBOT & REPORTING');
  
  // 3.1 - Basic chat query
  await test('3.1 Basic Chat Query', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/chat`, {
      method: 'POST',
      body: JSON.stringify({
        message: 'What vulnerabilities were found?',
        context: { scanId }
      }),
    });
    
    if (!data.response) throw new Error('No chat response');
    if (data.response.length < 10) throw new Error('Response too short');
    
    return { responseLength: data.response.length };
  });
  
  // 3.2 - Context-aware query
  await test('3.2 Context-Aware Query', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/chat`, {
      method: 'POST',
      body: JSON.stringify({
        message: `Summarize the security posture of ${TEST_TARGET}`,
        context: { scanId }
      }),
    });
    
    if (!data.response) throw new Error('No chat response');
    return { responseLength: data.response.length };
  });
  
  // 3.3 - Remediation query
  await test('3.3 Remediation Query', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/chat`, {
      method: 'POST',
      body: JSON.stringify({
        message: 'What are the top priority fixes I should implement?',
        context: { scanId }
      }),
    });
    
    if (!data.response) throw new Error('No chat response');
    return { responseLength: data.response.length };
  });
  
  // 3.4 - Empty message handling
  await test('3.4 Empty Message Handling', async () => {
    try {
      const data = await fetchJSON(`${BASE_URL}/api/chat`, {
        method: 'POST',
        body: JSON.stringify({ message: '' }),
      });
      // Should either return error or handle gracefully
      return { handled: true };
    } catch (error: any) {
      // Expected to fail gracefully
      return { handled: true, error: error.message };
    }
  });
  
  // 3.5 - Compliance Report - OWASP Top 10
  await test('3.5 OWASP Top 10 Compliance', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/compliance?framework=OWASP%20Top%2010&scanId=${scanId}`);
    if (!data.success) throw new Error('Compliance API failed');
    
    const report = data.report;
    if (!report) throw new Error('No compliance report');
    if (!report.summary) throw new Error('Report missing summary');
    
    return {
      framework: report.framework,
      score: report.summary.complianceScore,
      requirements: report.summary.totalRequirements
    };
  });
  
  // 3.6 - Compliance Report - PCI DSS
  await test('3.6 PCI DSS Compliance', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/compliance?framework=PCI%20DSS%204.0&scanId=${scanId}`);
    if (!data.success) throw new Error('PCI DSS compliance failed');
    
    return {
      framework: data.report?.framework,
      score: data.report?.summary?.complianceScore
    };
  });
  
  // 3.7 - Export JSON
  await test('3.7 Export JSON', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json&scanId=${scanId}`);
    if (!response.ok) throw new Error('JSON export failed');
    
    const data = await response.json();
    if (!data.vulnerabilities) throw new Error('Export missing vulnerabilities');
    if (!data.exportedAt) throw new Error('Export missing timestamp');
    
    return {
      vulnerabilities: data.vulnerabilities.length,
      hosts: data.hosts?.length || 0
    };
  });
  
  // 3.8 - Export CSV
  await test('3.8 Export CSV', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv&scanId=${scanId}`);
    if (!response.ok) throw new Error('CSV export failed');
    
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('text/csv')) throw new Error('Wrong content type for CSV');
    
    const text = await response.text();
    const lines = text.split('\n').filter(l => l.trim());
    
    return {
      lines: lines.length,
      hasHeader: lines[0]?.includes('id') || lines[0]?.includes('title')
    };
  });
  
  // 3.9 - Export SARIF
  await test('3.9 Export SARIF', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif&scanId=${scanId}`);
    if (!response.ok) throw new Error('SARIF export failed');
    
    const data = await response.json();
    if (!data.$schema) throw new Error('SARIF missing schema');
    if (!data.runs || !Array.isArray(data.runs)) throw new Error('SARIF missing runs');
    
    return {
      schema: data.$schema,
      runsCount: data.runs.length
    };
  });
  
  // 3.10 - Export HTML
  await test('3.10 Export HTML', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html&scanId=${scanId}`);
    if (!response.ok) throw new Error('HTML export failed');
    
    const contentType = response.headers.get('content-type');
    if (!contentType?.includes('text/html')) throw new Error('Wrong content type for HTML');
    
    const text = await response.text();
    if (!text.includes('<!DOCTYPE html>') && !text.includes('<html')) {
      throw new Error('Invalid HTML document');
    }
    
    return { length: text.length };
  });
  
  // 3.11 - Invalid export format handling
  await test('3.11 Invalid Export Format', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=invalid&scanId=${scanId}`);
    // Should return error, not crash
    return { 
      handled: true,
      status: response.status
    };
  });
  
  // 3.12 - Trending data
  await test('3.12 Trending Data', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/trending?target=${TEST_TARGET}`);
    // May not have historical data, but API should work
    return { 
      success: data.success !== false,
      dataPoints: data.data?.length || 0
    };
  });
  
  return endPhase();
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function main() {
  console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
  console.log('‚ïë     VULNERABILITY SCANNER - DEEP INTEGRATION TEST (SQA Level)       ‚ïë');
  console.log('‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£');
  console.log(`‚ïë  Target: ${TEST_TARGET.padEnd(58)}‚ïë`);
  console.log(`‚ïë  Started: ${new Date().toISOString().padEnd(57)}‚ïë`);
  console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
  
  const startTime = Date.now();
  
  // Run Phase 1
  const phase1Passed = await runPhase1();
  
  // Check if we have scan results (critical for Phase 2)
  const hasScanResults = phase1RawResults && Object.keys(phase1RawResults).length > 0;
  
  if (!hasScanResults) {
    console.log('\n' + '‚ïê'.repeat(70));
    console.log('‚ùå PHASE 1 FAILED - CANNOT PROCEED TO PHASE 2');
    console.log('‚ïê'.repeat(70));
    console.log('\nPhase 2 requires valid scan results from Phase 1.');
    console.log('Please fix Phase 1 issues before testing Phase 2.\n');
    printSummary(startTime);
    process.exit(1);
  }
  
  // If only non-critical tests failed, continue
  if (!phase1Passed && hasScanResults) {
    console.log('\n‚ö†Ô∏è  Some non-critical Phase 1 tests failed, but scan completed. Continuing...\n');
  }
  
  // Run Phase 2 (only if Phase 1 passed)
  const phase2Passed = await runPhase2();
  
  // Continue to Phase 3 even if some Phase 2 tests failed
  // (as long as core normalization/enrichment worked)
  if (!phase2Passed) {
    console.log('\n‚ö†Ô∏è  Some Phase 2 tests failed, but continuing to Phase 3...\n');
  }
  
  // Run Phase 2B (Database Integration)
  const phase2BPassed = await runPhase2B();
  
  // Run Phase 3 (even if 2B has issues, as some DBs may not be configured)
  const phase3Passed = await runPhase3();
  
  // Print final summary
  printSummary(startTime);
  
  // Exit with appropriate code
  const allPassed = phase1Passed && phase2Passed && phase3Passed;
  process.exit(allPassed ? 0 : 1);
}

function printSummary(startTime: number) {
  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  
  console.log('\n' + '‚ïê'.repeat(70));
  console.log('üìä FINAL SUMMARY');
  console.log('‚ïê'.repeat(70));
  
  let totalTests = 0;
  let totalPassed = 0;
  let totalFailed = 0;
  
  for (const phase of results) {
    const passed = phase.tests.filter(t => t.passed).length;
    const failed = phase.tests.filter(t => !t.passed).length;
    totalTests += phase.tests.length;
    totalPassed += passed;
    totalFailed += failed;
    
    const icon = phase.passed ? '‚úÖ' : '‚ùå';
    console.log(`${icon} ${phase.phase}: ${passed}/${phase.tests.length} (${(phase.totalTime/1000).toFixed(1)}s)`);
  }
  
  console.log('‚îÄ'.repeat(70));
  console.log(`Total Tests: ${totalTests}`);
  console.log(`‚úÖ Passed: ${totalPassed}`);
  console.log(`‚ùå Failed: ${totalFailed}`);
  console.log(`‚è±Ô∏è  Total Time: ${totalTime}s`);
  console.log(`üìä Pass Rate: ${((totalPassed/totalTests)*100).toFixed(1)}%`);
  console.log('‚ïê'.repeat(70));
  
  if (totalFailed === 0) {
    console.log('üéâ ALL TESTS PASSED!');
  } else {
    console.log(`‚ö†Ô∏è  ${totalFailed} test(s) failed`);
    
    // List failed tests
    console.log('\nFailed Tests:');
    for (const phase of results) {
      for (const test of phase.tests.filter(t => !t.passed)) {
        console.log(`  - [${phase.phase}] ${test.name}: ${test.error}`);
      }
    }
  }
  
  console.log('');
}

// Run the tests
main().catch(error => {
  console.error('Test execution failed:', error);
  process.exit(1);
});
