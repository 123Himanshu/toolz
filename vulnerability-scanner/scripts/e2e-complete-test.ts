/**
 * COMPLETE END-TO-END TEST
 * 
 * Tests the entire vulnerability scanner pipeline:
 * 1. Target Classification
 * 2. Scanning (all working tools)
 * 3. Phase 2 Processing (normalization, enrichment, correlation)
 * 4. Phase 3 (RAG chatbot, compliance, exports)
 * 5. Database Integration
 */

const BASE_URL = 'http://localhost:3000';
const TEST_TARGET = 'scanme.nmap.org';

interface TestResult {
  name: string;
  passed: boolean;
  duration: number;
  error?: string;
  data?: any;
}

const results: TestResult[] = [];
let scanId: string | null = null;

async function fetchJSON(url: string, options?: RequestInit): Promise<any> {
  const response = await fetch(url, {
    ...options,
    headers: { 'Content-Type': 'application/json', ...options?.headers },
  });
  const text = await response.text();
  if (!response.ok) throw new Error(`HTTP ${response.status}: ${text.substring(0, 200)}`);
  try { return JSON.parse(text); } catch { return { raw: text }; }
}

async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function test(name: string, fn: () => Promise<any>): Promise<boolean> {
  const start = Date.now();
  try {
    const data = await fn();
    const duration = Date.now() - start;
    results.push({ name, passed: true, duration, data });
    console.log(`  âœ… ${name} (${duration}ms)`);
    return true;
  } catch (error: any) {
    const duration = Date.now() - start;
    results.push({ name, passed: false, duration, error: error.message });
    console.log(`  âŒ ${name}: ${error.message}`);
    return false;
  }
}

// ============================================================================
// SECTION 1: TARGET CLASSIFICATION
// ============================================================================
async function testTargetClassification() {
  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸŽ¯ SECTION 1: TARGET CLASSIFICATION');
  console.log('â•'.repeat(70));

  await test('1.1 Classify IP Address', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets?target=192.168.1.1`);
    if (!data.success || data.type !== 'ip') throw new Error('Classification failed');
    return data;
  });

  await test('1.2 Classify Domain', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets?target=example.com`);
    if (!data.success || data.type !== 'domain') throw new Error('Classification failed');
    return data;
  });

  await test('1.3 Classify URL', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets?target=https://example.com/path`);
    if (!data.success || data.type !== 'url') throw new Error('Classification failed');
    return data;
  });

  await test('1.4 Classify CIDR', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets?target=10.0.0.0/8`);
    if (!data.success || data.type !== 'cidr') throw new Error('Classification failed');
    return data;
  });

  await test('1.5 Batch Classification', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/classify-targets`, {
      method: 'POST',
      body: JSON.stringify({
        targets: ['192.168.1.1', 'example.com', 'https://test.com', '10.0.0.0/24']
      }),
    });
    if (!data.success || data.stats.total !== 4) throw new Error('Batch classification failed');
    return data.stats;
  });
}

// ============================================================================
// SECTION 2: SCANNING
// ============================================================================
async function testScanning() {
  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸ” SECTION 2: SCANNING');
  console.log('â•'.repeat(70));

  // Create comprehensive scan
  await test('2.1 Create Active Scan', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/scan`, {
      method: 'POST',
      body: JSON.stringify({
        target: TEST_TARGET,
        scanType: 'active',
        tools: {
          network: ['nmap', 'naabu', 'rustscan'],
          web: ['nuclei', 'httpx'],
          system: [],
        },
      }),
    });
    if (!data.success || !data.scanId) throw new Error('Scan creation failed');
    scanId = data.scanId;
    return { scanId };
  });

  // Wait for completion
  await test('2.2 Wait for Scan Completion', async () => {
    let attempts = 0;
    const maxAttempts = 60; // 5 minutes
    
    while (attempts < maxAttempts) {
      const scan = await fetchJSON(`${BASE_URL}/api/scan?scanId=${scanId}`);
      
      const progress = Object.entries(scan.progress || {})
        .map(([tool, status]) => `${tool}:${status}`)
        .join(', ');
      process.stdout.write(`\r    Progress: ${progress}`.padEnd(80));
      
      if (scan.status === 'completed' || scan.status === 'failed') {
        console.log('');
        
        const completed = Object.values(scan.progress || {}).filter(s => s === 'completed').length;
        const total = Object.keys(scan.progress || {}).length;
        
        if (completed === 0) throw new Error('No tools completed');
        
        return { status: scan.status, completed, total };
      }
      
      await sleep(5000);
      attempts++;
    }
    throw new Error('Scan timed out');
  });

  // Verify each tool
  await test('2.3 Verify Nmap Results', async () => {
    const scan = await fetchJSON(`${BASE_URL}/api/scan?scanId=${scanId}`);
    const result = scan.results?.nmap;
    if (!result?.success) throw new Error('Nmap failed');
    return { hosts: Object.keys(result.data?.hosts || {}).length };
  });

  await test('2.4 Verify Nuclei Results', async () => {
    const scan = await fetchJSON(`${BASE_URL}/api/scan?scanId=${scanId}`);
    const result = scan.results?.nuclei;
    if (!result?.success) throw new Error('Nuclei failed');
    return { vulnerabilities: result.vulnerabilities_found || 0 };
  });

  await test('2.5 Verify Phase 2 Triggered', async () => {
    const scan = await fetchJSON(`${BASE_URL}/api/scan?scanId=${scanId}`);
    if (!scan.phase2?.processed) throw new Error('Phase 2 not processed');
    return scan.phase2;
  });
}

// ============================================================================
// SECTION 3: PHASE 2 - NORMALIZATION & ENRICHMENT
// ============================================================================
async function testPhase2() {
  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸ”¬ SECTION 3: PHASE 2 - NORMALIZATION & ENRICHMENT');
  console.log('â•'.repeat(70));

  await test('3.1 Vulnerabilities API', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/vulnerabilities`);
    if (!data.success) throw new Error('API failed');
    return { count: data.vulnerabilities?.length || 0 };
  });

  await test('3.2 Hosts API', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/hosts`);
    if (!data.success) throw new Error('API failed');
    return { count: data.hosts?.length || 0 };
  });

  await test('3.3 Services API', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/services`);
    if (!data.success) throw new Error('API failed');
    return { count: data.services?.length || 0 };
  });

  await test('3.4 Threat Intel Enrichment', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/threat-intel`, {
      method: 'POST',
      body: JSON.stringify({ cveId: 'CVE-2021-44228' }),
    });
    if (!data.success) throw new Error('Enrichment failed');
    return { cve: data.cve };
  });

  await test('3.5 MITRE ATT&CK Mapping', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/mitre`);
    if (!data.success) throw new Error('Mapping failed');
    return { techniques: data.summary?.techniquesFound || 0 };
  });

  await test('3.6 Zero-Day Exposure Score', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/zdes`);
    return { hosts: data.results?.length || 0 };
  });

  await test('3.7 Attack Paths', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/attack-paths`);
    if (!data.success) throw new Error('Attack paths failed');
    return { paths: data.attackPaths?.length || 0 };
  });

  await test('3.8 Correlation', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/correlation`);
    if (!data.success) throw new Error('Correlation failed');
    return { groups: data.groups?.length || 0 };
  });

  await test('3.9 Statistics', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/statistics`);
    if (!data.success) throw new Error('Statistics failed');
    return data.statistics?.overview;
  });

  await test('3.10 Remediation Plan', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/remediation`);
    if (!data.success) throw new Error('Remediation failed');
    return { actions: data.plan?.prioritizedActions?.length || 0 };
  });

  await test('3.11 Trending', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/trending`);
    if (!data.success) throw new Error('Trending failed');
    return { hasData: !!data.trending };
  });
}

// ============================================================================
// SECTION 4: PHASE 3 - RAG CHATBOT & REPORTING
// ============================================================================
async function testPhase3() {
  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸ¤– SECTION 4: PHASE 3 - RAG CHATBOT & REPORTING');
  console.log('â•'.repeat(70));

  await test('4.1 Chat - Basic Query', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/chat`, {
      method: 'POST',
      body: JSON.stringify({
        message: 'What vulnerabilities were found?',
        scanId,
      }),
    });
    if (!data.response) throw new Error('No response');
    return { length: data.response.length };
  });

  await test('4.2 Chat - Remediation Query', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/chat`, {
      method: 'POST',
      body: JSON.stringify({
        message: 'How do I fix the security issues?',
        scanId,
      }),
    });
    if (!data.response) throw new Error('No response');
    return { length: data.response.length };
  });

  await test('4.3 OWASP Top 10 Compliance', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/compliance?framework=owasp`);
    if (!data.success) throw new Error('Compliance failed');
    return { categories: data.compliance?.categories?.length || 0 };
  });

  await test('4.4 PCI DSS Compliance', async () => {
    const data = await fetchJSON(`${BASE_URL}/api/phase2/compliance?framework=pci-dss`);
    if (!data.success) throw new Error('Compliance failed');
    return { requirements: data.compliance?.requirements?.length || 0 };
  });

  await test('4.5 Export JSON', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=json&scanId=${scanId}`);
    if (!response.ok) throw new Error('Export failed');
    const text = await response.text();
    return { size: text.length };
  });

  await test('4.6 Export CSV', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=csv&scanId=${scanId}`);
    if (!response.ok) throw new Error('Export failed');
    return { format: 'CSV' };
  });

  await test('4.7 Export SARIF', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=sarif&scanId=${scanId}`);
    if (!response.ok) throw new Error('Export failed');
    return { format: 'SARIF' };
  });

  await test('4.8 Export HTML', async () => {
    const response = await fetch(`${BASE_URL}/api/phase2/export?format=html&scanId=${scanId}`);
    if (!response.ok) throw new Error('Export failed');
    return { format: 'HTML' };
  });
}

// ============================================================================
// MAIN
// ============================================================================
async function main() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘        COMPLETE END-TO-END VULNERABILITY SCANNER TEST                â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log(`â•‘  Target: ${TEST_TARGET.padEnd(58)}â•‘`);
  console.log(`â•‘  Started: ${new Date().toISOString().padEnd(57)}â•‘`);
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

  const startTime = Date.now();

  // Run all sections
  await testTargetClassification();
  await testScanning();
  await testPhase2();
  await testPhase3();

  // Print summary
  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  const passed = results.filter(r => r.passed).length;
  const failed = results.filter(r => !r.passed).length;
  const passRate = ((passed / results.length) * 100).toFixed(1);

  console.log('\n' + 'â•'.repeat(70));
  console.log('ðŸ“Š FINAL SUMMARY');
  console.log('â•'.repeat(70));

  // By section
  const sections = [
    { name: 'Target Classification', prefix: '1.' },
    { name: 'Scanning', prefix: '2.' },
    { name: 'Phase 2 Processing', prefix: '3.' },
    { name: 'Phase 3 Reporting', prefix: '4.' },
  ];

  for (const section of sections) {
    const sectionResults = results.filter(r => r.name.startsWith(section.prefix));
    const sectionPassed = sectionResults.filter(r => r.passed).length;
    const status = sectionPassed === sectionResults.length ? 'âœ…' : 'âš ï¸';
    console.log(`${status} ${section.name}: ${sectionPassed}/${sectionResults.length} passed`);
  }

  console.log('â”€'.repeat(70));
  console.log(`Total Tests: ${results.length}`);
  console.log(`âœ… Passed: ${passed}`);
  console.log(`âŒ Failed: ${failed}`);
  console.log(`â±ï¸  Total Time: ${totalTime}s`);
  console.log(`ðŸ“Š Pass Rate: ${passRate}%`);
  console.log('â•'.repeat(70));

  if (failed > 0) {
    console.log('\nFailed Tests:');
    results.filter(r => !r.passed).forEach(r => {
      console.log(`  - ${r.name}: ${r.error}`);
    });
  }

  // Exit with appropriate code
  process.exit(failed > 0 ? 1 : 0);
}

main().catch(console.error);
