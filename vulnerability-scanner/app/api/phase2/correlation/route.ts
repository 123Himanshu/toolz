/**
 * Cross-Scanner Correlation API
 * Groups related vulnerabilities found by different scanners
 */

import { NextRequest, NextResponse } from 'next/server';
import { getPhase2Storage } from '@/lib/phase2/storage';

interface CorrelationGroup {
  id: string;
  primaryVuln: any;
  relatedVulns: any[];
  scanners: string[];
  confidence: number;
  cves: string[];
}

function correlateVulnerabilities(vulns: any[]): CorrelationGroup[] {
  const groups: Map<string, CorrelationGroup> = new Map();

  for (const vuln of vulns) {
    // Create correlation key based on CVE, host, and port
    const cves = vuln.cve || [];
    const host = vuln.host || vuln.target || 'unknown';
    const port = vuln.port || 0;

    // Try to find existing group
    let matched = false;

    for (const [key, group] of groups) {
      // Match by CVE
      if (cves.length > 0 && group.cves.some(c => cves.includes(c))) {
        group.relatedVulns.push(vuln);
        group.scanners = [...new Set([...group.scanners, vuln.scanner || 'unknown'])];
        group.cves = [...new Set([...group.cves, ...cves])];
        group.confidence = Math.min(1, group.confidence + 0.1);
        matched = true;
        break;
      }

      // Match by host + port + similar title
      if (group.primaryVuln.host === host && group.primaryVuln.port === port) {
        const titleSimilarity = calculateSimilarity(
          group.primaryVuln.title || '',
          vuln.title || ''
        );
        if (titleSimilarity > 0.7) {
          group.relatedVulns.push(vuln);
          group.scanners = [...new Set([...group.scanners, vuln.scanner || 'unknown'])];
          group.confidence = Math.min(1, group.confidence + 0.05);
          matched = true;
          break;
        }
      }
    }

    if (!matched) {
      // Create new group
      const groupId = `grp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      groups.set(groupId, {
        id: groupId,
        primaryVuln: vuln,
        relatedVulns: [],
        scanners: [vuln.scanner || 'unknown'],
        confidence: 0.5,
        cves: cves
      });
    }
  }

  return Array.from(groups.values());
}

function calculateSimilarity(str1: string, str2: string): number {
  if (!str1 || !str2) return 0;
  
  const s1 = str1.toLowerCase();
  const s2 = str2.toLowerCase();
  
  if (s1 === s2) return 1;
  
  // Simple word overlap similarity
  const words1 = new Set(s1.split(/\s+/));
  const words2 = new Set(s2.split(/\s+/));
  
  let overlap = 0;
  for (const word of words1) {
    if (words2.has(word)) overlap++;
  }
  
  return overlap / Math.max(words1.size, words2.size);
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const scanId = searchParams.get('scanId');

    const storage = getPhase2Storage();
    let vulns: any[];

    if (scanId) {
      vulns = storage.getVulnerabilitiesByScan(scanId);
    } else {
      vulns = storage.queryVulnerabilities({}).data;
    }

    const groups = correlateVulnerabilities(vulns);

    // Calculate statistics
    const multiScannerGroups = groups.filter(g => g.scanners.length > 1);
    const highConfidenceGroups = groups.filter(g => g.confidence > 0.7);

    return NextResponse.json({
      success: true,
      total: groups.length,
      groups: groups.slice(0, 100), // Limit response size
      statistics: {
        totalVulnerabilities: vulns.length,
        correlationGroups: groups.length,
        multiScannerCorrelations: multiScannerGroups.length,
        highConfidenceCorrelations: highConfidenceGroups.length,
        uniqueScanners: [...new Set(vulns.map(v => v.scanner || 'unknown'))],
        averageConfidence: groups.length > 0 
          ? groups.reduce((sum, g) => sum + g.confidence, 0) / groups.length 
          : 0
      }
    });
  } catch (error) {
    console.error('Correlation error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to correlate vulnerabilities' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { vulnerabilities } = body;

    if (!vulnerabilities || !Array.isArray(vulnerabilities)) {
      return NextResponse.json(
        { success: false, error: 'Vulnerabilities array required' },
        { status: 400 }
      );
    }

    const groups = correlateVulnerabilities(vulnerabilities);

    return NextResponse.json({
      success: true,
      total: groups.length,
      groups
    });
  } catch (error) {
    console.error('Correlation POST error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to correlate vulnerabilities' },
      { status: 500 }
    );
  }
}
