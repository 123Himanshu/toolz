/**
 * AI-Powered Vulnerability Analysis API
 * Provides AI analysis when CVE/threat intel is unavailable
 */

import { NextRequest, NextResponse } from 'next/server';
import { getPhase2Storage } from '@/lib/phase2/storage';
import {
  analyzeWithAI,
  generateAIThreatIntel,
  predictAttackPaths,
  generateRemediationPlan,
  classifyUnknownVuln,
  enrichWithAIFallback,
} from '@/lib/phase2/ai-analysis';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const action = searchParams.get('action');
    const vulnId = searchParams.get('vulnId');
    const scanId = searchParams.get('scanId');

    const storage = getPhase2Storage();

    switch (action) {
      case 'analyze': {
        // Analyze single vulnerability
        if (!vulnId) {
          return NextResponse.json({ success: false, error: 'vulnId required' }, { status: 400 });
        }
        const vuln = storage.getVulnerability(vulnId);
        if (!vuln) {
          return NextResponse.json({ success: false, error: 'Vulnerability not found' }, { status: 404 });
        }
        const analysis = await analyzeWithAI(vuln);
        return NextResponse.json({ success: true, analysis });
      }

      case 'threat-intel': {
        // Generate AI threat intel
        if (!vulnId) {
          return NextResponse.json({ success: false, error: 'vulnId required' }, { status: 400 });
        }
        const vuln = storage.getVulnerability(vulnId);
        if (!vuln) {
          return NextResponse.json({ success: false, error: 'Vulnerability not found' }, { status: 404 });
        }
        const intel = await generateAIThreatIntel(vuln);
        return NextResponse.json({ success: true, threatIntel: intel });
      }

      case 'classify': {
        // Classify unknown vulnerability
        if (!vulnId) {
          return NextResponse.json({ success: false, error: 'vulnId required' }, { status: 400 });
        }
        const vuln = storage.getVulnerability(vulnId);
        if (!vuln) {
          return NextResponse.json({ success: false, error: 'Vulnerability not found' }, { status: 404 });
        }
        const classification = await classifyUnknownVuln(vuln);
        return NextResponse.json({ success: true, classification });
      }

      case 'attack-paths': {
        // Predict attack paths
        const vulns = storage.queryVulnerabilities({ scanId: scanId || undefined }).data;
        const paths = await predictAttackPaths(vulns);
        return NextResponse.json({ success: true, attackPaths: paths });
      }

      case 'remediation': {
        // Generate remediation plan
        const vulns = storage.queryVulnerabilities({ scanId: scanId || undefined }).data;
        const plan = await generateRemediationPlan(vulns);
        return NextResponse.json({ success: true, remediationPlan: plan });
      }

      default: {
        // Return available actions
        return NextResponse.json({
          success: true,
          availableActions: [
            { action: 'analyze', description: 'AI analysis of vulnerability', params: ['vulnId'] },
            { action: 'threat-intel', description: 'Generate AI threat intel', params: ['vulnId'] },
            { action: 'classify', description: 'Classify unknown vulnerability', params: ['vulnId'] },
            { action: 'attack-paths', description: 'Predict attack paths', params: ['scanId?'] },
            { action: 'remediation', description: 'Generate remediation plan', params: ['scanId?'] },
          ]
        });
      }
    }
  } catch (error: any) {
    console.error('AI Analysis API error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { action, vulnIds, scanId } = body;

    const storage = getPhase2Storage();

    switch (action) {
      case 'enrich-all': {
        // Enrich all vulnerabilities with AI fallback
        const vulns = storage.queryVulnerabilities({ scanId: scanId || undefined }).data;
        const enrichedCount = { total: vulns.length, aiEnriched: 0 };

        for (const vuln of vulns) {
          // Check if already has good data
          if (!vuln.cve || vuln.cve.length === 0 || vuln.title === 'Unknown') {
            const enriched = await enrichWithAIFallback(vuln, null);
            storage.storeVulnerability(enriched);
            enrichedCount.aiEnriched++;
          }
        }

        return NextResponse.json({
          success: true,
          message: `Enriched ${enrichedCount.aiEnriched} of ${enrichedCount.total} vulnerabilities with AI`,
          enrichedCount
        });
      }

      case 'batch-analyze': {
        // Batch analyze specific vulnerabilities
        if (!vulnIds || !Array.isArray(vulnIds)) {
          return NextResponse.json({ success: false, error: 'vulnIds array required' }, { status: 400 });
        }

        const results = [];
        for (const id of vulnIds.slice(0, 10)) { // Limit to 10
          const vuln = storage.getVulnerability(id);
          if (vuln) {
            const analysis = await analyzeWithAI(vuln);
            results.push({ vulnId: id, analysis });
          }
        }

        return NextResponse.json({ success: true, results });
      }

      default:
        return NextResponse.json({ success: false, error: 'Unknown action' }, { status: 400 });
    }
  } catch (error: any) {
    console.error('AI Analysis POST error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
