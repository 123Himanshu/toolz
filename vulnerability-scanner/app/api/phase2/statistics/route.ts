/**
 * Phase 2 API: Statistics
 * GET /api/phase2/statistics
 * 
 * Get overall statistics and dashboard data
 */

import { NextRequest, NextResponse } from 'next/server';
import { getOverallStatistics, getPhase2Storage, queryVulnerabilities } from '@/lib/phase2';

export async function GET(request: NextRequest) {
  try {
    const storage = getPhase2Storage();
    const stats = getOverallStatistics();

    // Get recent vulnerabilities
    const recentVulns = queryVulnerabilities({
      sortBy: 'discoveredAt',
      sortOrder: 'desc',
      limit: 10
    });

    // Get top risky hosts
    const hosts = storage.getAllHosts();
    const topRiskyHosts = [...hosts]
      .sort((a, b) => b.riskScore - a.riskScore)
      .slice(0, 5)
      .map(h => ({
        ip: h.ip,
        hostname: h.hostname,
        riskScore: h.riskScore,
        vulnerabilities: Object.values(h.vulnerabilityCount).reduce((s, v) => s + v, 0),
        criticalCount: h.vulnerabilityCount.critical,
        highCount: h.vulnerabilityCount.high
      }));

    // Get scanner comparison
    const scannerComparison = Object.entries(stats.scannerBreakdown).map(([scanner, count]) => ({
      scanner,
      findings: count,
      percentage: Math.round((count / stats.totalVulnerabilities) * 100)
    }));

    // Calculate trends (would use historical data in production)
    const trends = {
      vulnerabilities: {
        current: stats.totalVulnerabilities,
        change: 0,
        trend: 'stable' as const
      },
      hosts: {
        current: stats.totalHosts,
        change: 0,
        trend: 'stable' as const
      },
      criticalFindings: {
        current: stats.severityBreakdown.critical,
        change: 0,
        trend: 'stable' as const
      }
    };

    return NextResponse.json({
      success: true,
      statistics: {
        overview: {
          totalVulnerabilities: stats.totalVulnerabilities,
          totalHosts: stats.totalHosts,
          totalServices: stats.totalServices,
          totalSessions: stats.totalSessions
        },
        severity: stats.severityBreakdown,
        scanners: scannerComparison,
        topRiskyHosts,
        recentVulnerabilities: recentVulns.data.map(v => ({
          id: v.id,
          title: v.title,
          severity: v.severity,
          host: v.host,
          scanner: v.scanner,
          discoveredAt: v.discoveredAt
        })),
        trends
      }
    });

  } catch (error) {
    console.error('Statistics query error:', error);
    return NextResponse.json(
      { error: 'Query failed', details: String(error) },
      { status: 500 }
    );
  }
}
