/**
 * MITRE ATT&CK Mapping API
 */

import { NextRequest, NextResponse } from 'next/server';
import { mapToATTCK, getATTCKSummary, enrichWithATTCK } from '@/lib/phase2/mitre-attck';
import { getPhase2Storage } from '@/lib/phase2/storage';

export const dynamic = 'force-dynamic';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const scanId = searchParams.get('scanId');
    const vulnId = searchParams.get('vulnId');

    // Get vulnerabilities
    const storage = getPhase2Storage();
    const vulnsResult = storage.queryVulnerabilities({ scanId: scanId || undefined });
    const vulns = vulnsResult.data;

    if (vulnId) {
      // Map single vulnerability
      const vuln = vulns.find(v => v.id === vulnId);
      if (!vuln) {
        return NextResponse.json({ success: false, error: 'Vulnerability not found' }, { status: 404 });
      }

      const mapping = mapToATTCK(vuln);
      return NextResponse.json({
        success: true,
        vulnerability: vuln.title,
        mapping
      });
    }

    // Get summary for all vulnerabilities
    const summary = getATTCKSummary(vulns);
    const enriched = enrichWithATTCK(vulns);

    return NextResponse.json({
      success: true,
      total: vulns.length,
      summary: {
        techniquesFound: summary.techniques.length,
        tacticsFound: summary.tactics.length,
        coverage: summary.coverage.toFixed(1) + '%'
      },
      techniques: summary.techniques.slice(0, 20),
      tactics: summary.tactics,
      vulnerabilities: enriched.slice(0, 10).map(v => ({
        id: v.id,
        title: v.title,
        severity: v.severity.label,
        mitreTechniques: (v as any).mitreTechniques || [],
        mitreTactics: (v as any).mitreTactics || []
      }))
    });
  } catch (error: any) {
    console.error('MITRE ATT&CK API error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}
