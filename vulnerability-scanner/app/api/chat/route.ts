import { NextRequest, NextResponse } from 'next/server';
import { getAICompletion } from '@/lib/multi-ai-provider';
import { searchScanResults, getScansByDateRange, getScanStatistics } from '@/lib/qdrant-client';
import { getPhase2Storage, getScanSummary } from '@/lib/phase2';
import { generateComplianceReport, getAvailableFrameworks } from '@/lib/phase2/compliance';
import { parseTarget, validateTarget } from '@/lib/target-parser';
import { analyzeTarget } from '@/lib/scan-intelligence';

export const dynamic = 'force-dynamic';

// Tool recommendation based on target type
interface ToolRecommendation {
  tool: string;
  category: 'network' | 'web' | 'system' | 'recon';
  reason: string;
  priority: 'high' | 'medium' | 'low';
}

function getToolRecommendations(target: string): {
  recommendations: ToolRecommendation[];
  targetType: string;
  scanStrategy: string;
} {
  const parsed = parseTarget(target);
  const recommendations: ToolRecommendation[] = [];
  let scanStrategy = '';

  switch (parsed.type) {
    case 'ip':
      scanStrategy = 'Network-focused scan for IP address';
      recommendations.push(
        { tool: 'nmap', category: 'network', reason: 'Comprehensive port and service detection', priority: 'high' },
        { tool: 'naabu', category: 'network', reason: 'Fast initial port discovery', priority: 'high' },
        { tool: 'rustscan', category: 'network', reason: 'Ultra-fast port scanning', priority: 'medium' },
        { tool: 'nuclei', category: 'web', reason: 'Vulnerability scanning if web services found', priority: 'medium' },
      );
      break;

    case 'domain':
    case 'url':
      scanStrategy = 'Web application and domain reconnaissance';
      recommendations.push(
        { tool: 'subfinder', category: 'recon', reason: 'Subdomain enumeration', priority: 'high' },
        { tool: 'httpx', category: 'web', reason: 'HTTP probing and tech detection', priority: 'high' },
        { tool: 'nuclei', category: 'web', reason: 'CVE and vulnerability scanning (5000+ templates)', priority: 'high' },
        { tool: 'nmap', category: 'network', reason: 'Port and service discovery', priority: 'medium' },
        { tool: 'nikto', category: 'web', reason: 'Web server vulnerability scanning', priority: 'medium' },
        { tool: 'wapiti', category: 'web', reason: 'Web application vulnerability scanning', priority: 'low' },
      );
      break;

    case 'cidr':
      scanStrategy = 'Network range scanning';
      recommendations.push(
        { tool: 'naabu', category: 'network', reason: 'Fast port scanning for IP ranges', priority: 'high' },
        { tool: 'masscan', category: 'network', reason: 'High-speed network scanning', priority: 'high' },
        { tool: 'nmap', category: 'network', reason: 'Detailed service detection', priority: 'medium' },
      );
      break;

    case 'container':
      scanStrategy = 'Container security scanning';
      recommendations.push(
        { tool: 'trivy', category: 'system', reason: 'Container vulnerability scanning', priority: 'high' },
      );
      break;

    default:
      scanStrategy = 'General security assessment';
      recommendations.push(
        { tool: 'nmap', category: 'network', reason: 'Network reconnaissance', priority: 'high' },
        { tool: 'nuclei', category: 'web', reason: 'Vulnerability scanning', priority: 'high' },
      );
  }

  return {
    recommendations,
    targetType: parsed.type,
    scanStrategy,
  };
}

export async function POST(request: NextRequest) {
  try {
    const { message, scanData, scanId, history } = await request.json();

    if (!message) {
      return NextResponse.json(
        { error: 'Message is required' },
        { status: 400 }
      );
    }

    // Build context from scan data (RAG with Qdrant)
    let context = '';
    let ragResults: any[] = [];
    let toolRecommendations: any = null;
    let detectedTarget: string | null = null;
    
    // Detect if user is asking for tool recommendations or wants to scan a target
    const scanIntentPatterns = [
      /(?:scan|test|check|analyze|assess|pentest|attack)\s+(?:this\s+)?(?:target|url|ip|domain|website|server|host)?\s*[:\s]*([^\s,]+)/i,
      /(?:what\s+tools?\s+(?:should|can|to)\s+(?:i\s+)?use\s+(?:for|on|to\s+scan))\s*[:\s]*([^\s,]+)?/i,
      /(?:recommend|suggest)\s+(?:tools?|scan)\s+(?:for)?\s*[:\s]*([^\s,]+)?/i,
      /(?:how\s+(?:to|should\s+i)\s+scan)\s+([^\s,]+)/i,
    ];
    
    for (const pattern of scanIntentPatterns) {
      const match = message.match(pattern);
      if (match) {
        detectedTarget = match[1]?.trim();
        if (detectedTarget && detectedTarget.length > 3) {
          // Validate it looks like a target
          const validation = validateTarget(detectedTarget);
          if (validation.valid) {
            toolRecommendations = getToolRecommendations(detectedTarget);
          }
        }
        break;
      }
    }
    
    // Also check if user explicitly mentions a URL/IP in the message
    if (!detectedTarget) {
      const urlPattern = /(?:https?:\/\/)?(?:www\.)?([a-zA-Z0-9][-a-zA-Z0-9]*(?:\.[a-zA-Z0-9][-a-zA-Z0-9]*)+)(?:\/[^\s]*)?/i;
      const ipPattern = /\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}(?:\/\d{1,2})?)\b/;
      
      const urlMatch = message.match(urlPattern);
      const ipMatch = message.match(ipPattern);
      
      if (urlMatch || ipMatch) {
        detectedTarget = urlMatch?.[0] || ipMatch?.[0];
        if (detectedTarget) {
          const validation = validateTarget(detectedTarget);
          if (validation.valid) {
            toolRecommendations = getToolRecommendations(detectedTarget);
          }
        }
      }
    }
    
    // Detect time-based queries
    const timeQuery = detectTimeBasedQuery(message);
    
    if (timeQuery) {
      // Handle time-based queries (today, yesterday, this week, etc.)
      try {
        const { startDate, endDate } = timeQuery;
        
        // Get statistics
        const stats = await getScanStatistics(startDate, endDate);
        
        // Get actual scans
        const scans = await getScansByDateRange(startDate, endDate, 20);
        
        context = `Time-based query for ${timeQuery.description}:\n\n`;
        context += `Statistics:\n`;
        context += `- Total scans: ${stats.totalScans}\n`;
        context += `- Total vulnerabilities found: ${stats.totalVulnerabilities}\n`;
        context += `- Scans by target: ${JSON.stringify(stats.scansByTarget)}\n`;
        context += `- Scans by tool: ${JSON.stringify(stats.scansByTool)}\n\n`;
        
        if (scans.length > 0) {
          context += `Recent scan details:\n`;
          scans.slice(0, 10).forEach((scan, index) => {
            context += `[${index + 1}] ${scan.payload.content}\n`;
          });
        }
      } catch (error) {
        console.error('Time-based query failed:', error);
      }
    } else if (scanId) {
      // Try to get relevant context from Qdrant vector database for specific scan
      try {
        ragResults = await searchScanResults(message, scanId, 5);
        if (ragResults.length > 0) {
          context = 'Relevant scan information from vector database:\n\n';
          ragResults.forEach((result, index) => {
            context += `[${index + 1}] ${result.payload.content}\n\n`;
          });
        }
      } catch (error) {
        console.error('Qdrant search failed, using fallback:', error);
      }
    } else {
      // General query - search across all scans
      try {
        ragResults = await searchScanResults(message, undefined, 10);
        if (ragResults.length > 0) {
          context = 'Relevant information from all scans:\n\n';
          ragResults.forEach((result, index) => {
            context += `[${index + 1}] Scan: ${result.payload.scanId}, Target: ${result.payload.target}\n`;
            context += `${result.payload.content}\n\n`;
          });
        }
      } catch (error) {
        console.error('Global search failed:', error);
      }
    }
    
    // Fallback to basic scan context if Qdrant not available
    if (!context && scanData) {
      context = buildScanContext(scanData);
    }

    // Enhance context with Phase 2 normalized data
    if (scanId) {
      try {
        const phase2Summary = getScanSummary(scanId);
        if (phase2Summary.vulnerabilities.length > 0) {
          context += '\n\nğŸ“Š PHASE 2 NORMALIZED DATA:\n';
          context += `Total Vulnerabilities: ${phase2Summary.vulnerabilities.length}\n`;
          context += `Hosts Discovered: ${phase2Summary.hosts.length}\n`;
          context += `Attack Paths: ${phase2Summary.attackPaths.length}\n\n`;
          
          // Add vulnerability details
          const criticalVulns = phase2Summary.vulnerabilities.filter(v => v.severity.label === 'critical');
          const highVulns = phase2Summary.vulnerabilities.filter(v => v.severity.label === 'high');
          
          if (criticalVulns.length > 0) {
            context += 'ğŸ”´ CRITICAL VULNERABILITIES:\n';
            criticalVulns.slice(0, 5).forEach(v => {
              context += `- ${v.title} on ${v.host}:${v.port || 'N/A'} (CVE: ${v.cve?.join(', ') || 'N/A'})\n`;
              context += `  Description: ${v.description?.substring(0, 200) || 'N/A'}\n`;
              context += `  Remediation: ${v.remediation || 'N/A'}\n`;
            });
          }
          
          if (highVulns.length > 0) {
            context += '\nğŸŸ  HIGH VULNERABILITIES:\n';
            highVulns.slice(0, 5).forEach(v => {
              context += `- ${v.title} on ${v.host}:${v.port || 'N/A'}\n`;
            });
          }
          
          // Add attack paths
          if (phase2Summary.attackPaths.length > 0) {
            context += '\nâš¡ ATTACK PATHS:\n';
            phase2Summary.attackPaths.slice(0, 3).forEach((path, i) => {
              context += `${i + 1}. ${path.name} (Risk: ${path.overallRisk})\n`;
              context += `   Steps: ${path.criticalPath.length}\n`;
              context += `   Mitigations: ${path.mitigations.slice(0, 2).join(', ')}\n`;
            });
          }
        }
      } catch (e) {
        console.error('Phase 2 data fetch failed:', e);
      }
    }
    
    // Add global Phase 2 statistics for general queries
    if (!scanId) {
      try {
        const storage = getPhase2Storage();
        const stats = storage.getStatistics();
        if (stats.totalVulnerabilities > 0) {
          context += '\n\nğŸ“ˆ OVERALL SECURITY STATISTICS:\n';
          context += `Total Vulnerabilities: ${stats.totalVulnerabilities}\n`;
          context += `Total Hosts: ${stats.totalHosts}\n`;
          context += `Total Scans: ${stats.totalSessions}\n`;
          context += `Severity Breakdown: Critical=${stats.severityBreakdown.critical}, High=${stats.severityBreakdown.high}, Medium=${stats.severityBreakdown.medium}, Low=${stats.severityBreakdown.low}\n`;
          
          // Add compliance summary if user asks about compliance
          if (message.toLowerCase().includes('compliance') || 
              message.toLowerCase().includes('pci') || 
              message.toLowerCase().includes('owasp') ||
              message.toLowerCase().includes('cis')) {
            const vulns = storage.queryVulnerabilities({}).data;
            if (vulns.length > 0) {
              try {
                const pciReport = generateComplianceReport(vulns, 'PCI DSS');
                const owaspReport = generateComplianceReport(vulns, 'OWASP Top 10');
                
                context += '\n\nğŸ“‹ COMPLIANCE STATUS:\n';
                context += `PCI DSS 4.0 Score: ${pciReport.summary.complianceScore}% (${pciReport.summary.passed}/${pciReport.summary.totalRequirements} requirements passed)\n`;
                context += `OWASP Top 10 Score: ${owaspReport.summary.complianceScore}% (${owaspReport.summary.passed}/${owaspReport.summary.totalRequirements} requirements passed)\n`;
                
                // List failed requirements
                const failedPci = pciReport.requirements.filter(r => r.status === 'fail').slice(0, 3);
                const failedOwasp = owaspReport.requirements.filter(r => r.status === 'fail').slice(0, 3);
                
                if (failedPci.length > 0) {
                  context += '\nFailed PCI DSS Requirements:\n';
                  failedPci.forEach(r => {
                    context += `- ${r.id}: ${r.name} (${r.findings.length} findings)\n`;
                  });
                }
                
                if (failedOwasp.length > 0) {
                  context += '\nFailed OWASP Requirements:\n';
                  failedOwasp.forEach(r => {
                    context += `- ${r.id}: ${r.name} (${r.findings.length} findings)\n`;
                  });
                }
              } catch (complianceError) {
                console.error('Compliance report generation failed:', complianceError);
              }
            }
          }
        }
      } catch (e) {
        // Phase 2 storage not available
      }
    }

    // Add tool recommendations to context if detected
    if (toolRecommendations && detectedTarget) {
      context += `\n\nğŸ¯ TOOL RECOMMENDATIONS FOR TARGET: ${detectedTarget}\n`;
      context += `Target Type: ${toolRecommendations.targetType}\n`;
      context += `Strategy: ${toolRecommendations.scanStrategy}\n\n`;
      context += `Recommended Tools:\n`;
      toolRecommendations.recommendations.forEach((rec: ToolRecommendation, idx: number) => {
        context += `${idx + 1}. ${rec.tool.toUpperCase()} (${rec.category}) - Priority: ${rec.priority}\n`;
        context += `   Reason: ${rec.reason}\n`;
      });
      context += `\nIMPORTANT: When recommending tools, also mention that the user can:\n`;
      context += `1. Click "Start Scan" button to begin scanning with recommended tools\n`;
      context += `2. Modify the tool selection before starting\n`;
      context += `3. The scan will run at: /scan/new?target=${encodeURIComponent(detectedTarget)}\n`;
    }

    // Build conversation history
    const conversationHistory = history
      ?.slice(-5)
      .map((msg: any) => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
      .join('\n') || '';

    // System prompt for security assistant
    const systemPrompt = `You are an expert cybersecurity AI assistant specializing in vulnerability assessment and penetration testing. 

Your role:
- Analyze security scan results and vulnerabilities
- Provide clear, actionable remediation advice
- Explain security concepts in simple terms
- Help users understand their security posture
- Recommend best practices and tools

CRITICAL FORMATTING RULES - FOLLOW EXACTLY:
1. NEVER EVER use asterisks (*) - they will be removed
2. NEVER use markdown formatting (**bold** or *italic*)
3. ALWAYS use emojis for bullets: ğŸ”¹ (not *)
4. ALWAYS use numbers for ordered lists: 1. 2. 3.
5. ALWAYS use emojis for section headers: ğŸ” ğŸ›¡ï¸ âš ï¸ âœ… âŒ ğŸ“Š ğŸ¯ ğŸ’¡ ğŸ”§
6. Use "Step 1:" format for sequential steps
7. Use clear line breaks between sections
8. Use plain text - no markdown symbols

CORRECT FORMAT EXAMPLE:
ğŸ” ATTACK PATH ANALYSIS

Step 1: Reconnaissance
The attacker gathers information about the target.

ğŸ”¹ DNS enumeration
ğŸ”¹ Subdomain scanning  
ğŸ”¹ Network reconnaissance

Step 2: Port Scanning
Identify open ports and services.

1. Scan common ports
2. Identify services
3. Check versions

âš ï¸ Critical: Always verify findings

WRONG FORMAT (DO NOT USE):
* Step 1: Reconnaissance
* The attacker gathers information
  * DNS enumeration
  * Subdomain scanning
**Important:** Never use asterisks

Guidelines:
- Be concise but thorough
- Prioritize critical vulnerabilities
- Provide step-by-step remediation when asked
- If you don't know something, say so
- Never make up CVE numbers or vulnerabilities

${context ? `\n\nCurrent Scan Context:\n${context}` : ''}
${conversationHistory ? `\n\nConversation History:\n${conversationHistory}` : ''}`;

    const userPrompt = message;

    // Get AI response
    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.7,
      maxTokens: 1000
    });

    // Format and clean the response
    const formattedResponse = formatAIResponse(response.content);

    // Build response with optional tool recommendations
    const responseData: any = {
      success: true,
      response: formattedResponse,
      timestamp: new Date().toISOString()
    };
    
    // Include tool recommendations if detected
    if (toolRecommendations && detectedTarget) {
      responseData.toolRecommendations = {
        target: detectedTarget,
        targetType: toolRecommendations.targetType,
        strategy: toolRecommendations.scanStrategy,
        tools: toolRecommendations.recommendations,
        scanUrl: `/scan/new?target=${encodeURIComponent(detectedTarget)}&tools=${toolRecommendations.recommendations.filter((r: any) => r.priority === 'high').map((r: any) => r.tool).join(',')}`
      };
    }
    
    return NextResponse.json(responseData);
  } catch (error: any) {
    console.error('Chat API error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to get AI response',
        response: "I'm having trouble connecting right now. Please try again in a moment! ğŸ”„"
      },
      { status: 200 } // Return 200 so frontend shows the fallback message
    );
  }
}

function buildScanContext(scanData: any): string {
  let context = 'Scan Information:\n';
  
  if (scanData.target) {
    context += `- Target: ${scanData.target}\n`;
  }
  
  if (scanData.scanType) {
    context += `- Scan Type: ${scanData.scanType}\n`;
  }
  
  if (scanData.status) {
    context += `- Status: ${scanData.status}\n`;
  }
  
  if (scanData.summary) {
    context += `- Total Tools: ${scanData.summary.total_tools}\n`;
    context += `- Completed: ${scanData.summary.completed_tools}\n`;
    context += `- Failed: ${scanData.summary.failed_tools}\n`;
    context += `- Success Rate: ${scanData.summary.success_rate}%\n`;
  }
  
  // Add results summary
  if (scanData.results) {
    context += '\nScan Results Summary:\n';
    Object.entries(scanData.results).forEach(([tool, result]: [string, any]) => {
      if (result.success) {
        context += `- ${tool}: `;
        if (result.vulnerabilities_found !== undefined) {
          context += `${result.vulnerabilities_found} vulnerabilities found\n`;
        } else if (result.open_ports) {
          context += `${result.open_ports.length} open ports\n`;
        } else if (result.status) {
          context += `${result.status}\n`;
        } else {
          context += 'completed\n';
        }
      } else {
        context += `- ${tool}: failed\n`;
      }
    });
  }
  
  // Add critical findings
  if (scanData.results) {
    const criticalFindings: string[] = [];
    Object.entries(scanData.results).forEach(([tool, result]: [string, any]) => {
      if (result.vulnerabilities && Array.isArray(result.vulnerabilities)) {
        result.vulnerabilities
          .filter((v: any) => v.severity === 'critical' || v.severity === 'high')
          .forEach((v: any) => {
            criticalFindings.push(`${tool}: ${v.name || v.title || 'Unknown'} (${v.severity})`);
          });
      }
    });
    
    if (criticalFindings.length > 0) {
      context += '\nCritical/High Severity Findings:\n';
      criticalFindings.slice(0, 5).forEach(finding => {
        context += `- ${finding}\n`;
      });
    }
  }
  
  return context;
}


/**
 * Detect time-based queries and return date range
 */
function detectTimeBasedQuery(message: string): {
  startDate: string;
  endDate: string;
  description: string;
} | null {
  const lowerMessage = message.toLowerCase();
  const now = new Date();
  
  // Today
  if (lowerMessage.includes('today') || lowerMessage.includes('today\'s')) {
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
    return {
      startDate: startOfDay.toISOString(),
      endDate: endOfDay.toISOString(),
      description: 'today',
    };
  }
  
  // Yesterday
  if (lowerMessage.includes('yesterday')) {
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const startOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
    const endOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);
    return {
      startDate: startOfDay.toISOString(),
      endDate: endOfDay.toISOString(),
      description: 'yesterday',
    };
  }
  
  // This week
  if (lowerMessage.includes('this week') || lowerMessage.includes('week')) {
    const startOfWeek = new Date(now);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
    startOfWeek.setHours(0, 0, 0, 0);
    return {
      startDate: startOfWeek.toISOString(),
      endDate: now.toISOString(),
      description: 'this week',
    };
  }
  
  // Last 7 days
  if (lowerMessage.includes('last 7 days') || lowerMessage.includes('past 7 days') || lowerMessage.includes('last week')) {
    const sevenDaysAgo = new Date(now);
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    return {
      startDate: sevenDaysAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'last 7 days',
    };
  }
  
  // This month
  if (lowerMessage.includes('this month') || lowerMessage.includes('month')) {
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    return {
      startDate: startOfMonth.toISOString(),
      endDate: now.toISOString(),
      description: 'this month',
    };
  }
  
  // Last 30 days
  if (lowerMessage.includes('last 30 days') || lowerMessage.includes('past 30 days')) {
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    return {
      startDate: thirtyDaysAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'last 30 days',
    };
  }
  
  // All time / all scans
  if (lowerMessage.includes('all scans') || lowerMessage.includes('all time') || lowerMessage.includes('everything')) {
    const longTimeAgo = new Date(now);
    longTimeAgo.setFullYear(longTimeAgo.getFullYear() - 1); // Last year
    return {
      startDate: longTimeAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'all time',
    };
  }
  
  return null;
}

/**
 * Format AI response for better readability
 * Removes ALL asterisks and improves visual structure
 */
function formatAIResponse(content: string): string {
  let formatted = content;
  
  // Step 1: Replace asterisk bullet points FIRST (before removing other asterisks)
  formatted = formatted.replace(/^\s*\*\s+/gm, 'ğŸ”¹ ');
  formatted = formatted.replace(/\n\s*\*\s+/g, '\nğŸ”¹ ');
  
  // Step 2: Remove markdown bold (**text** -> text)
  formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '$1');
  
  // Step 3: Remove markdown italic (*text* -> text)
  formatted = formatted.replace(/\*([^*\n]+)\*/g, '$1');
  
  // Step 4: Remove ALL remaining asterisks (any that are left)
  formatted = formatted.replace(/\*/g, '');
  
  // Step 5: Improve section headers (add spacing)
  formatted = formatted.replace(/^(Step \d+:|Phase \d+:|Stage \d+:)/gm, '\n$1');
  
  // Step 6: Add emoji to common section headers if not present
  if (!/^ğŸ”/.test(formatted)) {
    formatted = formatted.replace(/^(Reconnaissance|Port Scanning|Vulnerability Scanning|Vulnerability Assessment)/gm, 'ğŸ” $1');
  }
  formatted = formatted.replace(/^(Exploitation|Attack|Penetration)/gm, 'âš¡ $1');
  formatted = formatted.replace(/^(Post-Exploitation|Persistence|Lateral Movement)/gm, 'ğŸ¯ $1');
  formatted = formatted.replace(/^(Critical|High|Medium|Low):/gm, 'âš ï¸ $1:');
  formatted = formatted.replace(/^(Recommendation|Action|Fix|Solution)s?:/gm, 'ğŸ’¡ $1:');
  formatted = formatted.replace(/^(Summary|Conclusion|Result):/gm, 'ğŸ“Š $1:');
  
  // Step 7: Clean up excessive newlines
  formatted = formatted.replace(/\n{3,}/g, '\n\n');
  
  // Step 8: Trim whitespace
  formatted = formatted.trim();
  
  return formatted;
}
