import { NextRequest, NextResponse } from 'next/server';
import { getAICompletion } from '@/lib/multi-ai-provider';
import { searchScanResults, getScansByDateRange, getScanStatistics } from '@/lib/qdrant-client';

export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    const { message, scanData, scanId, history } = await request.json();

    if (!message) {
      return NextResponse.json(
        { error: 'Message is required' },
        { status: 400 }
      );
    }

    // Build context from scan data (RAG with Qdrant)
    let context = '';
    let ragResults: any[] = [];
    
    // Detect time-based queries
    const timeQuery = detectTimeBasedQuery(message);
    
    if (timeQuery) {
      // Handle time-based queries (today, yesterday, this week, etc.)
      try {
        const { startDate, endDate } = timeQuery;
        
        // Get statistics
        const stats = await getScanStatistics(startDate, endDate);
        
        // Get actual scans
        const scans = await getScansByDateRange(startDate, endDate, 20);
        
        context = `Time-based query for ${timeQuery.description}:\n\n`;
        context += `Statistics:\n`;
        context += `- Total scans: ${stats.totalScans}\n`;
        context += `- Total vulnerabilities found: ${stats.totalVulnerabilities}\n`;
        context += `- Scans by target: ${JSON.stringify(stats.scansByTarget)}\n`;
        context += `- Scans by tool: ${JSON.stringify(stats.scansByTool)}\n\n`;
        
        if (scans.length > 0) {
          context += `Recent scan details:\n`;
          scans.slice(0, 10).forEach((scan, index) => {
            context += `[${index + 1}] ${scan.payload.content}\n`;
          });
        }
      } catch (error) {
        console.error('Time-based query failed:', error);
      }
    } else if (scanId) {
      // Try to get relevant context from Qdrant vector database for specific scan
      try {
        ragResults = await searchScanResults(message, scanId, 5);
        if (ragResults.length > 0) {
          context = 'Relevant scan information from vector database:\n\n';
          ragResults.forEach((result, index) => {
            context += `[${index + 1}] ${result.payload.content}\n\n`;
          });
        }
      } catch (error) {
        console.error('Qdrant search failed, using fallback:', error);
      }
    } else {
      // General query - search across all scans
      try {
        ragResults = await searchScanResults(message, undefined, 10);
        if (ragResults.length > 0) {
          context = 'Relevant information from all scans:\n\n';
          ragResults.forEach((result, index) => {
            context += `[${index + 1}] Scan: ${result.payload.scanId}, Target: ${result.payload.target}\n`;
            context += `${result.payload.content}\n\n`;
          });
        }
      } catch (error) {
        console.error('Global search failed:', error);
      }
    }
    
    // Fallback to basic scan context if Qdrant not available
    if (!context && scanData) {
      context = buildScanContext(scanData);
    }

    // Build conversation history
    const conversationHistory = history
      ?.slice(-5)
      .map((msg: any) => `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.content}`)
      .join('\n') || '';

    // System prompt for security assistant
    const systemPrompt = `You are an expert cybersecurity AI assistant specializing in vulnerability assessment and penetration testing. 

Your role:
- Analyze security scan results and vulnerabilities
- Provide clear, actionable remediation advice
- Explain security concepts in simple terms
- Help users understand their security posture
- Recommend best practices and tools

CRITICAL FORMATTING RULES - FOLLOW EXACTLY:
1. NEVER EVER use asterisks (*) - they will be removed
2. NEVER use markdown formatting (**bold** or *italic*)
3. ALWAYS use emojis for bullets: ğŸ”¹ (not *)
4. ALWAYS use numbers for ordered lists: 1. 2. 3.
5. ALWAYS use emojis for section headers: ğŸ” ğŸ›¡ï¸ âš ï¸ âœ… âŒ ğŸ“Š ğŸ¯ ğŸ’¡ ğŸ”§
6. Use "Step 1:" format for sequential steps
7. Use clear line breaks between sections
8. Use plain text - no markdown symbols

CORRECT FORMAT EXAMPLE:
ğŸ” ATTACK PATH ANALYSIS

Step 1: Reconnaissance
The attacker gathers information about the target.

ğŸ”¹ DNS enumeration
ğŸ”¹ Subdomain scanning  
ğŸ”¹ Network reconnaissance

Step 2: Port Scanning
Identify open ports and services.

1. Scan common ports
2. Identify services
3. Check versions

âš ï¸ Critical: Always verify findings

WRONG FORMAT (DO NOT USE):
* Step 1: Reconnaissance
* The attacker gathers information
  * DNS enumeration
  * Subdomain scanning
**Important:** Never use asterisks

Guidelines:
- Be concise but thorough
- Prioritize critical vulnerabilities
- Provide step-by-step remediation when asked
- If you don't know something, say so
- Never make up CVE numbers or vulnerabilities

${context ? `\n\nCurrent Scan Context:\n${context}` : ''}
${conversationHistory ? `\n\nConversation History:\n${conversationHistory}` : ''}`;

    const userPrompt = message;

    // Get AI response
    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.7,
      maxTokens: 1000
    });

    // Format and clean the response
    const formattedResponse = formatAIResponse(response.content);

    return NextResponse.json({
      success: true,
      response: formattedResponse,
      timestamp: new Date().toISOString()
    });
  } catch (error: any) {
    console.error('Chat API error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to get AI response',
        response: "I'm having trouble connecting right now. Please try again in a moment! ğŸ”„"
      },
      { status: 200 } // Return 200 so frontend shows the fallback message
    );
  }
}

function buildScanContext(scanData: any): string {
  let context = 'Scan Information:\n';
  
  if (scanData.target) {
    context += `- Target: ${scanData.target}\n`;
  }
  
  if (scanData.scanType) {
    context += `- Scan Type: ${scanData.scanType}\n`;
  }
  
  if (scanData.status) {
    context += `- Status: ${scanData.status}\n`;
  }
  
  if (scanData.summary) {
    context += `- Total Tools: ${scanData.summary.total_tools}\n`;
    context += `- Completed: ${scanData.summary.completed_tools}\n`;
    context += `- Failed: ${scanData.summary.failed_tools}\n`;
    context += `- Success Rate: ${scanData.summary.success_rate}%\n`;
  }
  
  // Add results summary
  if (scanData.results) {
    context += '\nScan Results Summary:\n';
    Object.entries(scanData.results).forEach(([tool, result]: [string, any]) => {
      if (result.success) {
        context += `- ${tool}: `;
        if (result.vulnerabilities_found !== undefined) {
          context += `${result.vulnerabilities_found} vulnerabilities found\n`;
        } else if (result.open_ports) {
          context += `${result.open_ports.length} open ports\n`;
        } else if (result.status) {
          context += `${result.status}\n`;
        } else {
          context += 'completed\n';
        }
      } else {
        context += `- ${tool}: failed\n`;
      }
    });
  }
  
  // Add critical findings
  if (scanData.results) {
    const criticalFindings: string[] = [];
    Object.entries(scanData.results).forEach(([tool, result]: [string, any]) => {
      if (result.vulnerabilities && Array.isArray(result.vulnerabilities)) {
        result.vulnerabilities
          .filter((v: any) => v.severity === 'critical' || v.severity === 'high')
          .forEach((v: any) => {
            criticalFindings.push(`${tool}: ${v.name || v.title || 'Unknown'} (${v.severity})`);
          });
      }
    });
    
    if (criticalFindings.length > 0) {
      context += '\nCritical/High Severity Findings:\n';
      criticalFindings.slice(0, 5).forEach(finding => {
        context += `- ${finding}\n`;
      });
    }
  }
  
  return context;
}


/**
 * Detect time-based queries and return date range
 */
function detectTimeBasedQuery(message: string): {
  startDate: string;
  endDate: string;
  description: string;
} | null {
  const lowerMessage = message.toLowerCase();
  const now = new Date();
  
  // Today
  if (lowerMessage.includes('today') || lowerMessage.includes('today\'s')) {
    const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const endOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
    return {
      startDate: startOfDay.toISOString(),
      endDate: endOfDay.toISOString(),
      description: 'today',
    };
  }
  
  // Yesterday
  if (lowerMessage.includes('yesterday')) {
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const startOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate());
    const endOfDay = new Date(yesterday.getFullYear(), yesterday.getMonth(), yesterday.getDate(), 23, 59, 59);
    return {
      startDate: startOfDay.toISOString(),
      endDate: endOfDay.toISOString(),
      description: 'yesterday',
    };
  }
  
  // This week
  if (lowerMessage.includes('this week') || lowerMessage.includes('week')) {
    const startOfWeek = new Date(now);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());
    startOfWeek.setHours(0, 0, 0, 0);
    return {
      startDate: startOfWeek.toISOString(),
      endDate: now.toISOString(),
      description: 'this week',
    };
  }
  
  // Last 7 days
  if (lowerMessage.includes('last 7 days') || lowerMessage.includes('past 7 days') || lowerMessage.includes('last week')) {
    const sevenDaysAgo = new Date(now);
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
    return {
      startDate: sevenDaysAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'last 7 days',
    };
  }
  
  // This month
  if (lowerMessage.includes('this month') || lowerMessage.includes('month')) {
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    return {
      startDate: startOfMonth.toISOString(),
      endDate: now.toISOString(),
      description: 'this month',
    };
  }
  
  // Last 30 days
  if (lowerMessage.includes('last 30 days') || lowerMessage.includes('past 30 days')) {
    const thirtyDaysAgo = new Date(now);
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    return {
      startDate: thirtyDaysAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'last 30 days',
    };
  }
  
  // All time / all scans
  if (lowerMessage.includes('all scans') || lowerMessage.includes('all time') || lowerMessage.includes('everything')) {
    const longTimeAgo = new Date(now);
    longTimeAgo.setFullYear(longTimeAgo.getFullYear() - 1); // Last year
    return {
      startDate: longTimeAgo.toISOString(),
      endDate: now.toISOString(),
      description: 'all time',
    };
  }
  
  return null;
}

/**
 * Format AI response for better readability
 * Removes ALL asterisks and improves visual structure
 */
function formatAIResponse(content: string): string {
  let formatted = content;
  
  // Step 1: Replace asterisk bullet points FIRST (before removing other asterisks)
  formatted = formatted.replace(/^\s*\*\s+/gm, 'ğŸ”¹ ');
  formatted = formatted.replace(/\n\s*\*\s+/g, '\nğŸ”¹ ');
  
  // Step 2: Remove markdown bold (**text** -> text)
  formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '$1');
  
  // Step 3: Remove markdown italic (*text* -> text)
  formatted = formatted.replace(/\*([^*\n]+)\*/g, '$1');
  
  // Step 4: Remove ALL remaining asterisks (any that are left)
  formatted = formatted.replace(/\*/g, '');
  
  // Step 5: Improve section headers (add spacing)
  formatted = formatted.replace(/^(Step \d+:|Phase \d+:|Stage \d+:)/gm, '\n$1');
  
  // Step 6: Add emoji to common section headers if not present
  if (!/^ğŸ”/.test(formatted)) {
    formatted = formatted.replace(/^(Reconnaissance|Port Scanning|Vulnerability Scanning|Vulnerability Assessment)/gm, 'ğŸ” $1');
  }
  formatted = formatted.replace(/^(Exploitation|Attack|Penetration)/gm, 'âš¡ $1');
  formatted = formatted.replace(/^(Post-Exploitation|Persistence|Lateral Movement)/gm, 'ğŸ¯ $1');
  formatted = formatted.replace(/^(Critical|High|Medium|Low):/gm, 'âš ï¸ $1:');
  formatted = formatted.replace(/^(Recommendation|Action|Fix|Solution)s?:/gm, 'ğŸ’¡ $1:');
  formatted = formatted.replace(/^(Summary|Conclusion|Result):/gm, 'ğŸ“Š $1:');
  
  // Step 7: Clean up excessive newlines
  formatted = formatted.replace(/\n{3,}/g, '\n\n');
  
  // Step 8: Trim whitespace
  formatted = formatted.trim();
  
  return formatted;
}
