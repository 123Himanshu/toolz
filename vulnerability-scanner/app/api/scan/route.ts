import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import { v4 as uuidv4 } from 'uuid';

const execAsync = promisify(exec);

// Disable static optimization for this route
export const dynamic = 'force-dynamic';

// In-memory storage for scans (use database in production)
const scans = new Map();

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { target, scanType, tools, config } = body;

    // Validate input
    if (!target || !scanType || !tools) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Generate scan ID
    const scanId = uuidv4();

    // Create scan record
    const scan = {
      id: scanId,
      target,
      scanType,
      tools,
      config,
      status: 'queued',
      progress: {},
      results: {},
      startedAt: new Date().toISOString(),
      completedAt: null,
    };

    scans.set(scanId, scan);

    // Start scan asynchronously
    startScan(scanId, target, scanType, tools, config);

    return NextResponse.json({
      success: true,
      scanId,
      message: 'Scan started successfully',
    });
  } catch (error: any) {
    console.error('Error starting scan:', error);
    return NextResponse.json(
      { error: 'Failed to start scan' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const scanId = searchParams.get('scanId');

    if (scanId) {
      // Get specific scan
      const scan = scans.get(scanId);
      if (!scan) {
        return NextResponse.json(
          { error: 'Scan not found' },
          { status: 404 }
        );
      }
      return NextResponse.json(scan);
    } else {
      // Get all scans
      const allScans = Array.from(scans.values());
      return NextResponse.json(allScans);
    }
  } catch (error: any) {
    console.error('Error fetching scans:', error);
    return NextResponse.json(
      { error: 'Failed to fetch scans' },
      { status: 500 }
    );
  }
}

async function startScan(
  scanId: string,
  target: string,
  scanType: string,
  tools: any,
  config: any
) {
  const scan = scans.get(scanId);
  if (!scan) return;

  scan.status = 'running';
  scan.progress = {};
  scan.results = {};

  try {
    // Build tool list based on scan type
    const selectedTools: string[] = [];
    
    if (scanType === 'passive' || scanType === 'both') {
      // Add passive reconnaissance
      selectedTools.push('passive_recon');
    }
    
    if (scanType === 'active' || scanType === 'both') {
      if (tools.network && Array.isArray(tools.network)) {
        selectedTools.push(...tools.network);
      }
      if (tools.web && Array.isArray(tools.web)) {
        selectedTools.push(...tools.web);
      }
      if (tools.system && Array.isArray(tools.system)) {
        selectedTools.push(...tools.system);
      }
    }

    console.log(`Starting scan ${scanId} with tools:`, selectedTools);

    // Initialize progress for all tools
    selectedTools.forEach(tool => {
      scan.progress[tool] = 'queued';
    });
    scans.set(scanId, scan);

    // Execute tools sequentially
    for (const tool of selectedTools) {
      try {
        console.log(`Starting ${tool} for scan ${scanId}`);
        scan.progress[tool] = 'running';
        scans.set(scanId, scan);

        let result;
        if (tool === 'passive_recon') {
          result = await executePassiveRecon(target);
        } else {
          result = await executeTool(tool, target, config);
        }

        scan.progress[tool] = 'completed';
        scan.results[tool] = {
          ...result,
          completed_at: new Date().toISOString(),
          duration: result.duration_seconds || 0,
        };
        
        console.log(`Completed ${tool} for scan ${scanId}`);
      } catch (error: any) {
        console.error(`Failed ${tool} for scan ${scanId}:`, error.message);
        scan.progress[tool] = 'failed';
        scan.results[tool] = {
          error: error.message,
          failed_at: new Date().toISOString(),
        };
      }

      scans.set(scanId, scan);
    }

    // Calculate final statistics
    const completedTools = Object.values(scan.progress).filter(status => status === 'completed').length;
    const failedTools = Object.values(scan.progress).filter(status => status === 'failed').length;
    
    scan.status = failedTools === selectedTools.length ? 'failed' : 'completed';
    scan.completedAt = new Date().toISOString();
    scan.summary = {
      total_tools: selectedTools.length,
      completed_tools: completedTools,
      failed_tools: failedTools,
      success_rate: Math.round((completedTools / selectedTools.length) * 100),
    };
    
    console.log(`Scan ${scanId} completed with status: ${scan.status}`);
  } catch (error: any) {
    console.error(`Scan ${scanId} failed:`, error.message);
    scan.status = 'failed';
    scan.error = error.message;
  }

  scans.set(scanId, scan);
}

async function executePassiveRecon(target: string) {
  const command = `docker run --rm security-scanner python -c "
from passive_recon_v2 import PassiveReconEngine
import json
engine = PassiveReconEngine('${target}')
results = engine.run_full_scan()
print(json.dumps(results, default=str))
"`;

  try {
    const { stdout, stderr } = await execAsync(command, {
      timeout: 300000, // 5 minutes
      maxBuffer: 1024 * 1024 * 5, // 5MB buffer
    });

    if (stderr && stderr.includes('Error') && !stdout) {
      throw new Error(stderr);
    }

    return JSON.parse(stdout);
  } catch (error: any) {
    throw new Error(`Passive reconnaissance failed: ${error.message}`);
  }
}

async function executeTool(tool: string, target: string, config: any) {
  // Map tool names to Docker commands with proper Python backend integration
  const toolCommands: Record<string, string> = {
    // Network Tools
    nmap: `docker run --rm security-scanner python -c "
from nmap_wrapper import NmapWrapper
import json
scanner = NmapWrapper(docker_mode=False)
result = scanner.quick_scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    masscan: `docker run --rm security-scanner python -c "
from masscan_wrapper import MasscanWrapper
import json
scanner = MasscanWrapper()
result = scanner.scan('${target}', '80,443,22,21,25,53,110,143,993,995,3306,5432,6379,27017', 1000)
print(json.dumps(result, default=str))
"`,
    
    rustscan: `docker run --rm security-scanner python -c "
from rustscan_wrapper import RustScanWrapper
import json
scanner = RustScanWrapper()
result = scanner.scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    naabu: `docker run --rm security-scanner python -c "
from naabu_wrapper import NaabuWrapper
import json
scanner = NaabuWrapper()
result = scanner.scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    zmap: `docker run --rm security-scanner python -c "
from zmap_wrapper import ZmapWrapper
import json
scanner = ZmapWrapper()
result = scanner.scan('${target}', '80')
print(json.dumps(result, default=str))
"`,
    
    // Web Application Tools
    nuclei: `docker run --rm security-scanner python -c "
from nuclei_scanner import NucleiScanner
import json
scanner = NucleiScanner(use_docker=False)
result = scanner.quick_scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    zap: `docker run --rm security-scanner python -c "
from zap_scanner import ZAPScanner
import json
scanner = ZAPScanner(use_docker=False)
result = scanner.baseline_scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    wapiti: `docker run --rm security-scanner python -c "
from wapiti_scanner import WapitiScanner
import json
scanner = WapitiScanner(use_docker=False)
result = scanner.quick_scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    nikto: `docker run --rm security-scanner python -c "
from nikto_scanner import NiktoScanner
import json
scanner = NiktoScanner(use_docker=False)
result = scanner.scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    jaeles: `docker run --rm security-scanner python -c "
from jaeles_scanner import JaelesScanner
import json
scanner = JaelesScanner(use_docker=False)
result = scanner.quick_scan('${target}')
print(json.dumps(result, default=str))
"`,
    
    // System Tools
    trivy: `docker run --rm security-scanner python -c "
from trivy_wrapper import TrivyWrapper
import json
scanner = TrivyWrapper()
result = scanner.scan_image('${target}')
print(json.dumps(result, default=str))
"`,
    
    openvas: `docker run --rm security-scanner python -c "
from openvas_wrapper import OpenVASWrapper
import json
scanner = OpenVASWrapper()
result = scanner.scan('${target}')
print(json.dumps(result, default=str))
"`,
  };

  const command = toolCommands[tool.toLowerCase()];
  if (!command) {
    throw new Error(`Unknown tool: ${tool}`);
  }

  try {
    console.log(`Executing ${tool} on ${target}...`);
    const { stdout, stderr } = await execAsync(command, {
      timeout: 600000, // 10 minutes
      maxBuffer: 1024 * 1024 * 10, // 10MB buffer
    });

    if (stderr && stderr.includes('Error') && !stdout) {
      throw new Error(stderr);
    }

    // Try to parse JSON, fallback to raw output
    try {
      return JSON.parse(stdout);
    } catch (parseError) {
      return {
        success: true,
        raw_output: stdout,
        stderr: stderr,
        tool: tool,
        target: target,
      };
    }
  } catch (error: any) {
    console.error(`Tool ${tool} execution failed:`, error.message);
    throw new Error(`${tool} execution failed: ${error.message}`);
  }
}
