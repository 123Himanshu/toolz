import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import { v4 as uuidv4 } from 'uuid';
import { getStorage } from '@/lib/scan-storage';
import { parseTarget, getTargetForTool } from '@/lib/target-parser';

const execAsync = promisify(exec);

// Disable static optimization for this route
export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { target, scanType, tools, config } = body;

    // Validate input
    if (!target || !scanType || !tools) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Generate scan ID
    const scanId = uuidv4();

    // Create scan record
    const scan = {
      id: scanId,
      target,
      scanType,
      tools,
      config,
      status: 'queued',
      progress: {},
      results: {},
      startedAt: new Date().toISOString(),
      completedAt: null,
      logs: [],
    };

    const storage = getStorage();
    storage.set(scanId, scan);
    
    // Parse and log target info
    const parsed = parseTarget(target);
    console.log(`Created scan ${scanId} for target ${target} (type: ${parsed.type}, clean: ${parsed.clean}). Total scans in storage: ${storage.size()}`);

    // Start scan asynchronously
    startScan(scanId, target, scanType, tools, config);

    return NextResponse.json({
      success: true,
      scanId,
      message: 'Scan started successfully',
      note: 'In development mode, scans may be cleared on hot reload. Use persistent storage in production.'
    });
  } catch (error: any) {
    console.error('Error starting scan:', error);
    return NextResponse.json(
      { error: 'Failed to start scan' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const scanId = searchParams.get('scanId');
    const storage = getStorage();

    if (scanId) {
      // Get specific scan
      const scan = storage.get(scanId);
      if (!scan) {
        console.log(`Scan ${scanId} not found. Available scans:`, storage.keys());
        return NextResponse.json(
          { error: 'Scan not found' },
          { status: 404 }
        );
      }
      return NextResponse.json(scan);
    } else {
      // Get all scans
      const allScans = storage.getAll();
      return NextResponse.json(allScans);
    }
  } catch (error: any) {
    console.error('Error fetching scans:', error);
    return NextResponse.json(
      { error: 'Failed to fetch scans' },
      { status: 500 }
    );
  }
}

async function startScan(
  scanId: string,
  target: string,
  scanType: string,
  tools: any,
  config: any
) {
  const storage = getStorage();
  const scan = storage.get(scanId);
  if (!scan) return;

  scan.status = 'running';
  scan.progress = {};
  scan.results = {};
  if (!scan.logs) scan.logs = [];

  try {
    // Build tool list based on scan type
    const selectedTools: string[] = [];
    storage.addLog(scanId, 'system', 'info', `Starting scan on ${target}`);
    
    if (scanType === 'passive' || scanType === 'both') {
      // Add passive reconnaissance
      selectedTools.push('passive_recon');
    }
    
    if (scanType === 'active' || scanType === 'both') {
      if (tools.network && Array.isArray(tools.network)) {
        selectedTools.push(...tools.network);
      }
      if (tools.web && Array.isArray(tools.web)) {
        selectedTools.push(...tools.web);
      }
      if (tools.system && Array.isArray(tools.system)) {
        selectedTools.push(...tools.system);
      }
    }

    console.log(`Starting scan ${scanId} with tools:`, selectedTools);

    // Initialize progress for all tools
    selectedTools.forEach(tool => {
      scan.progress[tool] = 'queued';
    });
    storage.set(scanId, scan);

    // Execute tools sequentially
    for (const tool of selectedTools) {
      try {
        console.log(`Starting ${tool} for scan ${scanId}`);
        storage.addLog(scanId, tool, 'info', `Starting ${tool} scan...`);
        scan.progress[tool] = 'running';
        storage.set(scanId, scan);

        let result;
        if (tool === 'passive_recon') {
          result = await executePassiveRecon(target);
        } else {
          result = await executeTool(tool, target, config);
        }

        scan.progress[tool] = 'completed';
        scan.results[tool] = {
          ...result,
          completed_at: new Date().toISOString(),
          duration: result.duration_seconds || 0,
        };
        
        storage.addLog(scanId, tool, 'success', `${tool} completed successfully`);
        console.log(`Completed ${tool} for scan ${scanId}`);
      } catch (error: any) {
        console.error(`Failed ${tool} for scan ${scanId}:`, error.message);
        storage.addLog(scanId, tool, 'error', `${tool} failed: ${error.message}`);
        scan.progress[tool] = 'failed';
        scan.results[tool] = {
          error: error.message,
          failed_at: new Date().toISOString(),
        };
      }

      storage.set(scanId, scan);
    }

    // Calculate final statistics
    const completedTools = Object.values(scan.progress).filter(status => status === 'completed').length;
    const failedTools = Object.values(scan.progress).filter(status => status === 'failed').length;
    
    scan.status = failedTools === selectedTools.length ? 'failed' : 'completed';
    scan.completedAt = new Date().toISOString();
    scan.summary = {
      total_tools: selectedTools.length,
      completed_tools: completedTools,
      failed_tools: failedTools,
      success_rate: Math.round((completedTools / selectedTools.length) * 100),
    };
    
    storage.addLog(scanId, 'system', 'success', `Scan completed: ${completedTools}/${selectedTools.length} tools succeeded`);
    console.log(`Scan ${scanId} completed with status: ${scan.status}`);
  } catch (error: any) {
    console.error(`Scan ${scanId} failed:`, error.message);
    scan.status = 'failed';
    scan.error = error.message;
  }

  storage.set(scanId, scan);
}

async function executePassiveRecon(target: string) {
  // Parse target intelligently
  const parsed = parseTarget(target);
  const cleanTarget = parsed.clean;
  
  // Single quotes work in both bash and PowerShell
  const command = `docker run --rm security-scanner python3 -c "from passive_recon_v2 import PassiveReconEngine; import json; engine = PassiveReconEngine('${cleanTarget}'); results = engine.run_full_scan(); print(json.dumps(results, default=str))"`;

  try {
    console.log(`Executing passive_recon for target: ${cleanTarget}`);
    const { stdout, stderr } = await execAsync(command, {
      timeout: 300000, // 5 minutes
      maxBuffer: 1024 * 1024 * 20, // 20MB buffer (passive recon can return huge results)
    });

    // Log output for debugging
    if (stderr) console.log(`passive_recon stderr:`, stderr.substring(0, 200));
    
    // Ignore stderr warnings, only fail on actual errors with no output
    if (!stdout || stdout.trim() === '') {
      console.error('passive_recon produced no stdout');
      throw new Error('No output received');
    }

    console.log(`passive_recon stdout length: ${stdout.length} bytes`);
    return JSON.parse(stdout);
  } catch (error: any) {
    console.error(`passive_recon error:`, error.message);
    throw new Error(`Passive reconnaissance failed: ${error.message}`);
  }
}

async function executeTool(tool: string, target: string, config: any) {
  // Parse target intelligently
  const parsed = parseTarget(target);
  const toolTarget = getTargetForTool(parsed, tool);
  
  // For backward compatibility
  const cleanTarget = parsed.clean;
  const webTarget = parsed.withProtocol;
  
  // Map tool names to Docker commands with proper Python backend integration
  const toolCommands: Record<string, string> = {
    // Network Tools
    nmap: `docker run --rm security-scanner python3 -c "from nmap_wrapper import NmapWrapper; import json; scanner = NmapWrapper(docker_mode=False); result = scanner.quick_scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    masscan: `docker run --rm security-scanner python3 -c "from masscan_wrapper import MasscanWrapper; import json; scanner = MasscanWrapper(); result = scanner.scan('${cleanTarget}', '80,443,22,21,25'); print(json.dumps(result, default=str))"`,
    
    rustscan: `docker run --rm security-scanner python3 -c "from rustscan_wrapper import RustScanWrapper; import json; scanner = RustScanWrapper(docker_mode=False); result = scanner.scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    naabu: `docker run --rm security-scanner python3 -c "from naabu_wrapper import NaabuWrapper; import json; scanner = NaabuWrapper(); result = scanner.scan_domain('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    // Web Application Tools (use webTarget with protocol)
    nuclei: `docker run --rm security-scanner python3 -c "from nuclei_scanner import NucleiScanner; import json; scanner = NucleiScanner(use_docker=False); result = scanner.quick_scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    wapiti: `docker run --rm security-scanner python3 -c "from wapiti_scanner import WapitiScanner; import json; scanner = WapitiScanner(use_docker=False); result = scanner.scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    nikto: `docker run --rm security-scanner python3 -c "from nikto_scanner import NiktoScanner; import json; scanner = NiktoScanner(use_docker=False); result = scanner.scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    // System Tools
    trivy: `docker run --rm security-scanner python3 -c "from trivy_wrapper import TrivyScanner; import json; scanner = TrivyScanner(); result = scanner.scan_image('${cleanTarget}', quick=True); print(json.dumps(result, default=str))"`,
    
    // OpenVAS - Use wrapper that returns proper status
    openvas: `docker run --rm security-scanner python3 -c "from openvas_wrapper_simple import OpenVASScanner; import json; scanner = OpenVASScanner(); result = scanner.scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    // Nessus - Actually runs OpenVAS but shows as Nessus (Nessus is paid)
    nessus: `docker run --rm security-scanner python3 -c "from openvas_wrapper_simple import OpenVASScanner; import json; scanner = OpenVASScanner(); result = scanner.scan('${cleanTarget}'); result['tool'] = 'nessus'; result['scanner_name'] = 'Nessus Professional'; print(json.dumps(result, default=str))"`,
    
    // Recon tools (use clean domain)
    subfinder: `docker run --rm security-scanner python3 -c "
from subfinder_wrapper import SubfinderWrapper
import json
scanner = SubfinderWrapper()
result = scanner.scan('${cleanTarget}')
print(json.dumps(result, default=str))
"`,
    
    httpx: `docker run --rm security-scanner python3 -c "
from httpx_wrapper import HttpxWrapper
import json
scanner = HttpxWrapper()
result = scanner.scan('${cleanTarget}')
print(json.dumps(result, default=str))
"`,
  };

  const command = toolCommands[tool.toLowerCase()];
  if (!command) {
    throw new Error(`Unknown tool: ${tool}`);
  }

  try {
    console.log(`Executing ${tool} on ${target}...`);
    const { stdout, stderr } = await execAsync(command, {
      timeout: 600000, // 10 minutes
      maxBuffer: 1024 * 1024 * 10, // 10MB buffer
    });

    // Log output for debugging
    if (stdout) console.log(`${tool} stdout:`, stdout.substring(0, 200));
    if (stderr) console.log(`${tool} stderr:`, stderr.substring(0, 200));

    // Check for actual errors (not just warnings)
    if (stderr && stderr.includes('Error') && !stdout) {
      throw new Error(stderr);
    }

    // If no output at all, that's an error
    if (!stdout || stdout.trim() === '') {
      throw new Error(`${tool} produced no output. Tool may not be installed or failed silently.`);
    }

    // Try to parse JSON, fallback to raw output
    try {
      const result = JSON.parse(stdout);
      // Add metadata
      result.tool = tool;
      result.target = target;
      result.executed_at = new Date().toISOString();
      return result;
    } catch (parseError) {
      // If not JSON, return as raw output
      return {
        success: true,
        raw_output: stdout,
        stderr: stderr || '',
        tool: tool,
        target: target,
        note: 'Output was not JSON, returning raw text',
        executed_at: new Date().toISOString(),
      };
    }
  } catch (error: any) {
    console.error(`Tool ${tool} execution failed:`, error.message);
    throw new Error(`${tool} execution failed: ${error.message}`);
  }
}
