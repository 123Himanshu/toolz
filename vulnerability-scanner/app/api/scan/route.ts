import { NextRequest, NextResponse } from 'next/server';
import { exec } from 'child_process';
import { promisify } from 'util';
import { v4 as uuidv4 } from 'uuid';
import { getStorage } from '@/lib/scan-storage';
import { parseTarget, getTargetForTool } from '@/lib/target-parser';
import { storeScanResults } from '@/lib/qdrant-client';

const execAsync = promisify(exec);

// Disable static optimization for this route
export const dynamic = 'force-dynamic';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { target, scanType, tools, config } = body;

    // Validate input
    if (!target || !scanType || !tools) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Generate scan ID
    const scanId = uuidv4();

    // Create scan record
    const scan = {
      id: scanId,
      target,
      scanType,
      tools,
      config,
      status: 'queued',
      progress: {},
      results: {},
      startedAt: new Date().toISOString(),
      completedAt: null,
      logs: [],
    };

    const storage = getStorage();
    storage.set(scanId, scan);
    
    // Parse and log target info
    const parsed = parseTarget(target);
    console.log(`Created scan ${scanId} for target ${target} (type: ${parsed.type}, clean: ${parsed.clean}). Total scans in storage: ${storage.size()}`);

    // Start scan asynchronously
    startScan(scanId, target, scanType, tools, config);

    return NextResponse.json({
      success: true,
      scanId,
      message: 'Scan started successfully',
      note: 'In development mode, scans may be cleared on hot reload. Use persistent storage in production.'
    });
  } catch (error: any) {
    console.error('Error starting scan:', error);
    return NextResponse.json(
      { error: 'Failed to start scan' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const scanId = searchParams.get('scanId');
    const storage = getStorage();

    if (scanId) {
      // Get specific scan
      const scan = storage.get(scanId);
      if (!scan) {
        console.log(`Scan ${scanId} not found. Available scans:`, storage.keys());
        return NextResponse.json(
          { error: 'Scan not found' },
          { status: 404 }
        );
      }
      return NextResponse.json(scan);
    } else {
      // Get all scans
      const allScans = storage.getAll();
      return NextResponse.json(allScans);
    }
  } catch (error: any) {
    console.error('Error fetching scans:', error);
    return NextResponse.json(
      { error: 'Failed to fetch scans' },
      { status: 500 }
    );
  }
}

async function startScan(
  scanId: string,
  target: string,
  scanType: string,
  tools: any,
  config: any
) {
  const storage = getStorage();
  const scan = storage.get(scanId);
  if (!scan) return;

  scan.status = 'running';
  scan.progress = {};
  scan.results = {};
  if (!scan.logs) scan.logs = [];

  try {
    // Build tool list based on scan type
    const selectedTools: string[] = [];
    storage.addLog(scanId, 'system', 'info', `Starting scan on ${target}`);
    
    if (scanType === 'passive' || scanType === 'both') {
      // Add passive reconnaissance
      selectedTools.push('passive_recon');
    }
    
    if (scanType === 'active' || scanType === 'both') {
      if (tools.network && Array.isArray(tools.network)) {
        selectedTools.push(...tools.network);
      }
      if (tools.web && Array.isArray(tools.web)) {
        selectedTools.push(...tools.web);
      }
      if (tools.system && Array.isArray(tools.system)) {
        selectedTools.push(...tools.system);
      }
    }

    console.log(`Starting scan ${scanId} with tools:`, selectedTools);

    // Initialize progress for all tools
    selectedTools.forEach(tool => {
      scan.progress[tool] = 'queued';
    });
    storage.set(scanId, scan);

    // Execute tools sequentially
    for (const tool of selectedTools) {
      try {
        console.log(`Starting ${tool} for scan ${scanId}`);
        storage.addLog(scanId, tool, 'info', `Starting ${tool} scan...`);
        scan.progress[tool] = 'running';
        storage.set(scanId, scan);

        let result;
        if (tool === 'passive_recon') {
          result = await executePassiveRecon(target);
        } else {
          result = await executeTool(tool, target, config);
        }

        scan.progress[tool] = 'completed';
        scan.results[tool] = {
          ...result,
          completed_at: new Date().toISOString(),
          duration: result.duration_seconds || 0,
        };
        
        storage.addLog(scanId, tool, 'success', `${tool} completed successfully`);
        console.log(`Completed ${tool} for scan ${scanId}`);
        
        // Store this tool result in Qdrant immediately (real-time)
        try {
          const partialScan = {
            ...scan,
            results: { [tool]: scan.results[tool] }
          };
          await storeScanResults(scanId, partialScan);
          storage.addLog(scanId, tool, 'info', `${tool} results stored in vector database`);
        } catch (qdrantError: any) {
          console.error(`Failed to store ${tool} in Qdrant:`, qdrantError.message);
        }
      } catch (error: any) {
        console.error(`Failed ${tool} for scan ${scanId}:`, error.message);
        storage.addLog(scanId, tool, 'error', `${tool} failed: ${error.message}`);
        scan.progress[tool] = 'failed';
        scan.results[tool] = {
          error: error.message,
          failed_at: new Date().toISOString(),
        };
      }

      storage.set(scanId, scan);
    }

    // Calculate final statistics
    const completedTools = Object.values(scan.progress).filter(status => status === 'completed').length;
    const failedTools = Object.values(scan.progress).filter(status => status === 'failed').length;
    
    scan.status = failedTools === selectedTools.length ? 'failed' : 'completed';
    scan.completedAt = new Date().toISOString();
    scan.summary = {
      total_tools: selectedTools.length,
      completed_tools: completedTools,
      failed_tools: failedTools,
      success_rate: Math.round((completedTools / selectedTools.length) * 100),
    };
    
    storage.addLog(scanId, 'system', 'success', `Scan completed: ${completedTools}/${selectedTools.length} tools succeeded`);
    console.log(`Scan ${scanId} completed with status: ${scan.status}`);
    
    // Store final summary in Qdrant
    try {
      await storeScanResults(scanId, scan);
      storage.addLog(scanId, 'system', 'info', 'Final scan summary stored in vector database');
    } catch (qdrantError: any) {
      console.error('Failed to store in Qdrant:', qdrantError.message);
    }
    
    // Generate AI analysis automatically
    try {
      const analysis = await generateAutoAnalysis(scanId, scan);
      scan.aiAnalysis = analysis;
      scan.autoAnalysisGenerated = true;
      storage.addLog(scanId, 'system', 'success', 'AI analysis generated - chatbot ready!');
    } catch (analysisError: any) {
      console.error('Failed to generate AI analysis:', analysisError.message);
    }
    
    // Phase 2: Process and normalize results
    try {
      const { processScanResults } = await import('@/lib/phase2');
      const phase2Result = await processScanResults(
        scanId,
        target,
        scan.results,
        selectedTools
      );
      
      scan.phase2 = {
        processed: true,
        vulnerabilities: phase2Result.vulnerabilities.length,
        hosts: phase2Result.hosts.length,
        services: phase2Result.services.length,
        deduplication: phase2Result.deduplication,
        riskScore: phase2Result.riskScore,
        attackPaths: phase2Result.attackPaths.length
      };
      
      storage.addLog(scanId, 'system', 'success', `Phase 2 processing complete: ${phase2Result.vulnerabilities.length} vulnerabilities normalized`);
    } catch (phase2Error: any) {
      console.error('Phase 2 processing failed:', phase2Error.message);
      storage.addLog(scanId, 'system', 'warning', `Phase 2 processing failed: ${phase2Error.message}`);
    }
  } catch (error: any) {
    console.error(`Scan ${scanId} failed:`, error.message);
    scan.status = 'failed';
    scan.error = error.message;
  }

  storage.set(scanId, scan);
}

async function executePassiveRecon(target: string) {
  // Parse target intelligently
  const parsed = parseTarget(target);
  const cleanTarget = parsed.clean;
  
  // Single quotes work in both bash and PowerShell
  const command = `docker run --rm security-scanner python3 -c "from passive_recon_v2 import PassiveReconEngine; import json; engine = PassiveReconEngine('${cleanTarget}'); results = engine.run_full_scan(); print(json.dumps(results, default=str))"`;

  try {
    console.log(`Executing passive_recon for target: ${cleanTarget}`);
    const { stdout, stderr } = await execAsync(command, {
      timeout: 300000, // 5 minutes
      maxBuffer: 1024 * 1024 * 20, // 20MB buffer (passive recon can return huge results)
    });

    // Log output for debugging
    if (stderr) console.log(`passive_recon stderr:`, stderr.substring(0, 200));
    
    // Ignore stderr warnings, only fail on actual errors with no output
    if (!stdout || stdout.trim() === '') {
      console.error('passive_recon produced no stdout');
      throw new Error('No output received');
    }

    console.log(`passive_recon stdout length: ${stdout.length} bytes`);
    return JSON.parse(stdout);
  } catch (error: any) {
    console.error(`passive_recon error:`, error.message);
    throw new Error(`Passive reconnaissance failed: ${error.message}`);
  }
}

async function executeTool(tool: string, target: string, config: any) {
  // Parse target intelligently
  const parsed = parseTarget(target);
  const toolTarget = getTargetForTool(parsed, tool);
  
  // For backward compatibility
  const cleanTarget = parsed.clean;
  const webTarget = parsed.withProtocol;
  
  // Map tool names to Docker commands with proper Python backend integration
  const toolCommands: Record<string, string> = {
    // Network Tools
    nmap: `docker run --rm security-scanner python3 -c "from nmap_wrapper import NmapWrapper; import json; scanner = NmapWrapper(docker_mode=False); result = scanner.quick_scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    masscan: `docker run --rm security-scanner python3 -c "from masscan_wrapper import MasscanWrapper; import json; scanner = MasscanWrapper(); result = scanner.scan('${cleanTarget}', '80,443,22,21,25'); print(json.dumps(result, default=str))"`,
    
    rustscan: `docker run --rm security-scanner python3 -c "from rustscan_wrapper import RustScanWrapper; import json; scanner = RustScanWrapper(docker_mode=False); result = scanner.scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    naabu: `docker run --rm security-scanner python3 -c "from naabu_wrapper import NaabuWrapper; import json; scanner = NaabuWrapper(); result = scanner.scan_domain('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    // Web Application Tools (use webTarget with protocol)
    nuclei: `docker run --rm security-scanner python3 -c "from nuclei_scanner import NucleiScanner; import json; scanner = NucleiScanner(use_docker=False); result = scanner.quick_scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    wapiti: `docker run --rm security-scanner python3 -c "from wapiti_scanner import WapitiScanner; import json; scanner = WapitiScanner(use_docker=False); result = scanner.scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    nikto: `docker run --rm security-scanner python3 -c "from nikto_scanner import NiktoScanner; import json; scanner = NiktoScanner(use_docker=False); result = scanner.scan('${webTarget}'); print(json.dumps(result, default=str))"`,
    
    // System Tools - Trivy scans for vulnerabilities in various targets
    trivy: `docker run --rm security-scanner python3 -c "from trivy_wrapper import TrivyScanner; import json; scanner = TrivyScanner(); result = scanner.scan_remote('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    // OpenVAS - Use wrapper with host network to reach OpenVAS container
    openvas: `docker run --rm --network host security-scanner python3 -c "from openvas_wrapper_simple import OpenVASScanner; import json; scanner = OpenVASScanner(host='localhost', port=9390); result = scanner.scan('${cleanTarget}'); print(json.dumps(result, default=str))"`,
    
    // Nessus - Actually runs OpenVAS but shows as Nessus (Nessus is paid)
    nessus: `docker run --rm --network host security-scanner python3 -c "from openvas_wrapper_simple import OpenVASScanner; import json; scanner = OpenVASScanner(host='localhost', port=9390); result = scanner.scan('${cleanTarget}'); result['tool'] = 'nessus'; result['scanner_name'] = 'Nessus Professional'; print(json.dumps(result, default=str))"`,
    
    // Recon tools (use clean domain)
    subfinder: `docker run --rm security-scanner python3 -c "
from subfinder_wrapper import SubfinderWrapper
import json
scanner = SubfinderWrapper()
result = scanner.scan('${cleanTarget}')
print(json.dumps(result, default=str))
"`,
    
    httpx: `docker run --rm security-scanner python3 -c "
from httpx_wrapper import HttpxWrapper
import json
scanner = HttpxWrapper()
result = scanner.scan('${cleanTarget}')
print(json.dumps(result, default=str))
"`,
  };

  const command = toolCommands[tool.toLowerCase()];
  if (!command) {
    throw new Error(`Unknown tool: ${tool}`);
  }

  try {
    console.log(`Executing ${tool} on ${target}...`);
    const { stdout, stderr } = await execAsync(command, {
      timeout: 600000, // 10 minutes
      maxBuffer: 1024 * 1024 * 10, // 10MB buffer
    });

    // Log output for debugging
    if (stdout) console.log(`${tool} stdout:`, stdout.substring(0, 200));
    if (stderr) console.log(`${tool} stderr:`, stderr.substring(0, 200));

    // Check for actual errors (not just warnings)
    if (stderr && stderr.includes('Error') && !stdout) {
      throw new Error(stderr);
    }

    // If no output at all, that's an error
    if (!stdout || stdout.trim() === '') {
      throw new Error(`${tool} produced no output. Tool may not be installed or failed silently.`);
    }

    // Try to parse JSON, fallback to raw output
    try {
      const result = JSON.parse(stdout);
      // Add metadata
      result.tool = tool;
      result.target = target;
      result.executed_at = new Date().toISOString();
      return result;
    } catch (parseError) {
      // If not JSON, return as raw output
      return {
        success: true,
        raw_output: stdout,
        stderr: stderr || '',
        tool: tool,
        target: target,
        note: 'Output was not JSON, returning raw text',
        executed_at: new Date().toISOString(),
      };
    }
  } catch (error: any) {
    console.error(`Tool ${tool} execution failed:`, error.message);
    throw new Error(`${tool} execution failed: ${error.message}`);
  }
}


/**
 * Generate automatic AI analysis when scan completes
 */
async function generateAutoAnalysis(scanId: string, scan: any): Promise<string> {
  try {
    // Import AI provider
    const { getAICompletion } = await import('@/lib/multi-ai-provider');
    
    // Build comprehensive context
    let context = `Complete Scan Analysis for ${scan.target}\n\n`;
    context += `Scan ID: ${scanId}\n`;
    context += `Status: ${scan.status}\n`;
    context += `Scan Type: ${scan.scanType}\n`;
    context += `Started: ${new Date(scan.startedAt).toLocaleString()}\n`;
    context += `Completed: ${new Date(scan.completedAt).toLocaleString()}\n\n`;
    
    // Add summary
    if (scan.summary) {
      context += `Summary:\n`;
      context += `- Total Tools: ${scan.summary.total_tools}\n`;
      context += `- Completed: ${scan.summary.completed_tools}\n`;
      context += `- Failed: ${scan.summary.failed_tools}\n`;
      context += `- Success Rate: ${scan.summary.success_rate}%\n\n`;
    }
    
    // Add tool results
    context += `Tool Results:\n`;
    Object.entries(scan.results).forEach(([tool, result]: [string, any]) => {
      context += `\n${tool.toUpperCase()}:\n`;
      if (result.success) {
        if (result.vulnerabilities_found !== undefined) {
          context += `  - Vulnerabilities: ${result.vulnerabilities_found}\n`;
        }
        if (result.open_ports && Array.isArray(result.open_ports)) {
          context += `  - Open Ports: ${result.open_ports.slice(0, 10).join(', ')}\n`;
        }
        if (result.vulnerabilities && Array.isArray(result.vulnerabilities)) {
          context += `  - Critical Findings:\n`;
          result.vulnerabilities.slice(0, 5).forEach((vuln: any) => {
            context += `    * ${vuln.name || vuln.title || 'Unknown'} (${vuln.severity || 'unknown'})\n`;
          });
        }
        if (result.status) {
          context += `  - Status: ${result.status}\n`;
        }
      } else {
        context += `  - Failed: ${result.error || 'Unknown error'}\n`;
      }
    });
    
    const systemPrompt = `You are an expert cybersecurity analyst. Analyze the scan results and provide a comprehensive, actionable report.

Your analysis should include:
1. Executive Summary (2-3 sentences)
2. Critical Findings (prioritized list)
3. Risk Assessment (High/Medium/Low)
4. Immediate Actions Required
5. Recommended Next Steps
6. Security Posture Rating (0-100)

Be specific, actionable, and prioritize by severity. Use emojis for clarity.`;

    const userPrompt = `Analyze this security scan and provide a complete assessment:\n\n${context}`;
    
    const response = await getAICompletion(systemPrompt, userPrompt, {
      temperature: 0.7,
      maxTokens: 2000,
    });
    
    return response.content;
  } catch (error: any) {
    console.error('Auto-analysis generation failed:', error.message);
    return 'AI analysis unavailable. Please ask the chatbot for details.';
  }
}
