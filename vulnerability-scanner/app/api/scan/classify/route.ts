/**
 * Target Classification API - Classify scan targets
 */

import { NextRequest, NextResponse } from 'next/server';

function classifyTarget(target: string): {
  type: string;
  classification: string;
  details: any;
} {
  const trimmed = target.trim();

  // IP address patterns
  const ipv4Regex = /^(\d{1,3}\.){3}\d{1,3}$/;
  const ipv6Regex = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/;
  const cidrRegex = /^(\d{1,3}\.){3}\d{1,3}\/\d{1,2}$/;

  // Domain patterns
  const domainRegex = /^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}$/;
  const subdomainRegex = /^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$/;

  // URL pattern
  const urlRegex = /^https?:\/\/.+/;

  if (ipv4Regex.test(trimmed)) {
    return {
      type: 'ipv4',
      classification: 'single_host',
      details: { ip: trimmed, version: 4 }
    };
  }

  if (ipv6Regex.test(trimmed)) {
    return {
      type: 'ipv6',
      classification: 'single_host',
      details: { ip: trimmed, version: 6 }
    };
  }

  if (cidrRegex.test(trimmed)) {
    const [ip, prefix] = trimmed.split('/');
    const hostCount = Math.pow(2, 32 - parseInt(prefix));
    return {
      type: 'cidr',
      classification: 'network_range',
      details: { network: ip, prefix: parseInt(prefix), estimatedHosts: hostCount }
    };
  }

  if (urlRegex.test(trimmed)) {
    const url = new URL(trimmed);
    return {
      type: 'url',
      classification: 'web_application',
      details: { protocol: url.protocol, hostname: url.hostname, path: url.pathname }
    };
  }

  if (domainRegex.test(trimmed) || subdomainRegex.test(trimmed)) {
    return {
      type: 'domain',
      classification: 'domain',
      details: { domain: trimmed, isSubdomain: trimmed.split('.').length > 2 }
    };
  }

  // Check for IP range (e.g., 192.168.1.1-100)
  if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}-\d{1,3}$/.test(trimmed)) {
    return {
      type: 'ip_range',
      classification: 'network_range',
      details: { range: trimmed }
    };
  }

  return {
    type: 'unknown',
    classification: 'unknown',
    details: { raw: trimmed }
  };
}

export async function GET(request: NextRequest) {
  const target = request.nextUrl.searchParams.get('target');

  if (!target) {
    return NextResponse.json({ success: false, error: 'Target parameter required' }, { status: 400 });
  }

  const result = classifyTarget(target);

  return NextResponse.json({
    success: true,
    target,
    ...result,
    recommendedTools: getRecommendedTools(result.type)
  });
}

function getRecommendedTools(type: string): string[] {
  switch (type) {
    case 'ipv4':
    case 'ipv6':
      return ['nmap', 'masscan', 'nuclei', 'trivy'];
    case 'cidr':
    case 'ip_range':
      return ['masscan', 'naabu', 'rustscan'];
    case 'domain':
      return ['subfinder', 'httpx', 'nuclei', 'nikto'];
    case 'url':
      return ['nuclei', 'nikto', 'wapiti'];
    default:
      return ['nmap', 'nuclei'];
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { targets } = body;

    if (!targets || !Array.isArray(targets)) {
      return NextResponse.json({ success: false, error: 'Targets array required' }, { status: 400 });
    }

    const results = targets.map(target => ({
      target,
      ...classifyTarget(target),
      recommendedTools: getRecommendedTools(classifyTarget(target).type)
    }));

    return NextResponse.json({
      success: true,
      total: results.length,
      classifications: results
    });
  } catch (error) {
    return NextResponse.json({ success: false, error: 'Invalid request body' }, { status: 400 });
  }
}
