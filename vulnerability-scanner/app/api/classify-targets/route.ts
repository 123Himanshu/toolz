/**
 * Target Classification API
 * Classifies targets by type (IP, domain, URL, CIDR range)
 */

import { NextRequest, NextResponse } from 'next/server';

interface ClassifiedTarget {
  original: string;
  type: 'ip' | 'ipv6' | 'domain' | 'url' | 'cidr' | 'unknown';
  clean: string;
  hostname?: string;
  port?: number;
  protocol?: string;
  isPrivate?: boolean;
  isLocalhost?: boolean;
}

function classifyTarget(target: string): ClassifiedTarget {
  const trimmed = target.trim();
  
  // Check for URL
  if (/^https?:\/\//i.test(trimmed)) {
    try {
      const url = new URL(trimmed);
      return {
        original: trimmed,
        type: 'url',
        clean: url.hostname,
        hostname: url.hostname,
        port: url.port ? parseInt(url.port) : (url.protocol === 'https:' ? 443 : 80),
        protocol: url.protocol.replace(':', ''),
      };
    } catch {
      return { original: trimmed, type: 'unknown', clean: trimmed };
    }
  }
  
  // Check for IPv4 CIDR
  if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}$/.test(trimmed)) {
    const [ip] = trimmed.split('/');
    return {
      original: trimmed,
      type: 'cidr',
      clean: trimmed,
      isPrivate: isPrivateIP(ip),
    };
  }
  
  // Check for IPv4
  if (/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(trimmed)) {
    return {
      original: trimmed,
      type: 'ip',
      clean: trimmed,
      isPrivate: isPrivateIP(trimmed),
      isLocalhost: trimmed === '127.0.0.1',
    };
  }
  
  // Check for IPv6
  if (/^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$/.test(trimmed) || trimmed === '::1') {
    return {
      original: trimmed,
      type: 'ipv6',
      clean: trimmed,
      isLocalhost: trimmed === '::1',
    };
  }
  
  // Check for domain
  if (/^[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9]?\.[a-zA-Z]{2,}$/.test(trimmed)) {
    return {
      original: trimmed,
      type: 'domain',
      clean: trimmed.toLowerCase(),
      hostname: trimmed.toLowerCase(),
    };
  }
  
  // Check for domain with subdomain
  if (/^([a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}$/.test(trimmed)) {
    return {
      original: trimmed,
      type: 'domain',
      clean: trimmed.toLowerCase(),
      hostname: trimmed.toLowerCase(),
    };
  }
  
  return { original: trimmed, type: 'unknown', clean: trimmed };
}

function isPrivateIP(ip: string): boolean {
  const parts = ip.split('.').map(Number);
  if (parts.length !== 4) return false;
  
  // 10.0.0.0/8
  if (parts[0] === 10) return true;
  // 172.16.0.0/12
  if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
  // 192.168.0.0/16
  if (parts[0] === 192 && parts[1] === 168) return true;
  // 127.0.0.0/8
  if (parts[0] === 127) return true;
  
  return false;
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { targets } = body;
    
    if (!targets || !Array.isArray(targets)) {
      return NextResponse.json(
        { success: false, error: 'targets array required' },
        { status: 400 }
      );
    }
    
    const classified = targets.map(classifyTarget);
    
    // Group by type
    const byType = {
      ip: classified.filter(t => t.type === 'ip'),
      ipv6: classified.filter(t => t.type === 'ipv6'),
      domain: classified.filter(t => t.type === 'domain'),
      url: classified.filter(t => t.type === 'url'),
      cidr: classified.filter(t => t.type === 'cidr'),
      unknown: classified.filter(t => t.type === 'unknown'),
    };
    
    // Statistics
    const stats = {
      total: targets.length,
      byType: {
        ip: byType.ip.length,
        ipv6: byType.ipv6.length,
        domain: byType.domain.length,
        url: byType.url.length,
        cidr: byType.cidr.length,
        unknown: byType.unknown.length,
      },
      privateTargets: classified.filter(t => t.isPrivate).length,
      localhostTargets: classified.filter(t => t.isLocalhost).length,
    };
    
    return NextResponse.json({
      success: true,
      classified,
      byType,
      stats,
    });
  } catch (error: any) {
    console.error('Classification error:', error);
    return NextResponse.json(
      { success: false, error: error.message },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const target = searchParams.get('target');
  
  if (!target) {
    return NextResponse.json(
      { success: false, error: 'target parameter required' },
      { status: 400 }
    );
  }
  
  const classified = classifyTarget(target);
  
  return NextResponse.json({
    success: true,
    ...classified,
  });
}
