"""
Zero-Day Exploit Behavior Detection
Detects suspicious exploitation patterns that may indicate zero-day activity
"""
from typing import List, Dict, Any
from models.schemas import NormalizedVulnerability, AttackPath, ZeroDayIndicator
from utils.logger import engine_logger
from collections import defaultdict
from datetime import datetime, timedelta

class ExploitBehaviorDetector:
    """Detect suspicious exploitation patterns"""
    
    def __init__(self):
        self.logger = engine_logger
        self.behavior_history = defaultdict(list)
    
    def detect_suspicious_behaviors(self, attack_paths: List[AttackPath], 
                                   vulnerabilities: List[NormalizedVulnerability]) -> List[ZeroDayIndicator]:
        """Detect suspicious exploitation behaviors"""
        
        indicators = []
        
        # Detect privilege escalation anomalies
        indicators.extend(self._detect_privilege_escalation_anomalies(attack_paths))
        
        # Detect unexpected lateral movement
        indicators.extend(self._detect_unexpected_lateral_movement(attack_paths))
        
        # Detect RCE-like patterns
        indicators.extend(self._detect_rce_patterns(vulnerabilities))
        
        # Detect suspicious pivot paths
        indicators.extend(self._detect_suspicious_pivots(attack_paths))
        
        # Detect toxic CVE combinations
        indicators.extend(self._detect_toxic_combinations(vulnerabilities))
        
        self.logger.info(f"Detected {len(indicators)} suspicious behaviors")
        
        return indicators
    
    def _detect_privilege_escalation_anomalies(self, attack_paths: List[AttackPath]) -> List[ZeroDayIndicator]:
        """Detect unusual privilege escalation patterns"""
        
        indicators = []
        
        for path in attack_paths:
            # Check for rapid privilege escalation
            priv_escalations = 0
            
            for step in path.steps:
                if step.privilege_gained in ['SYSTEM', 'ADMIN', 'ELEVATED']:
                    priv_escalations += 1
            
            # If multiple privilege escalations in a short path
            if priv_escalations >= 2 and len(path.steps) <= 3:
                indicators.append(ZeroDayIndicator(
                    asset_id=path.target,
                    indicator_type='behavior',
                    description=f'Rapid privilege escalation detected: {priv_escalations} escalations in {len(path.steps)} steps',
                    confidence=0.7,
                    severity='HIGH',
                    details={
                        'path_id': path.path_id,
                        'escalations': priv_escalations,
                        'steps': len(path.steps)
                    }
                ))
        
        return indicators
    
    def _detect_unexpected_lateral_movement(self, attack_paths: List[AttackPath]) -> List[ZeroDayIndicator]:
        """Detect unexpected lateral movement patterns"""
        
        indicators = []
        
        # Track lateral movements
        lateral_movements = defaultdict(int)
        
        for path in attack_paths:
            for i, step in enumerate(path.steps):
                if i > 0:  # Not the first step
                    # Check if moving to a different asset
                    if step.source_asset != step.target_asset:
                        key = f"{step.source_asset}->{step.target_asset}"
                        lateral_movements[key] += 1
        
        # Detect unusual patterns
        for movement, count in lateral_movements.items():
            if count >= 3:  # Multiple paths use same lateral movement
                source, target = movement.split('->')
                
                indicators.append(ZeroDayIndicator(
                    asset_id=target,
                    indicator_type='behavior',
                    description=f'Frequent lateral movement pattern: {movement} ({count} paths)',
                    confidence=0.6,
                    severity='MEDIUM',
                    details={
                        'source': source,
                        'target': target,
                        'frequency': count
                    }
                ))
        
        return indicators
    
    def _detect_rce_patterns(self, vulnerabilities: List[NormalizedVulnerability]) -> List[ZeroDayIndicator]:
        """Detect RCE-like vulnerability patterns"""
        
        indicators = []
        
        # Look for high-CVSS network-accessible vulnerabilities without CVE
        for vuln in vulnerabilities:
            if not vuln.cve_id:  # No known CVE
                if vuln.attack_vector == 'NETWORK':
                    if vuln.cvss_score and vuln.cvss_score >= 8.0:
                        indicators.append(ZeroDayIndicator(
                            asset_id=vuln.asset_id,
                            indicator_type='behavior',
                            description=f'Potential RCE pattern: High-severity network vulnerability without CVE on {vuln.service_name}',
                            confidence=0.5,
                            severity='HIGH',
                            details={
                                'service': vuln.service_name,
                                'port': vuln.port,
                                'cvss': vuln.cvss_score
                            }
                        ))
        
        # Look for command injection indicators
        command_injection_keywords = ['command', 'injection', 'exec', 'shell', 'code execution']
        
        for vuln in vulnerabilities:
            if vuln.misconfiguration:
                misc_lower = vuln.misconfiguration.lower()
                if any(keyword in misc_lower for keyword in command_injection_keywords):
                    indicators.append(ZeroDayIndicator(
                        asset_id=vuln.asset_id,
                        indicator_type='behavior',
                        description=f'Command injection pattern detected: {vuln.misconfiguration}',
                        confidence=0.6,
                        severity='HIGH',
                        details={'misconfiguration': vuln.misconfiguration}
                    ))
        
        return indicators
    
    def _detect_suspicious_pivots(self, attack_paths: List[AttackPath]) -> List[ZeroDayIndicator]:
        """Detect suspicious internal pivot paths"""
        
        indicators = []
        
        # Look for paths that pivot through multiple internal assets
        for path in attack_paths:
            internal_hops = 0
            
            for step in path.steps:
                # Count internal-to-internal movements
                if not step.source_asset.startswith('ATTACKER'):
                    internal_hops += 1
            
            # If path has many internal hops, it's suspicious
            if internal_hops >= 3:
                indicators.append(ZeroDayIndicator(
                    asset_id=path.target,
                    indicator_type='behavior',
                    description=f'Suspicious pivot path with {internal_hops} internal hops',
                    confidence=0.6,
                    severity='MEDIUM',
                    details={
                        'path_id': path.path_id,
                        'internal_hops': internal_hops,
                        'entry_point': path.entry_point,
                        'target': path.target
                    }
                ))
        
        return indicators
    
    def _detect_toxic_combinations(self, vulnerabilities: List[NormalizedVulnerability]) -> List[ZeroDayIndicator]:
        """Detect toxic CVE combinations that enable advanced attacks"""
        
        indicators = []
        
        # Group vulnerabilities by asset
        asset_vulns = defaultdict(list)
        for vuln in vulnerabilities:
            if vuln.cve_id:
                asset_vulns[vuln.asset_id].append(vuln)
        
        # Known toxic combinations (simplified)
        toxic_patterns = [
            # Info leak + RCE
            {'types': ['INFO_LEAK', 'RCE'], 'description': 'Information disclosure + Remote Code Execution'},
            # Auth bypass + Privilege escalation
            {'types': ['AUTH_BYPASS', 'PRIV_ESC'], 'description': 'Authentication bypass + Privilege escalation'},
            # Multiple RCEs
            {'types': ['RCE', 'RCE'], 'description': 'Multiple remote code execution vulnerabilities'}
        ]
        
        for asset_id, vulns in asset_vulns.items():
            # Check for high-severity CVE clusters
            high_severity = [v for v in vulns if v.cvss_score and v.cvss_score >= 7.0]
            
            if len(high_severity) >= 3:
                cve_list = [v.cve_id for v in high_severity]
                
                indicators.append(ZeroDayIndicator(
                    asset_id=asset_id,
                    indicator_type='behavior',
                    description=f'Toxic CVE combination: {len(high_severity)} high-severity vulnerabilities on same asset',
                    confidence=0.7,
                    severity='CRITICAL',
                    details={
                        'cve_count': len(high_severity),
                        'cves': cve_list[:5]  # Limit to first 5
                    }
                ))
        
        return indicators
    
    def analyze_exploit_chain(self, attack_path: AttackPath) -> Dict[str, Any]:
        """Analyze an attack path for exploit chain characteristics"""
        
        analysis = {
            'path_id': attack_path.path_id,
            'chain_length': len(attack_path.steps),
            'total_complexity': attack_path.total_complexity,
            'exploitability': attack_path.exploitability_score,
            'techniques_used': [],
            'privileges_gained': [],
            'risk_level': 'UNKNOWN'
        }
        
        # Extract techniques and privileges
        for step in attack_path.steps:
            if step.technique_id:
                analysis['techniques_used'].append(step.technique_id)
            if step.privilege_gained:
                analysis['privileges_gained'].append(step.privilege_gained)
        
        # Determine risk level
        if attack_path.exploitability_score >= 80:
            analysis['risk_level'] = 'CRITICAL'
        elif attack_path.exploitability_score >= 60:
            analysis['risk_level'] = 'HIGH'
        elif attack_path.exploitability_score >= 40:
            analysis['risk_level'] = 'MEDIUM'
        else:
            analysis['risk_level'] = 'LOW'
        
        return analysis
